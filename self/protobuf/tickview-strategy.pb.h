// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: tickview-strategy.proto

#ifndef GOOGLE_PROTOBUF_INCLUDED_tickview_2dstrategy_2eproto
#define GOOGLE_PROTOBUF_INCLUDED_tickview_2dstrategy_2eproto

#include <limits>
#include <string>

#include <google/protobuf/port_def.inc>
#if PROTOBUF_VERSION < 3021000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers. Please update
#error your headers.
#endif
#if 3021005 < PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers. Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/port_undef.inc>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/metadata_lite.h>
#include <google/protobuf/generated_message_reflection.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/generated_enum_reflection.h>
#include <google/protobuf/unknown_field_set.h>
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>
#define PROTOBUF_INTERNAL_EXPORT_tickview_2dstrategy_2eproto
PROTOBUF_NAMESPACE_OPEN
namespace internal {
class AnyMetadata;
}  // namespace internal
PROTOBUF_NAMESPACE_CLOSE

// Internal implementation detail -- do not use these members.
struct TableStruct_tickview_2dstrategy_2eproto {
  static const uint32_t offsets[];
};
extern const ::PROTOBUF_NAMESPACE_ID::internal::DescriptorTable descriptor_table_tickview_2dstrategy_2eproto;
namespace tickview_strategy {
class BatchControlReq;
struct BatchControlReqDefaultTypeInternal;
extern BatchControlReqDefaultTypeInternal _BatchControlReq_default_instance_;
class BugInjection;
struct BugInjectionDefaultTypeInternal;
extern BugInjectionDefaultTypeInternal _BugInjection_default_instance_;
class ClearDiagnosticEvent;
struct ClearDiagnosticEventDefaultTypeInternal;
extern ClearDiagnosticEventDefaultTypeInternal _ClearDiagnosticEvent_default_instance_;
class ClearOldRecord;
struct ClearOldRecordDefaultTypeInternal;
extern ClearOldRecordDefaultTypeInternal _ClearOldRecord_default_instance_;
class CloseAll;
struct CloseAllDefaultTypeInternal;
extern CloseAllDefaultTypeInternal _CloseAll_default_instance_;
class FrontAdjust;
struct FrontAdjustDefaultTypeInternal;
extern FrontAdjustDefaultTypeInternal _FrontAdjust_default_instance_;
class HeavyAttack;
struct HeavyAttackDefaultTypeInternal;
extern HeavyAttackDefaultTypeInternal _HeavyAttack_default_instance_;
class Level1ControlReq;
struct Level1ControlReqDefaultTypeInternal;
extern Level1ControlReqDefaultTypeInternal _Level1ControlReq_default_instance_;
class OrderConditionMandatorySet;
struct OrderConditionMandatorySetDefaultTypeInternal;
extern OrderConditionMandatorySetDefaultTypeInternal _OrderConditionMandatorySet_default_instance_;
class ProfilerControl;
struct ProfilerControlDefaultTypeInternal;
extern ProfilerControlDefaultTypeInternal _ProfilerControl_default_instance_;
class SyncInstrumentSet;
struct SyncInstrumentSetDefaultTypeInternal;
extern SyncInstrumentSetDefaultTypeInternal _SyncInstrumentSet_default_instance_;
class SyncTraderGroup;
struct SyncTraderGroupDefaultTypeInternal;
extern SyncTraderGroupDefaultTypeInternal _SyncTraderGroup_default_instance_;
class UnexpectedMinVolume;
struct UnexpectedMinVolumeDefaultTypeInternal;
extern UnexpectedMinVolumeDefaultTypeInternal _UnexpectedMinVolume_default_instance_;
class UpdateProjectPara;
struct UpdateProjectParaDefaultTypeInternal;
extern UpdateProjectParaDefaultTypeInternal _UpdateProjectPara_default_instance_;
class UpdateStrategyPara;
struct UpdateStrategyParaDefaultTypeInternal;
extern UpdateStrategyParaDefaultTypeInternal _UpdateStrategyPara_default_instance_;
class message;
struct messageDefaultTypeInternal;
extern messageDefaultTypeInternal _message_default_instance_;
}  // namespace tickview_strategy
PROTOBUF_NAMESPACE_OPEN
template<> ::tickview_strategy::BatchControlReq* Arena::CreateMaybeMessage<::tickview_strategy::BatchControlReq>(Arena*);
template<> ::tickview_strategy::BugInjection* Arena::CreateMaybeMessage<::tickview_strategy::BugInjection>(Arena*);
template<> ::tickview_strategy::ClearDiagnosticEvent* Arena::CreateMaybeMessage<::tickview_strategy::ClearDiagnosticEvent>(Arena*);
template<> ::tickview_strategy::ClearOldRecord* Arena::CreateMaybeMessage<::tickview_strategy::ClearOldRecord>(Arena*);
template<> ::tickview_strategy::CloseAll* Arena::CreateMaybeMessage<::tickview_strategy::CloseAll>(Arena*);
template<> ::tickview_strategy::FrontAdjust* Arena::CreateMaybeMessage<::tickview_strategy::FrontAdjust>(Arena*);
template<> ::tickview_strategy::HeavyAttack* Arena::CreateMaybeMessage<::tickview_strategy::HeavyAttack>(Arena*);
template<> ::tickview_strategy::Level1ControlReq* Arena::CreateMaybeMessage<::tickview_strategy::Level1ControlReq>(Arena*);
template<> ::tickview_strategy::OrderConditionMandatorySet* Arena::CreateMaybeMessage<::tickview_strategy::OrderConditionMandatorySet>(Arena*);
template<> ::tickview_strategy::ProfilerControl* Arena::CreateMaybeMessage<::tickview_strategy::ProfilerControl>(Arena*);
template<> ::tickview_strategy::SyncInstrumentSet* Arena::CreateMaybeMessage<::tickview_strategy::SyncInstrumentSet>(Arena*);
template<> ::tickview_strategy::SyncTraderGroup* Arena::CreateMaybeMessage<::tickview_strategy::SyncTraderGroup>(Arena*);
template<> ::tickview_strategy::UnexpectedMinVolume* Arena::CreateMaybeMessage<::tickview_strategy::UnexpectedMinVolume>(Arena*);
template<> ::tickview_strategy::UpdateProjectPara* Arena::CreateMaybeMessage<::tickview_strategy::UpdateProjectPara>(Arena*);
template<> ::tickview_strategy::UpdateStrategyPara* Arena::CreateMaybeMessage<::tickview_strategy::UpdateStrategyPara>(Arena*);
template<> ::tickview_strategy::message* Arena::CreateMaybeMessage<::tickview_strategy::message>(Arena*);
PROTOBUF_NAMESPACE_CLOSE
namespace tickview_strategy {

enum Level1ControlReq_Indication : int {
  Level1ControlReq_Indication_reserve = 0,
  Level1ControlReq_Indication_start = 1,
  Level1ControlReq_Indication_stop = 2,
  Level1ControlReq_Indication_Level1ControlReq_Indication_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  Level1ControlReq_Indication_Level1ControlReq_Indication_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
bool Level1ControlReq_Indication_IsValid(int value);
constexpr Level1ControlReq_Indication Level1ControlReq_Indication_Indication_MIN = Level1ControlReq_Indication_reserve;
constexpr Level1ControlReq_Indication Level1ControlReq_Indication_Indication_MAX = Level1ControlReq_Indication_stop;
constexpr int Level1ControlReq_Indication_Indication_ARRAYSIZE = Level1ControlReq_Indication_Indication_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* Level1ControlReq_Indication_descriptor();
template<typename T>
inline const std::string& Level1ControlReq_Indication_Name(T enum_t_value) {
  static_assert(::std::is_same<T, Level1ControlReq_Indication>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function Level1ControlReq_Indication_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    Level1ControlReq_Indication_descriptor(), enum_t_value);
}
inline bool Level1ControlReq_Indication_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, Level1ControlReq_Indication* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<Level1ControlReq_Indication>(
    Level1ControlReq_Indication_descriptor(), name, value);
}
enum OrderConditionMandatorySet_OrderCondition : int {
  OrderConditionMandatorySet_OrderCondition_reserve = 0,
  OrderConditionMandatorySet_OrderCondition_open_more = 1,
  OrderConditionMandatorySet_OrderCondition_open_short = 2,
  OrderConditionMandatorySet_OrderCondition_add_more = 3,
  OrderConditionMandatorySet_OrderCondition_add_short = 4,
  OrderConditionMandatorySet_OrderCondition_sync_open = 5,
  OrderConditionMandatorySet_OrderCondition_sync_close = 6,
  OrderConditionMandatorySet_OrderCondition_close_more = 7,
  OrderConditionMandatorySet_OrderCondition_close_short = 8,
  OrderConditionMandatorySet_OrderCondition_back_idle = 9,
  OrderConditionMandatorySet_OrderCondition_OrderConditionMandatorySet_OrderCondition_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  OrderConditionMandatorySet_OrderCondition_OrderConditionMandatorySet_OrderCondition_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
bool OrderConditionMandatorySet_OrderCondition_IsValid(int value);
constexpr OrderConditionMandatorySet_OrderCondition OrderConditionMandatorySet_OrderCondition_OrderCondition_MIN = OrderConditionMandatorySet_OrderCondition_reserve;
constexpr OrderConditionMandatorySet_OrderCondition OrderConditionMandatorySet_OrderCondition_OrderCondition_MAX = OrderConditionMandatorySet_OrderCondition_back_idle;
constexpr int OrderConditionMandatorySet_OrderCondition_OrderCondition_ARRAYSIZE = OrderConditionMandatorySet_OrderCondition_OrderCondition_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* OrderConditionMandatorySet_OrderCondition_descriptor();
template<typename T>
inline const std::string& OrderConditionMandatorySet_OrderCondition_Name(T enum_t_value) {
  static_assert(::std::is_same<T, OrderConditionMandatorySet_OrderCondition>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function OrderConditionMandatorySet_OrderCondition_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    OrderConditionMandatorySet_OrderCondition_descriptor(), enum_t_value);
}
inline bool OrderConditionMandatorySet_OrderCondition_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, OrderConditionMandatorySet_OrderCondition* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<OrderConditionMandatorySet_OrderCondition>(
    OrderConditionMandatorySet_OrderCondition_descriptor(), name, value);
}
enum BugInjection_InjectionType : int {
  BugInjection_InjectionType_reserve = 0,
  BugInjection_InjectionType_key_error = 1,
  BugInjection_InjectionType_noexist_ins = 2,
  BugInjection_InjectionType_expire_ins = 3,
  BugInjection_InjectionType_BugInjection_InjectionType_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  BugInjection_InjectionType_BugInjection_InjectionType_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
bool BugInjection_InjectionType_IsValid(int value);
constexpr BugInjection_InjectionType BugInjection_InjectionType_InjectionType_MIN = BugInjection_InjectionType_reserve;
constexpr BugInjection_InjectionType BugInjection_InjectionType_InjectionType_MAX = BugInjection_InjectionType_expire_ins;
constexpr int BugInjection_InjectionType_InjectionType_ARRAYSIZE = BugInjection_InjectionType_InjectionType_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* BugInjection_InjectionType_descriptor();
template<typename T>
inline const std::string& BugInjection_InjectionType_Name(T enum_t_value) {
  static_assert(::std::is_same<T, BugInjection_InjectionType>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function BugInjection_InjectionType_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    BugInjection_InjectionType_descriptor(), enum_t_value);
}
inline bool BugInjection_InjectionType_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, BugInjection_InjectionType* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<BugInjection_InjectionType>(
    BugInjection_InjectionType_descriptor(), name, value);
}
enum BugInjection_Indication : int {
  BugInjection_Indication_insert = 0,
  BugInjection_Indication_remove = 1,
  BugInjection_Indication_BugInjection_Indication_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  BugInjection_Indication_BugInjection_Indication_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
bool BugInjection_Indication_IsValid(int value);
constexpr BugInjection_Indication BugInjection_Indication_Indication_MIN = BugInjection_Indication_insert;
constexpr BugInjection_Indication BugInjection_Indication_Indication_MAX = BugInjection_Indication_remove;
constexpr int BugInjection_Indication_Indication_ARRAYSIZE = BugInjection_Indication_Indication_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* BugInjection_Indication_descriptor();
template<typename T>
inline const std::string& BugInjection_Indication_Name(T enum_t_value) {
  static_assert(::std::is_same<T, BugInjection_Indication>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function BugInjection_Indication_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    BugInjection_Indication_descriptor(), enum_t_value);
}
inline bool BugInjection_Indication_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, BugInjection_Indication* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<BugInjection_Indication>(
    BugInjection_Indication_descriptor(), name, value);
}
enum BatchControlReq_Indication : int {
  BatchControlReq_Indication_reserve = 0,
  BatchControlReq_Indication_start = 1,
  BatchControlReq_Indication_stop = 2,
  BatchControlReq_Indication_BatchControlReq_Indication_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  BatchControlReq_Indication_BatchControlReq_Indication_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
bool BatchControlReq_Indication_IsValid(int value);
constexpr BatchControlReq_Indication BatchControlReq_Indication_Indication_MIN = BatchControlReq_Indication_reserve;
constexpr BatchControlReq_Indication BatchControlReq_Indication_Indication_MAX = BatchControlReq_Indication_stop;
constexpr int BatchControlReq_Indication_Indication_ARRAYSIZE = BatchControlReq_Indication_Indication_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* BatchControlReq_Indication_descriptor();
template<typename T>
inline const std::string& BatchControlReq_Indication_Name(T enum_t_value) {
  static_assert(::std::is_same<T, BatchControlReq_Indication>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function BatchControlReq_Indication_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    BatchControlReq_Indication_descriptor(), enum_t_value);
}
inline bool BatchControlReq_Indication_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, BatchControlReq_Indication* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<BatchControlReq_Indication>(
    BatchControlReq_Indication_descriptor(), name, value);
}
enum ProfilerControl_ProfilerAction : int {
  ProfilerControl_ProfilerAction_reserve = 0,
  ProfilerControl_ProfilerAction_start_write = 1,
  ProfilerControl_ProfilerAction_stop_write = 2,
  ProfilerControl_ProfilerAction_ProfilerControl_ProfilerAction_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  ProfilerControl_ProfilerAction_ProfilerControl_ProfilerAction_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
bool ProfilerControl_ProfilerAction_IsValid(int value);
constexpr ProfilerControl_ProfilerAction ProfilerControl_ProfilerAction_ProfilerAction_MIN = ProfilerControl_ProfilerAction_reserve;
constexpr ProfilerControl_ProfilerAction ProfilerControl_ProfilerAction_ProfilerAction_MAX = ProfilerControl_ProfilerAction_stop_write;
constexpr int ProfilerControl_ProfilerAction_ProfilerAction_ARRAYSIZE = ProfilerControl_ProfilerAction_ProfilerAction_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* ProfilerControl_ProfilerAction_descriptor();
template<typename T>
inline const std::string& ProfilerControl_ProfilerAction_Name(T enum_t_value) {
  static_assert(::std::is_same<T, ProfilerControl_ProfilerAction>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function ProfilerControl_ProfilerAction_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    ProfilerControl_ProfilerAction_descriptor(), enum_t_value);
}
inline bool ProfilerControl_ProfilerAction_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, ProfilerControl_ProfilerAction* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<ProfilerControl_ProfilerAction>(
    ProfilerControl_ProfilerAction_descriptor(), name, value);
}
enum UpdateProjectPara_UpdateAction : int {
  UpdateProjectPara_UpdateAction_reserve = 0,
  UpdateProjectPara_UpdateAction_update = 1,
  UpdateProjectPara_UpdateAction_noupdate = 2,
  UpdateProjectPara_UpdateAction_UpdateProjectPara_UpdateAction_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  UpdateProjectPara_UpdateAction_UpdateProjectPara_UpdateAction_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
bool UpdateProjectPara_UpdateAction_IsValid(int value);
constexpr UpdateProjectPara_UpdateAction UpdateProjectPara_UpdateAction_UpdateAction_MIN = UpdateProjectPara_UpdateAction_reserve;
constexpr UpdateProjectPara_UpdateAction UpdateProjectPara_UpdateAction_UpdateAction_MAX = UpdateProjectPara_UpdateAction_noupdate;
constexpr int UpdateProjectPara_UpdateAction_UpdateAction_ARRAYSIZE = UpdateProjectPara_UpdateAction_UpdateAction_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* UpdateProjectPara_UpdateAction_descriptor();
template<typename T>
inline const std::string& UpdateProjectPara_UpdateAction_Name(T enum_t_value) {
  static_assert(::std::is_same<T, UpdateProjectPara_UpdateAction>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function UpdateProjectPara_UpdateAction_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    UpdateProjectPara_UpdateAction_descriptor(), enum_t_value);
}
inline bool UpdateProjectPara_UpdateAction_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, UpdateProjectPara_UpdateAction* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<UpdateProjectPara_UpdateAction>(
    UpdateProjectPara_UpdateAction_descriptor(), name, value);
}
enum UpdateStrategyPara_UpdateAction : int {
  UpdateStrategyPara_UpdateAction_reserve = 0,
  UpdateStrategyPara_UpdateAction_update = 1,
  UpdateStrategyPara_UpdateAction_noupdate = 2,
  UpdateStrategyPara_UpdateAction_UpdateStrategyPara_UpdateAction_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  UpdateStrategyPara_UpdateAction_UpdateStrategyPara_UpdateAction_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
bool UpdateStrategyPara_UpdateAction_IsValid(int value);
constexpr UpdateStrategyPara_UpdateAction UpdateStrategyPara_UpdateAction_UpdateAction_MIN = UpdateStrategyPara_UpdateAction_reserve;
constexpr UpdateStrategyPara_UpdateAction UpdateStrategyPara_UpdateAction_UpdateAction_MAX = UpdateStrategyPara_UpdateAction_noupdate;
constexpr int UpdateStrategyPara_UpdateAction_UpdateAction_ARRAYSIZE = UpdateStrategyPara_UpdateAction_UpdateAction_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* UpdateStrategyPara_UpdateAction_descriptor();
template<typename T>
inline const std::string& UpdateStrategyPara_UpdateAction_Name(T enum_t_value) {
  static_assert(::std::is_same<T, UpdateStrategyPara_UpdateAction>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function UpdateStrategyPara_UpdateAction_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    UpdateStrategyPara_UpdateAction_descriptor(), enum_t_value);
}
inline bool UpdateStrategyPara_UpdateAction_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, UpdateStrategyPara_UpdateAction* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<UpdateStrategyPara_UpdateAction>(
    UpdateStrategyPara_UpdateAction_descriptor(), name, value);
}
enum CloseAll_CloseAction : int {
  CloseAll_CloseAction_reserve = 0,
  CloseAll_CloseAction_can_open_again_in_this_day = 1,
  CloseAll_CloseAction_cannot_open_again_in_this_day = 2,
  CloseAll_CloseAction_CloseAll_CloseAction_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  CloseAll_CloseAction_CloseAll_CloseAction_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
bool CloseAll_CloseAction_IsValid(int value);
constexpr CloseAll_CloseAction CloseAll_CloseAction_CloseAction_MIN = CloseAll_CloseAction_reserve;
constexpr CloseAll_CloseAction CloseAll_CloseAction_CloseAction_MAX = CloseAll_CloseAction_cannot_open_again_in_this_day;
constexpr int CloseAll_CloseAction_CloseAction_ARRAYSIZE = CloseAll_CloseAction_CloseAction_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* CloseAll_CloseAction_descriptor();
template<typename T>
inline const std::string& CloseAll_CloseAction_Name(T enum_t_value) {
  static_assert(::std::is_same<T, CloseAll_CloseAction>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function CloseAll_CloseAction_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    CloseAll_CloseAction_descriptor(), enum_t_value);
}
inline bool CloseAll_CloseAction_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, CloseAll_CloseAction* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<CloseAll_CloseAction>(
    CloseAll_CloseAction_descriptor(), name, value);
}
enum ClearOldRecord_ClearAction : int {
  ClearOldRecord_ClearAction_reserve = 0,
  ClearOldRecord_ClearAction_clear = 1,
  ClearOldRecord_ClearAction_noclear = 2,
  ClearOldRecord_ClearAction_ClearOldRecord_ClearAction_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  ClearOldRecord_ClearAction_ClearOldRecord_ClearAction_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
bool ClearOldRecord_ClearAction_IsValid(int value);
constexpr ClearOldRecord_ClearAction ClearOldRecord_ClearAction_ClearAction_MIN = ClearOldRecord_ClearAction_reserve;
constexpr ClearOldRecord_ClearAction ClearOldRecord_ClearAction_ClearAction_MAX = ClearOldRecord_ClearAction_noclear;
constexpr int ClearOldRecord_ClearAction_ClearAction_ARRAYSIZE = ClearOldRecord_ClearAction_ClearAction_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* ClearOldRecord_ClearAction_descriptor();
template<typename T>
inline const std::string& ClearOldRecord_ClearAction_Name(T enum_t_value) {
  static_assert(::std::is_same<T, ClearOldRecord_ClearAction>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function ClearOldRecord_ClearAction_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    ClearOldRecord_ClearAction_descriptor(), enum_t_value);
}
inline bool ClearOldRecord_ClearAction_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, ClearOldRecord_ClearAction* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<ClearOldRecord_ClearAction>(
    ClearOldRecord_ClearAction_descriptor(), name, value);
}
enum SyncInstrumentSet_SyncAction : int {
  SyncInstrumentSet_SyncAction_reserve = 0,
  SyncInstrumentSet_SyncAction_sync = 1,
  SyncInstrumentSet_SyncAction_nosync = 2,
  SyncInstrumentSet_SyncAction_SyncInstrumentSet_SyncAction_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  SyncInstrumentSet_SyncAction_SyncInstrumentSet_SyncAction_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
bool SyncInstrumentSet_SyncAction_IsValid(int value);
constexpr SyncInstrumentSet_SyncAction SyncInstrumentSet_SyncAction_SyncAction_MIN = SyncInstrumentSet_SyncAction_reserve;
constexpr SyncInstrumentSet_SyncAction SyncInstrumentSet_SyncAction_SyncAction_MAX = SyncInstrumentSet_SyncAction_nosync;
constexpr int SyncInstrumentSet_SyncAction_SyncAction_ARRAYSIZE = SyncInstrumentSet_SyncAction_SyncAction_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* SyncInstrumentSet_SyncAction_descriptor();
template<typename T>
inline const std::string& SyncInstrumentSet_SyncAction_Name(T enum_t_value) {
  static_assert(::std::is_same<T, SyncInstrumentSet_SyncAction>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function SyncInstrumentSet_SyncAction_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    SyncInstrumentSet_SyncAction_descriptor(), enum_t_value);
}
inline bool SyncInstrumentSet_SyncAction_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, SyncInstrumentSet_SyncAction* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<SyncInstrumentSet_SyncAction>(
    SyncInstrumentSet_SyncAction_descriptor(), name, value);
}
enum SyncTraderGroup_SyncAction : int {
  SyncTraderGroup_SyncAction_reserve = 0,
  SyncTraderGroup_SyncAction_sync = 1,
  SyncTraderGroup_SyncAction_nosync = 2,
  SyncTraderGroup_SyncAction_SyncTraderGroup_SyncAction_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  SyncTraderGroup_SyncAction_SyncTraderGroup_SyncAction_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
bool SyncTraderGroup_SyncAction_IsValid(int value);
constexpr SyncTraderGroup_SyncAction SyncTraderGroup_SyncAction_SyncAction_MIN = SyncTraderGroup_SyncAction_reserve;
constexpr SyncTraderGroup_SyncAction SyncTraderGroup_SyncAction_SyncAction_MAX = SyncTraderGroup_SyncAction_nosync;
constexpr int SyncTraderGroup_SyncAction_SyncAction_ARRAYSIZE = SyncTraderGroup_SyncAction_SyncAction_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* SyncTraderGroup_SyncAction_descriptor();
template<typename T>
inline const std::string& SyncTraderGroup_SyncAction_Name(T enum_t_value) {
  static_assert(::std::is_same<T, SyncTraderGroup_SyncAction>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function SyncTraderGroup_SyncAction_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    SyncTraderGroup_SyncAction_descriptor(), enum_t_value);
}
inline bool SyncTraderGroup_SyncAction_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, SyncTraderGroup_SyncAction* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<SyncTraderGroup_SyncAction>(
    SyncTraderGroup_SyncAction_descriptor(), name, value);
}
// ===================================================================

class message final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:tickview_strategy.message) */ {
 public:
  inline message() : message(nullptr) {}
  ~message() override;
  explicit PROTOBUF_CONSTEXPR message(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  message(const message& from);
  message(message&& from) noexcept
    : message() {
    *this = ::std::move(from);
  }

  inline message& operator=(const message& from) {
    CopyFrom(from);
    return *this;
  }
  inline message& operator=(message&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const message& default_instance() {
    return *internal_default_instance();
  }
  enum MessageTypeCase {
    kControlReq = 1,
    kOrderCondition = 2,
    kBugInjection = 3,
    kBatchReq = 4,
    kProfilerControl = 5,
    kUpdateProjectPara = 6,
    kUpdateStrategyPara = 7,
    kCloseAll = 8,
    kUnexpectedMinVolume = 9,
    kClearDiagnosticEvent = 10,
    kClearRecord = 11,
    kSyncInstrument = 12,
    kSyncTraderGroup = 13,
    kHeavyAttack = 14,
    kFrontAdjust = 15,
    MESSAGETYPE_NOT_SET = 0,
  };

  static inline const message* internal_default_instance() {
    return reinterpret_cast<const message*>(
               &_message_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  friend void swap(message& a, message& b) {
    a.Swap(&b);
  }
  inline void Swap(message* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(message* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  message* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<message>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const message& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const message& from) {
    message::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(message* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "tickview_strategy.message";
  }
  protected:
  explicit message(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kControlReqFieldNumber = 1,
    kOrderConditionFieldNumber = 2,
    kBugInjectionFieldNumber = 3,
    kBatchReqFieldNumber = 4,
    kProfilerControlFieldNumber = 5,
    kUpdateProjectParaFieldNumber = 6,
    kUpdateStrategyParaFieldNumber = 7,
    kCloseAllFieldNumber = 8,
    kUnexpectedMinVolumeFieldNumber = 9,
    kClearDiagnosticEventFieldNumber = 10,
    kClearRecordFieldNumber = 11,
    kSyncInstrumentFieldNumber = 12,
    kSyncTraderGroupFieldNumber = 13,
    kHeavyAttackFieldNumber = 14,
    kFrontAdjustFieldNumber = 15,
  };
  // .tickview_strategy.Level1ControlReq control_req = 1;
  bool has_control_req() const;
  private:
  bool _internal_has_control_req() const;
  public:
  void clear_control_req();
  const ::tickview_strategy::Level1ControlReq& control_req() const;
  PROTOBUF_NODISCARD ::tickview_strategy::Level1ControlReq* release_control_req();
  ::tickview_strategy::Level1ControlReq* mutable_control_req();
  void set_allocated_control_req(::tickview_strategy::Level1ControlReq* control_req);
  private:
  const ::tickview_strategy::Level1ControlReq& _internal_control_req() const;
  ::tickview_strategy::Level1ControlReq* _internal_mutable_control_req();
  public:
  void unsafe_arena_set_allocated_control_req(
      ::tickview_strategy::Level1ControlReq* control_req);
  ::tickview_strategy::Level1ControlReq* unsafe_arena_release_control_req();

  // .tickview_strategy.OrderConditionMandatorySet order_condition = 2;
  bool has_order_condition() const;
  private:
  bool _internal_has_order_condition() const;
  public:
  void clear_order_condition();
  const ::tickview_strategy::OrderConditionMandatorySet& order_condition() const;
  PROTOBUF_NODISCARD ::tickview_strategy::OrderConditionMandatorySet* release_order_condition();
  ::tickview_strategy::OrderConditionMandatorySet* mutable_order_condition();
  void set_allocated_order_condition(::tickview_strategy::OrderConditionMandatorySet* order_condition);
  private:
  const ::tickview_strategy::OrderConditionMandatorySet& _internal_order_condition() const;
  ::tickview_strategy::OrderConditionMandatorySet* _internal_mutable_order_condition();
  public:
  void unsafe_arena_set_allocated_order_condition(
      ::tickview_strategy::OrderConditionMandatorySet* order_condition);
  ::tickview_strategy::OrderConditionMandatorySet* unsafe_arena_release_order_condition();

  // .tickview_strategy.BugInjection bug_injection = 3;
  bool has_bug_injection() const;
  private:
  bool _internal_has_bug_injection() const;
  public:
  void clear_bug_injection();
  const ::tickview_strategy::BugInjection& bug_injection() const;
  PROTOBUF_NODISCARD ::tickview_strategy::BugInjection* release_bug_injection();
  ::tickview_strategy::BugInjection* mutable_bug_injection();
  void set_allocated_bug_injection(::tickview_strategy::BugInjection* bug_injection);
  private:
  const ::tickview_strategy::BugInjection& _internal_bug_injection() const;
  ::tickview_strategy::BugInjection* _internal_mutable_bug_injection();
  public:
  void unsafe_arena_set_allocated_bug_injection(
      ::tickview_strategy::BugInjection* bug_injection);
  ::tickview_strategy::BugInjection* unsafe_arena_release_bug_injection();

  // .tickview_strategy.BatchControlReq batch_req = 4;
  bool has_batch_req() const;
  private:
  bool _internal_has_batch_req() const;
  public:
  void clear_batch_req();
  const ::tickview_strategy::BatchControlReq& batch_req() const;
  PROTOBUF_NODISCARD ::tickview_strategy::BatchControlReq* release_batch_req();
  ::tickview_strategy::BatchControlReq* mutable_batch_req();
  void set_allocated_batch_req(::tickview_strategy::BatchControlReq* batch_req);
  private:
  const ::tickview_strategy::BatchControlReq& _internal_batch_req() const;
  ::tickview_strategy::BatchControlReq* _internal_mutable_batch_req();
  public:
  void unsafe_arena_set_allocated_batch_req(
      ::tickview_strategy::BatchControlReq* batch_req);
  ::tickview_strategy::BatchControlReq* unsafe_arena_release_batch_req();

  // .tickview_strategy.ProfilerControl profiler_control = 5;
  bool has_profiler_control() const;
  private:
  bool _internal_has_profiler_control() const;
  public:
  void clear_profiler_control();
  const ::tickview_strategy::ProfilerControl& profiler_control() const;
  PROTOBUF_NODISCARD ::tickview_strategy::ProfilerControl* release_profiler_control();
  ::tickview_strategy::ProfilerControl* mutable_profiler_control();
  void set_allocated_profiler_control(::tickview_strategy::ProfilerControl* profiler_control);
  private:
  const ::tickview_strategy::ProfilerControl& _internal_profiler_control() const;
  ::tickview_strategy::ProfilerControl* _internal_mutable_profiler_control();
  public:
  void unsafe_arena_set_allocated_profiler_control(
      ::tickview_strategy::ProfilerControl* profiler_control);
  ::tickview_strategy::ProfilerControl* unsafe_arena_release_profiler_control();

  // .tickview_strategy.UpdateProjectPara update_project_para = 6;
  bool has_update_project_para() const;
  private:
  bool _internal_has_update_project_para() const;
  public:
  void clear_update_project_para();
  const ::tickview_strategy::UpdateProjectPara& update_project_para() const;
  PROTOBUF_NODISCARD ::tickview_strategy::UpdateProjectPara* release_update_project_para();
  ::tickview_strategy::UpdateProjectPara* mutable_update_project_para();
  void set_allocated_update_project_para(::tickview_strategy::UpdateProjectPara* update_project_para);
  private:
  const ::tickview_strategy::UpdateProjectPara& _internal_update_project_para() const;
  ::tickview_strategy::UpdateProjectPara* _internal_mutable_update_project_para();
  public:
  void unsafe_arena_set_allocated_update_project_para(
      ::tickview_strategy::UpdateProjectPara* update_project_para);
  ::tickview_strategy::UpdateProjectPara* unsafe_arena_release_update_project_para();

  // .tickview_strategy.UpdateStrategyPara update_strategy_para = 7;
  bool has_update_strategy_para() const;
  private:
  bool _internal_has_update_strategy_para() const;
  public:
  void clear_update_strategy_para();
  const ::tickview_strategy::UpdateStrategyPara& update_strategy_para() const;
  PROTOBUF_NODISCARD ::tickview_strategy::UpdateStrategyPara* release_update_strategy_para();
  ::tickview_strategy::UpdateStrategyPara* mutable_update_strategy_para();
  void set_allocated_update_strategy_para(::tickview_strategy::UpdateStrategyPara* update_strategy_para);
  private:
  const ::tickview_strategy::UpdateStrategyPara& _internal_update_strategy_para() const;
  ::tickview_strategy::UpdateStrategyPara* _internal_mutable_update_strategy_para();
  public:
  void unsafe_arena_set_allocated_update_strategy_para(
      ::tickview_strategy::UpdateStrategyPara* update_strategy_para);
  ::tickview_strategy::UpdateStrategyPara* unsafe_arena_release_update_strategy_para();

  // .tickview_strategy.CloseAll close_all = 8;
  bool has_close_all() const;
  private:
  bool _internal_has_close_all() const;
  public:
  void clear_close_all();
  const ::tickview_strategy::CloseAll& close_all() const;
  PROTOBUF_NODISCARD ::tickview_strategy::CloseAll* release_close_all();
  ::tickview_strategy::CloseAll* mutable_close_all();
  void set_allocated_close_all(::tickview_strategy::CloseAll* close_all);
  private:
  const ::tickview_strategy::CloseAll& _internal_close_all() const;
  ::tickview_strategy::CloseAll* _internal_mutable_close_all();
  public:
  void unsafe_arena_set_allocated_close_all(
      ::tickview_strategy::CloseAll* close_all);
  ::tickview_strategy::CloseAll* unsafe_arena_release_close_all();

  // .tickview_strategy.UnexpectedMinVolume unexpected_min_volume = 9;
  bool has_unexpected_min_volume() const;
  private:
  bool _internal_has_unexpected_min_volume() const;
  public:
  void clear_unexpected_min_volume();
  const ::tickview_strategy::UnexpectedMinVolume& unexpected_min_volume() const;
  PROTOBUF_NODISCARD ::tickview_strategy::UnexpectedMinVolume* release_unexpected_min_volume();
  ::tickview_strategy::UnexpectedMinVolume* mutable_unexpected_min_volume();
  void set_allocated_unexpected_min_volume(::tickview_strategy::UnexpectedMinVolume* unexpected_min_volume);
  private:
  const ::tickview_strategy::UnexpectedMinVolume& _internal_unexpected_min_volume() const;
  ::tickview_strategy::UnexpectedMinVolume* _internal_mutable_unexpected_min_volume();
  public:
  void unsafe_arena_set_allocated_unexpected_min_volume(
      ::tickview_strategy::UnexpectedMinVolume* unexpected_min_volume);
  ::tickview_strategy::UnexpectedMinVolume* unsafe_arena_release_unexpected_min_volume();

  // .tickview_strategy.ClearDiagnosticEvent clear_diagnostic_event = 10;
  bool has_clear_diagnostic_event() const;
  private:
  bool _internal_has_clear_diagnostic_event() const;
  public:
  void clear_clear_diagnostic_event();
  const ::tickview_strategy::ClearDiagnosticEvent& clear_diagnostic_event() const;
  PROTOBUF_NODISCARD ::tickview_strategy::ClearDiagnosticEvent* release_clear_diagnostic_event();
  ::tickview_strategy::ClearDiagnosticEvent* mutable_clear_diagnostic_event();
  void set_allocated_clear_diagnostic_event(::tickview_strategy::ClearDiagnosticEvent* clear_diagnostic_event);
  private:
  const ::tickview_strategy::ClearDiagnosticEvent& _internal_clear_diagnostic_event() const;
  ::tickview_strategy::ClearDiagnosticEvent* _internal_mutable_clear_diagnostic_event();
  public:
  void unsafe_arena_set_allocated_clear_diagnostic_event(
      ::tickview_strategy::ClearDiagnosticEvent* clear_diagnostic_event);
  ::tickview_strategy::ClearDiagnosticEvent* unsafe_arena_release_clear_diagnostic_event();

  // .tickview_strategy.ClearOldRecord clear_record = 11;
  bool has_clear_record() const;
  private:
  bool _internal_has_clear_record() const;
  public:
  void clear_clear_record();
  const ::tickview_strategy::ClearOldRecord& clear_record() const;
  PROTOBUF_NODISCARD ::tickview_strategy::ClearOldRecord* release_clear_record();
  ::tickview_strategy::ClearOldRecord* mutable_clear_record();
  void set_allocated_clear_record(::tickview_strategy::ClearOldRecord* clear_record);
  private:
  const ::tickview_strategy::ClearOldRecord& _internal_clear_record() const;
  ::tickview_strategy::ClearOldRecord* _internal_mutable_clear_record();
  public:
  void unsafe_arena_set_allocated_clear_record(
      ::tickview_strategy::ClearOldRecord* clear_record);
  ::tickview_strategy::ClearOldRecord* unsafe_arena_release_clear_record();

  // .tickview_strategy.SyncInstrumentSet sync_instrument = 12;
  bool has_sync_instrument() const;
  private:
  bool _internal_has_sync_instrument() const;
  public:
  void clear_sync_instrument();
  const ::tickview_strategy::SyncInstrumentSet& sync_instrument() const;
  PROTOBUF_NODISCARD ::tickview_strategy::SyncInstrumentSet* release_sync_instrument();
  ::tickview_strategy::SyncInstrumentSet* mutable_sync_instrument();
  void set_allocated_sync_instrument(::tickview_strategy::SyncInstrumentSet* sync_instrument);
  private:
  const ::tickview_strategy::SyncInstrumentSet& _internal_sync_instrument() const;
  ::tickview_strategy::SyncInstrumentSet* _internal_mutable_sync_instrument();
  public:
  void unsafe_arena_set_allocated_sync_instrument(
      ::tickview_strategy::SyncInstrumentSet* sync_instrument);
  ::tickview_strategy::SyncInstrumentSet* unsafe_arena_release_sync_instrument();

  // .tickview_strategy.SyncTraderGroup sync_trader_group = 13;
  bool has_sync_trader_group() const;
  private:
  bool _internal_has_sync_trader_group() const;
  public:
  void clear_sync_trader_group();
  const ::tickview_strategy::SyncTraderGroup& sync_trader_group() const;
  PROTOBUF_NODISCARD ::tickview_strategy::SyncTraderGroup* release_sync_trader_group();
  ::tickview_strategy::SyncTraderGroup* mutable_sync_trader_group();
  void set_allocated_sync_trader_group(::tickview_strategy::SyncTraderGroup* sync_trader_group);
  private:
  const ::tickview_strategy::SyncTraderGroup& _internal_sync_trader_group() const;
  ::tickview_strategy::SyncTraderGroup* _internal_mutable_sync_trader_group();
  public:
  void unsafe_arena_set_allocated_sync_trader_group(
      ::tickview_strategy::SyncTraderGroup* sync_trader_group);
  ::tickview_strategy::SyncTraderGroup* unsafe_arena_release_sync_trader_group();

  // .tickview_strategy.HeavyAttack heavy_attack = 14;
  bool has_heavy_attack() const;
  private:
  bool _internal_has_heavy_attack() const;
  public:
  void clear_heavy_attack();
  const ::tickview_strategy::HeavyAttack& heavy_attack() const;
  PROTOBUF_NODISCARD ::tickview_strategy::HeavyAttack* release_heavy_attack();
  ::tickview_strategy::HeavyAttack* mutable_heavy_attack();
  void set_allocated_heavy_attack(::tickview_strategy::HeavyAttack* heavy_attack);
  private:
  const ::tickview_strategy::HeavyAttack& _internal_heavy_attack() const;
  ::tickview_strategy::HeavyAttack* _internal_mutable_heavy_attack();
  public:
  void unsafe_arena_set_allocated_heavy_attack(
      ::tickview_strategy::HeavyAttack* heavy_attack);
  ::tickview_strategy::HeavyAttack* unsafe_arena_release_heavy_attack();

  // .tickview_strategy.FrontAdjust front_adjust = 15;
  bool has_front_adjust() const;
  private:
  bool _internal_has_front_adjust() const;
  public:
  void clear_front_adjust();
  const ::tickview_strategy::FrontAdjust& front_adjust() const;
  PROTOBUF_NODISCARD ::tickview_strategy::FrontAdjust* release_front_adjust();
  ::tickview_strategy::FrontAdjust* mutable_front_adjust();
  void set_allocated_front_adjust(::tickview_strategy::FrontAdjust* front_adjust);
  private:
  const ::tickview_strategy::FrontAdjust& _internal_front_adjust() const;
  ::tickview_strategy::FrontAdjust* _internal_mutable_front_adjust();
  public:
  void unsafe_arena_set_allocated_front_adjust(
      ::tickview_strategy::FrontAdjust* front_adjust);
  ::tickview_strategy::FrontAdjust* unsafe_arena_release_front_adjust();

  void clear_MessageType();
  MessageTypeCase MessageType_case() const;
  // @@protoc_insertion_point(class_scope:tickview_strategy.message)
 private:
  class _Internal;
  void set_has_control_req();
  void set_has_order_condition();
  void set_has_bug_injection();
  void set_has_batch_req();
  void set_has_profiler_control();
  void set_has_update_project_para();
  void set_has_update_strategy_para();
  void set_has_close_all();
  void set_has_unexpected_min_volume();
  void set_has_clear_diagnostic_event();
  void set_has_clear_record();
  void set_has_sync_instrument();
  void set_has_sync_trader_group();
  void set_has_heavy_attack();
  void set_has_front_adjust();

  inline bool has_MessageType() const;
  inline void clear_has_MessageType();

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    union MessageTypeUnion {
      constexpr MessageTypeUnion() : _constinit_{} {}
        ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized _constinit_;
      ::tickview_strategy::Level1ControlReq* control_req_;
      ::tickview_strategy::OrderConditionMandatorySet* order_condition_;
      ::tickview_strategy::BugInjection* bug_injection_;
      ::tickview_strategy::BatchControlReq* batch_req_;
      ::tickview_strategy::ProfilerControl* profiler_control_;
      ::tickview_strategy::UpdateProjectPara* update_project_para_;
      ::tickview_strategy::UpdateStrategyPara* update_strategy_para_;
      ::tickview_strategy::CloseAll* close_all_;
      ::tickview_strategy::UnexpectedMinVolume* unexpected_min_volume_;
      ::tickview_strategy::ClearDiagnosticEvent* clear_diagnostic_event_;
      ::tickview_strategy::ClearOldRecord* clear_record_;
      ::tickview_strategy::SyncInstrumentSet* sync_instrument_;
      ::tickview_strategy::SyncTraderGroup* sync_trader_group_;
      ::tickview_strategy::HeavyAttack* heavy_attack_;
      ::tickview_strategy::FrontAdjust* front_adjust_;
    } MessageType_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    uint32_t _oneof_case_[1];

  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_tickview_2dstrategy_2eproto;
};
// -------------------------------------------------------------------

class Level1ControlReq final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:tickview_strategy.Level1ControlReq) */ {
 public:
  inline Level1ControlReq() : Level1ControlReq(nullptr) {}
  ~Level1ControlReq() override;
  explicit PROTOBUF_CONSTEXPR Level1ControlReq(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Level1ControlReq(const Level1ControlReq& from);
  Level1ControlReq(Level1ControlReq&& from) noexcept
    : Level1ControlReq() {
    *this = ::std::move(from);
  }

  inline Level1ControlReq& operator=(const Level1ControlReq& from) {
    CopyFrom(from);
    return *this;
  }
  inline Level1ControlReq& operator=(Level1ControlReq&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Level1ControlReq& default_instance() {
    return *internal_default_instance();
  }
  static inline const Level1ControlReq* internal_default_instance() {
    return reinterpret_cast<const Level1ControlReq*>(
               &_Level1ControlReq_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  friend void swap(Level1ControlReq& a, Level1ControlReq& b) {
    a.Swap(&b);
  }
  inline void Swap(Level1ControlReq* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Level1ControlReq* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Level1ControlReq* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Level1ControlReq>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Level1ControlReq& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const Level1ControlReq& from) {
    Level1ControlReq::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Level1ControlReq* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "tickview_strategy.Level1ControlReq";
  }
  protected:
  explicit Level1ControlReq(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef Level1ControlReq_Indication Indication;
  static constexpr Indication reserve =
    Level1ControlReq_Indication_reserve;
  static constexpr Indication start =
    Level1ControlReq_Indication_start;
  static constexpr Indication stop =
    Level1ControlReq_Indication_stop;
  static inline bool Indication_IsValid(int value) {
    return Level1ControlReq_Indication_IsValid(value);
  }
  static constexpr Indication Indication_MIN =
    Level1ControlReq_Indication_Indication_MIN;
  static constexpr Indication Indication_MAX =
    Level1ControlReq_Indication_Indication_MAX;
  static constexpr int Indication_ARRAYSIZE =
    Level1ControlReq_Indication_Indication_ARRAYSIZE;
  static inline const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
  Indication_descriptor() {
    return Level1ControlReq_Indication_descriptor();
  }
  template<typename T>
  static inline const std::string& Indication_Name(T enum_t_value) {
    static_assert(::std::is_same<T, Indication>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function Indication_Name.");
    return Level1ControlReq_Indication_Name(enum_t_value);
  }
  static inline bool Indication_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name,
      Indication* value) {
    return Level1ControlReq_Indication_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  enum : int {
    kStrategyNameFieldNumber = 1,
    kStrategyExchFieldNumber = 2,
    kStrategyGroupFieldNumber = 3,
    kStrategyIndexFieldNumber = 4,
    kIndicationFieldNumber = 5,
  };
  // string strategy_name = 1;
  void clear_strategy_name();
  const std::string& strategy_name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_strategy_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_strategy_name();
  PROTOBUF_NODISCARD std::string* release_strategy_name();
  void set_allocated_strategy_name(std::string* strategy_name);
  private:
  const std::string& _internal_strategy_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_strategy_name(const std::string& value);
  std::string* _internal_mutable_strategy_name();
  public:

  // string strategy_exch = 2;
  void clear_strategy_exch();
  const std::string& strategy_exch() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_strategy_exch(ArgT0&& arg0, ArgT... args);
  std::string* mutable_strategy_exch();
  PROTOBUF_NODISCARD std::string* release_strategy_exch();
  void set_allocated_strategy_exch(std::string* strategy_exch);
  private:
  const std::string& _internal_strategy_exch() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_strategy_exch(const std::string& value);
  std::string* _internal_mutable_strategy_exch();
  public:

  // string strategy_group = 3;
  void clear_strategy_group();
  const std::string& strategy_group() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_strategy_group(ArgT0&& arg0, ArgT... args);
  std::string* mutable_strategy_group();
  PROTOBUF_NODISCARD std::string* release_strategy_group();
  void set_allocated_strategy_group(std::string* strategy_group);
  private:
  const std::string& _internal_strategy_group() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_strategy_group(const std::string& value);
  std::string* _internal_mutable_strategy_group();
  public:

  // string strategy_index = 4;
  void clear_strategy_index();
  const std::string& strategy_index() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_strategy_index(ArgT0&& arg0, ArgT... args);
  std::string* mutable_strategy_index();
  PROTOBUF_NODISCARD std::string* release_strategy_index();
  void set_allocated_strategy_index(std::string* strategy_index);
  private:
  const std::string& _internal_strategy_index() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_strategy_index(const std::string& value);
  std::string* _internal_mutable_strategy_index();
  public:

  // .tickview_strategy.Level1ControlReq.Indication indication = 5;
  void clear_indication();
  ::tickview_strategy::Level1ControlReq_Indication indication() const;
  void set_indication(::tickview_strategy::Level1ControlReq_Indication value);
  private:
  ::tickview_strategy::Level1ControlReq_Indication _internal_indication() const;
  void _internal_set_indication(::tickview_strategy::Level1ControlReq_Indication value);
  public:

  // @@protoc_insertion_point(class_scope:tickview_strategy.Level1ControlReq)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr strategy_name_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr strategy_exch_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr strategy_group_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr strategy_index_;
    int indication_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_tickview_2dstrategy_2eproto;
};
// -------------------------------------------------------------------

class OrderConditionMandatorySet final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:tickview_strategy.OrderConditionMandatorySet) */ {
 public:
  inline OrderConditionMandatorySet() : OrderConditionMandatorySet(nullptr) {}
  ~OrderConditionMandatorySet() override;
  explicit PROTOBUF_CONSTEXPR OrderConditionMandatorySet(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  OrderConditionMandatorySet(const OrderConditionMandatorySet& from);
  OrderConditionMandatorySet(OrderConditionMandatorySet&& from) noexcept
    : OrderConditionMandatorySet() {
    *this = ::std::move(from);
  }

  inline OrderConditionMandatorySet& operator=(const OrderConditionMandatorySet& from) {
    CopyFrom(from);
    return *this;
  }
  inline OrderConditionMandatorySet& operator=(OrderConditionMandatorySet&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const OrderConditionMandatorySet& default_instance() {
    return *internal_default_instance();
  }
  static inline const OrderConditionMandatorySet* internal_default_instance() {
    return reinterpret_cast<const OrderConditionMandatorySet*>(
               &_OrderConditionMandatorySet_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  friend void swap(OrderConditionMandatorySet& a, OrderConditionMandatorySet& b) {
    a.Swap(&b);
  }
  inline void Swap(OrderConditionMandatorySet* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(OrderConditionMandatorySet* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  OrderConditionMandatorySet* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<OrderConditionMandatorySet>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const OrderConditionMandatorySet& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const OrderConditionMandatorySet& from) {
    OrderConditionMandatorySet::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(OrderConditionMandatorySet* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "tickview_strategy.OrderConditionMandatorySet";
  }
  protected:
  explicit OrderConditionMandatorySet(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef OrderConditionMandatorySet_OrderCondition OrderCondition;
  static constexpr OrderCondition reserve =
    OrderConditionMandatorySet_OrderCondition_reserve;
  static constexpr OrderCondition open_more =
    OrderConditionMandatorySet_OrderCondition_open_more;
  static constexpr OrderCondition open_short =
    OrderConditionMandatorySet_OrderCondition_open_short;
  static constexpr OrderCondition add_more =
    OrderConditionMandatorySet_OrderCondition_add_more;
  static constexpr OrderCondition add_short =
    OrderConditionMandatorySet_OrderCondition_add_short;
  static constexpr OrderCondition sync_open =
    OrderConditionMandatorySet_OrderCondition_sync_open;
  static constexpr OrderCondition sync_close =
    OrderConditionMandatorySet_OrderCondition_sync_close;
  static constexpr OrderCondition close_more =
    OrderConditionMandatorySet_OrderCondition_close_more;
  static constexpr OrderCondition close_short =
    OrderConditionMandatorySet_OrderCondition_close_short;
  static constexpr OrderCondition back_idle =
    OrderConditionMandatorySet_OrderCondition_back_idle;
  static inline bool OrderCondition_IsValid(int value) {
    return OrderConditionMandatorySet_OrderCondition_IsValid(value);
  }
  static constexpr OrderCondition OrderCondition_MIN =
    OrderConditionMandatorySet_OrderCondition_OrderCondition_MIN;
  static constexpr OrderCondition OrderCondition_MAX =
    OrderConditionMandatorySet_OrderCondition_OrderCondition_MAX;
  static constexpr int OrderCondition_ARRAYSIZE =
    OrderConditionMandatorySet_OrderCondition_OrderCondition_ARRAYSIZE;
  static inline const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
  OrderCondition_descriptor() {
    return OrderConditionMandatorySet_OrderCondition_descriptor();
  }
  template<typename T>
  static inline const std::string& OrderCondition_Name(T enum_t_value) {
    static_assert(::std::is_same<T, OrderCondition>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function OrderCondition_Name.");
    return OrderConditionMandatorySet_OrderCondition_Name(enum_t_value);
  }
  static inline bool OrderCondition_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name,
      OrderCondition* value) {
    return OrderConditionMandatorySet_OrderCondition_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  enum : int {
    kStrategyExchFieldNumber = 1,
    kStrategyGroupFieldNumber = 2,
    kStrategyInsFieldNumber = 3,
    kStrategyIndexFieldNumber = 4,
    kConditionFieldNumber = 5,
  };
  // string strategy_exch = 1;
  void clear_strategy_exch();
  const std::string& strategy_exch() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_strategy_exch(ArgT0&& arg0, ArgT... args);
  std::string* mutable_strategy_exch();
  PROTOBUF_NODISCARD std::string* release_strategy_exch();
  void set_allocated_strategy_exch(std::string* strategy_exch);
  private:
  const std::string& _internal_strategy_exch() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_strategy_exch(const std::string& value);
  std::string* _internal_mutable_strategy_exch();
  public:

  // string strategy_group = 2;
  void clear_strategy_group();
  const std::string& strategy_group() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_strategy_group(ArgT0&& arg0, ArgT... args);
  std::string* mutable_strategy_group();
  PROTOBUF_NODISCARD std::string* release_strategy_group();
  void set_allocated_strategy_group(std::string* strategy_group);
  private:
  const std::string& _internal_strategy_group() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_strategy_group(const std::string& value);
  std::string* _internal_mutable_strategy_group();
  public:

  // string strategy_ins = 3;
  void clear_strategy_ins();
  const std::string& strategy_ins() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_strategy_ins(ArgT0&& arg0, ArgT... args);
  std::string* mutable_strategy_ins();
  PROTOBUF_NODISCARD std::string* release_strategy_ins();
  void set_allocated_strategy_ins(std::string* strategy_ins);
  private:
  const std::string& _internal_strategy_ins() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_strategy_ins(const std::string& value);
  std::string* _internal_mutable_strategy_ins();
  public:

  // string strategy_index = 4;
  void clear_strategy_index();
  const std::string& strategy_index() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_strategy_index(ArgT0&& arg0, ArgT... args);
  std::string* mutable_strategy_index();
  PROTOBUF_NODISCARD std::string* release_strategy_index();
  void set_allocated_strategy_index(std::string* strategy_index);
  private:
  const std::string& _internal_strategy_index() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_strategy_index(const std::string& value);
  std::string* _internal_mutable_strategy_index();
  public:

  // .tickview_strategy.OrderConditionMandatorySet.OrderCondition condition = 5;
  void clear_condition();
  ::tickview_strategy::OrderConditionMandatorySet_OrderCondition condition() const;
  void set_condition(::tickview_strategy::OrderConditionMandatorySet_OrderCondition value);
  private:
  ::tickview_strategy::OrderConditionMandatorySet_OrderCondition _internal_condition() const;
  void _internal_set_condition(::tickview_strategy::OrderConditionMandatorySet_OrderCondition value);
  public:

  // @@protoc_insertion_point(class_scope:tickview_strategy.OrderConditionMandatorySet)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr strategy_exch_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr strategy_group_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr strategy_ins_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr strategy_index_;
    int condition_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_tickview_2dstrategy_2eproto;
};
// -------------------------------------------------------------------

class BugInjection final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:tickview_strategy.BugInjection) */ {
 public:
  inline BugInjection() : BugInjection(nullptr) {}
  ~BugInjection() override;
  explicit PROTOBUF_CONSTEXPR BugInjection(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  BugInjection(const BugInjection& from);
  BugInjection(BugInjection&& from) noexcept
    : BugInjection() {
    *this = ::std::move(from);
  }

  inline BugInjection& operator=(const BugInjection& from) {
    CopyFrom(from);
    return *this;
  }
  inline BugInjection& operator=(BugInjection&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const BugInjection& default_instance() {
    return *internal_default_instance();
  }
  static inline const BugInjection* internal_default_instance() {
    return reinterpret_cast<const BugInjection*>(
               &_BugInjection_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  friend void swap(BugInjection& a, BugInjection& b) {
    a.Swap(&b);
  }
  inline void Swap(BugInjection* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(BugInjection* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  BugInjection* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<BugInjection>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const BugInjection& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const BugInjection& from) {
    BugInjection::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(BugInjection* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "tickview_strategy.BugInjection";
  }
  protected:
  explicit BugInjection(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef BugInjection_InjectionType InjectionType;
  static constexpr InjectionType reserve =
    BugInjection_InjectionType_reserve;
  static constexpr InjectionType key_error =
    BugInjection_InjectionType_key_error;
  static constexpr InjectionType noexist_ins =
    BugInjection_InjectionType_noexist_ins;
  static constexpr InjectionType expire_ins =
    BugInjection_InjectionType_expire_ins;
  static inline bool InjectionType_IsValid(int value) {
    return BugInjection_InjectionType_IsValid(value);
  }
  static constexpr InjectionType InjectionType_MIN =
    BugInjection_InjectionType_InjectionType_MIN;
  static constexpr InjectionType InjectionType_MAX =
    BugInjection_InjectionType_InjectionType_MAX;
  static constexpr int InjectionType_ARRAYSIZE =
    BugInjection_InjectionType_InjectionType_ARRAYSIZE;
  static inline const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
  InjectionType_descriptor() {
    return BugInjection_InjectionType_descriptor();
  }
  template<typename T>
  static inline const std::string& InjectionType_Name(T enum_t_value) {
    static_assert(::std::is_same<T, InjectionType>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function InjectionType_Name.");
    return BugInjection_InjectionType_Name(enum_t_value);
  }
  static inline bool InjectionType_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name,
      InjectionType* value) {
    return BugInjection_InjectionType_Parse(name, value);
  }

  typedef BugInjection_Indication Indication;
  static constexpr Indication insert =
    BugInjection_Indication_insert;
  static constexpr Indication remove =
    BugInjection_Indication_remove;
  static inline bool Indication_IsValid(int value) {
    return BugInjection_Indication_IsValid(value);
  }
  static constexpr Indication Indication_MIN =
    BugInjection_Indication_Indication_MIN;
  static constexpr Indication Indication_MAX =
    BugInjection_Indication_Indication_MAX;
  static constexpr int Indication_ARRAYSIZE =
    BugInjection_Indication_Indication_ARRAYSIZE;
  static inline const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
  Indication_descriptor() {
    return BugInjection_Indication_descriptor();
  }
  template<typename T>
  static inline const std::string& Indication_Name(T enum_t_value) {
    static_assert(::std::is_same<T, Indication>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function Indication_Name.");
    return BugInjection_Indication_Name(enum_t_value);
  }
  static inline bool Indication_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name,
      Indication* value) {
    return BugInjection_Indication_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  enum : int {
    kStrategyExchFieldNumber = 1,
    kStrategyGroupFieldNumber = 2,
    kStrategyInsFieldNumber = 3,
    kTypeFieldNumber = 4,
    kIndicationFieldNumber = 5,
  };
  // string strategy_exch = 1;
  void clear_strategy_exch();
  const std::string& strategy_exch() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_strategy_exch(ArgT0&& arg0, ArgT... args);
  std::string* mutable_strategy_exch();
  PROTOBUF_NODISCARD std::string* release_strategy_exch();
  void set_allocated_strategy_exch(std::string* strategy_exch);
  private:
  const std::string& _internal_strategy_exch() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_strategy_exch(const std::string& value);
  std::string* _internal_mutable_strategy_exch();
  public:

  // string strategy_group = 2;
  void clear_strategy_group();
  const std::string& strategy_group() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_strategy_group(ArgT0&& arg0, ArgT... args);
  std::string* mutable_strategy_group();
  PROTOBUF_NODISCARD std::string* release_strategy_group();
  void set_allocated_strategy_group(std::string* strategy_group);
  private:
  const std::string& _internal_strategy_group() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_strategy_group(const std::string& value);
  std::string* _internal_mutable_strategy_group();
  public:

  // string strategy_ins = 3;
  void clear_strategy_ins();
  const std::string& strategy_ins() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_strategy_ins(ArgT0&& arg0, ArgT... args);
  std::string* mutable_strategy_ins();
  PROTOBUF_NODISCARD std::string* release_strategy_ins();
  void set_allocated_strategy_ins(std::string* strategy_ins);
  private:
  const std::string& _internal_strategy_ins() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_strategy_ins(const std::string& value);
  std::string* _internal_mutable_strategy_ins();
  public:

  // .tickview_strategy.BugInjection.InjectionType type = 4;
  void clear_type();
  ::tickview_strategy::BugInjection_InjectionType type() const;
  void set_type(::tickview_strategy::BugInjection_InjectionType value);
  private:
  ::tickview_strategy::BugInjection_InjectionType _internal_type() const;
  void _internal_set_type(::tickview_strategy::BugInjection_InjectionType value);
  public:

  // .tickview_strategy.BugInjection.Indication indication = 5;
  void clear_indication();
  ::tickview_strategy::BugInjection_Indication indication() const;
  void set_indication(::tickview_strategy::BugInjection_Indication value);
  private:
  ::tickview_strategy::BugInjection_Indication _internal_indication() const;
  void _internal_set_indication(::tickview_strategy::BugInjection_Indication value);
  public:

  // @@protoc_insertion_point(class_scope:tickview_strategy.BugInjection)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr strategy_exch_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr strategy_group_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr strategy_ins_;
    int type_;
    int indication_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_tickview_2dstrategy_2eproto;
};
// -------------------------------------------------------------------

class BatchControlReq final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:tickview_strategy.BatchControlReq) */ {
 public:
  inline BatchControlReq() : BatchControlReq(nullptr) {}
  ~BatchControlReq() override;
  explicit PROTOBUF_CONSTEXPR BatchControlReq(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  BatchControlReq(const BatchControlReq& from);
  BatchControlReq(BatchControlReq&& from) noexcept
    : BatchControlReq() {
    *this = ::std::move(from);
  }

  inline BatchControlReq& operator=(const BatchControlReq& from) {
    CopyFrom(from);
    return *this;
  }
  inline BatchControlReq& operator=(BatchControlReq&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const BatchControlReq& default_instance() {
    return *internal_default_instance();
  }
  static inline const BatchControlReq* internal_default_instance() {
    return reinterpret_cast<const BatchControlReq*>(
               &_BatchControlReq_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    4;

  friend void swap(BatchControlReq& a, BatchControlReq& b) {
    a.Swap(&b);
  }
  inline void Swap(BatchControlReq* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(BatchControlReq* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  BatchControlReq* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<BatchControlReq>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const BatchControlReq& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const BatchControlReq& from) {
    BatchControlReq::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(BatchControlReq* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "tickview_strategy.BatchControlReq";
  }
  protected:
  explicit BatchControlReq(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef BatchControlReq_Indication Indication;
  static constexpr Indication reserve =
    BatchControlReq_Indication_reserve;
  static constexpr Indication start =
    BatchControlReq_Indication_start;
  static constexpr Indication stop =
    BatchControlReq_Indication_stop;
  static inline bool Indication_IsValid(int value) {
    return BatchControlReq_Indication_IsValid(value);
  }
  static constexpr Indication Indication_MIN =
    BatchControlReq_Indication_Indication_MIN;
  static constexpr Indication Indication_MAX =
    BatchControlReq_Indication_Indication_MAX;
  static constexpr int Indication_ARRAYSIZE =
    BatchControlReq_Indication_Indication_ARRAYSIZE;
  static inline const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
  Indication_descriptor() {
    return BatchControlReq_Indication_descriptor();
  }
  template<typename T>
  static inline const std::string& Indication_Name(T enum_t_value) {
    static_assert(::std::is_same<T, Indication>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function Indication_Name.");
    return BatchControlReq_Indication_Name(enum_t_value);
  }
  static inline bool Indication_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name,
      Indication* value) {
    return BatchControlReq_Indication_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  enum : int {
    kIndicationFieldNumber = 1,
  };
  // .tickview_strategy.BatchControlReq.Indication indication = 1;
  void clear_indication();
  ::tickview_strategy::BatchControlReq_Indication indication() const;
  void set_indication(::tickview_strategy::BatchControlReq_Indication value);
  private:
  ::tickview_strategy::BatchControlReq_Indication _internal_indication() const;
  void _internal_set_indication(::tickview_strategy::BatchControlReq_Indication value);
  public:

  // @@protoc_insertion_point(class_scope:tickview_strategy.BatchControlReq)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    int indication_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_tickview_2dstrategy_2eproto;
};
// -------------------------------------------------------------------

class ProfilerControl final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:tickview_strategy.ProfilerControl) */ {
 public:
  inline ProfilerControl() : ProfilerControl(nullptr) {}
  ~ProfilerControl() override;
  explicit PROTOBUF_CONSTEXPR ProfilerControl(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ProfilerControl(const ProfilerControl& from);
  ProfilerControl(ProfilerControl&& from) noexcept
    : ProfilerControl() {
    *this = ::std::move(from);
  }

  inline ProfilerControl& operator=(const ProfilerControl& from) {
    CopyFrom(from);
    return *this;
  }
  inline ProfilerControl& operator=(ProfilerControl&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ProfilerControl& default_instance() {
    return *internal_default_instance();
  }
  static inline const ProfilerControl* internal_default_instance() {
    return reinterpret_cast<const ProfilerControl*>(
               &_ProfilerControl_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    5;

  friend void swap(ProfilerControl& a, ProfilerControl& b) {
    a.Swap(&b);
  }
  inline void Swap(ProfilerControl* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ProfilerControl* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ProfilerControl* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ProfilerControl>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ProfilerControl& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const ProfilerControl& from) {
    ProfilerControl::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ProfilerControl* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "tickview_strategy.ProfilerControl";
  }
  protected:
  explicit ProfilerControl(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef ProfilerControl_ProfilerAction ProfilerAction;
  static constexpr ProfilerAction reserve =
    ProfilerControl_ProfilerAction_reserve;
  static constexpr ProfilerAction start_write =
    ProfilerControl_ProfilerAction_start_write;
  static constexpr ProfilerAction stop_write =
    ProfilerControl_ProfilerAction_stop_write;
  static inline bool ProfilerAction_IsValid(int value) {
    return ProfilerControl_ProfilerAction_IsValid(value);
  }
  static constexpr ProfilerAction ProfilerAction_MIN =
    ProfilerControl_ProfilerAction_ProfilerAction_MIN;
  static constexpr ProfilerAction ProfilerAction_MAX =
    ProfilerControl_ProfilerAction_ProfilerAction_MAX;
  static constexpr int ProfilerAction_ARRAYSIZE =
    ProfilerControl_ProfilerAction_ProfilerAction_ARRAYSIZE;
  static inline const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
  ProfilerAction_descriptor() {
    return ProfilerControl_ProfilerAction_descriptor();
  }
  template<typename T>
  static inline const std::string& ProfilerAction_Name(T enum_t_value) {
    static_assert(::std::is_same<T, ProfilerAction>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function ProfilerAction_Name.");
    return ProfilerControl_ProfilerAction_Name(enum_t_value);
  }
  static inline bool ProfilerAction_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name,
      ProfilerAction* value) {
    return ProfilerControl_ProfilerAction_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  enum : int {
    kProfilerActionFieldNumber = 1,
  };
  // .tickview_strategy.ProfilerControl.ProfilerAction profiler_action = 1;
  void clear_profiler_action();
  ::tickview_strategy::ProfilerControl_ProfilerAction profiler_action() const;
  void set_profiler_action(::tickview_strategy::ProfilerControl_ProfilerAction value);
  private:
  ::tickview_strategy::ProfilerControl_ProfilerAction _internal_profiler_action() const;
  void _internal_set_profiler_action(::tickview_strategy::ProfilerControl_ProfilerAction value);
  public:

  // @@protoc_insertion_point(class_scope:tickview_strategy.ProfilerControl)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    int profiler_action_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_tickview_2dstrategy_2eproto;
};
// -------------------------------------------------------------------

class UpdateProjectPara final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:tickview_strategy.UpdateProjectPara) */ {
 public:
  inline UpdateProjectPara() : UpdateProjectPara(nullptr) {}
  ~UpdateProjectPara() override;
  explicit PROTOBUF_CONSTEXPR UpdateProjectPara(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  UpdateProjectPara(const UpdateProjectPara& from);
  UpdateProjectPara(UpdateProjectPara&& from) noexcept
    : UpdateProjectPara() {
    *this = ::std::move(from);
  }

  inline UpdateProjectPara& operator=(const UpdateProjectPara& from) {
    CopyFrom(from);
    return *this;
  }
  inline UpdateProjectPara& operator=(UpdateProjectPara&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const UpdateProjectPara& default_instance() {
    return *internal_default_instance();
  }
  static inline const UpdateProjectPara* internal_default_instance() {
    return reinterpret_cast<const UpdateProjectPara*>(
               &_UpdateProjectPara_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    6;

  friend void swap(UpdateProjectPara& a, UpdateProjectPara& b) {
    a.Swap(&b);
  }
  inline void Swap(UpdateProjectPara* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(UpdateProjectPara* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  UpdateProjectPara* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<UpdateProjectPara>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const UpdateProjectPara& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const UpdateProjectPara& from) {
    UpdateProjectPara::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(UpdateProjectPara* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "tickview_strategy.UpdateProjectPara";
  }
  protected:
  explicit UpdateProjectPara(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef UpdateProjectPara_UpdateAction UpdateAction;
  static constexpr UpdateAction reserve =
    UpdateProjectPara_UpdateAction_reserve;
  static constexpr UpdateAction update =
    UpdateProjectPara_UpdateAction_update;
  static constexpr UpdateAction noupdate =
    UpdateProjectPara_UpdateAction_noupdate;
  static inline bool UpdateAction_IsValid(int value) {
    return UpdateProjectPara_UpdateAction_IsValid(value);
  }
  static constexpr UpdateAction UpdateAction_MIN =
    UpdateProjectPara_UpdateAction_UpdateAction_MIN;
  static constexpr UpdateAction UpdateAction_MAX =
    UpdateProjectPara_UpdateAction_UpdateAction_MAX;
  static constexpr int UpdateAction_ARRAYSIZE =
    UpdateProjectPara_UpdateAction_UpdateAction_ARRAYSIZE;
  static inline const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
  UpdateAction_descriptor() {
    return UpdateProjectPara_UpdateAction_descriptor();
  }
  template<typename T>
  static inline const std::string& UpdateAction_Name(T enum_t_value) {
    static_assert(::std::is_same<T, UpdateAction>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function UpdateAction_Name.");
    return UpdateProjectPara_UpdateAction_Name(enum_t_value);
  }
  static inline bool UpdateAction_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name,
      UpdateAction* value) {
    return UpdateProjectPara_UpdateAction_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  enum : int {
    kUpdateActionFieldNumber = 1,
  };
  // .tickview_strategy.UpdateProjectPara.UpdateAction update_action = 1;
  void clear_update_action();
  ::tickview_strategy::UpdateProjectPara_UpdateAction update_action() const;
  void set_update_action(::tickview_strategy::UpdateProjectPara_UpdateAction value);
  private:
  ::tickview_strategy::UpdateProjectPara_UpdateAction _internal_update_action() const;
  void _internal_set_update_action(::tickview_strategy::UpdateProjectPara_UpdateAction value);
  public:

  // @@protoc_insertion_point(class_scope:tickview_strategy.UpdateProjectPara)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    int update_action_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_tickview_2dstrategy_2eproto;
};
// -------------------------------------------------------------------

class UpdateStrategyPara final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:tickview_strategy.UpdateStrategyPara) */ {
 public:
  inline UpdateStrategyPara() : UpdateStrategyPara(nullptr) {}
  ~UpdateStrategyPara() override;
  explicit PROTOBUF_CONSTEXPR UpdateStrategyPara(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  UpdateStrategyPara(const UpdateStrategyPara& from);
  UpdateStrategyPara(UpdateStrategyPara&& from) noexcept
    : UpdateStrategyPara() {
    *this = ::std::move(from);
  }

  inline UpdateStrategyPara& operator=(const UpdateStrategyPara& from) {
    CopyFrom(from);
    return *this;
  }
  inline UpdateStrategyPara& operator=(UpdateStrategyPara&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const UpdateStrategyPara& default_instance() {
    return *internal_default_instance();
  }
  static inline const UpdateStrategyPara* internal_default_instance() {
    return reinterpret_cast<const UpdateStrategyPara*>(
               &_UpdateStrategyPara_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    7;

  friend void swap(UpdateStrategyPara& a, UpdateStrategyPara& b) {
    a.Swap(&b);
  }
  inline void Swap(UpdateStrategyPara* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(UpdateStrategyPara* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  UpdateStrategyPara* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<UpdateStrategyPara>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const UpdateStrategyPara& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const UpdateStrategyPara& from) {
    UpdateStrategyPara::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(UpdateStrategyPara* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "tickview_strategy.UpdateStrategyPara";
  }
  protected:
  explicit UpdateStrategyPara(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef UpdateStrategyPara_UpdateAction UpdateAction;
  static constexpr UpdateAction reserve =
    UpdateStrategyPara_UpdateAction_reserve;
  static constexpr UpdateAction update =
    UpdateStrategyPara_UpdateAction_update;
  static constexpr UpdateAction noupdate =
    UpdateStrategyPara_UpdateAction_noupdate;
  static inline bool UpdateAction_IsValid(int value) {
    return UpdateStrategyPara_UpdateAction_IsValid(value);
  }
  static constexpr UpdateAction UpdateAction_MIN =
    UpdateStrategyPara_UpdateAction_UpdateAction_MIN;
  static constexpr UpdateAction UpdateAction_MAX =
    UpdateStrategyPara_UpdateAction_UpdateAction_MAX;
  static constexpr int UpdateAction_ARRAYSIZE =
    UpdateStrategyPara_UpdateAction_UpdateAction_ARRAYSIZE;
  static inline const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
  UpdateAction_descriptor() {
    return UpdateStrategyPara_UpdateAction_descriptor();
  }
  template<typename T>
  static inline const std::string& UpdateAction_Name(T enum_t_value) {
    static_assert(::std::is_same<T, UpdateAction>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function UpdateAction_Name.");
    return UpdateStrategyPara_UpdateAction_Name(enum_t_value);
  }
  static inline bool UpdateAction_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name,
      UpdateAction* value) {
    return UpdateStrategyPara_UpdateAction_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  enum : int {
    kStrategyExchFieldNumber = 1,
    kStrategyGroupFieldNumber = 2,
    kStrategyIndexFieldNumber = 3,
    kUpdateActionFieldNumber = 4,
  };
  // string strategy_exch = 1;
  void clear_strategy_exch();
  const std::string& strategy_exch() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_strategy_exch(ArgT0&& arg0, ArgT... args);
  std::string* mutable_strategy_exch();
  PROTOBUF_NODISCARD std::string* release_strategy_exch();
  void set_allocated_strategy_exch(std::string* strategy_exch);
  private:
  const std::string& _internal_strategy_exch() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_strategy_exch(const std::string& value);
  std::string* _internal_mutable_strategy_exch();
  public:

  // string strategy_group = 2;
  void clear_strategy_group();
  const std::string& strategy_group() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_strategy_group(ArgT0&& arg0, ArgT... args);
  std::string* mutable_strategy_group();
  PROTOBUF_NODISCARD std::string* release_strategy_group();
  void set_allocated_strategy_group(std::string* strategy_group);
  private:
  const std::string& _internal_strategy_group() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_strategy_group(const std::string& value);
  std::string* _internal_mutable_strategy_group();
  public:

  // string strategy_index = 3;
  void clear_strategy_index();
  const std::string& strategy_index() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_strategy_index(ArgT0&& arg0, ArgT... args);
  std::string* mutable_strategy_index();
  PROTOBUF_NODISCARD std::string* release_strategy_index();
  void set_allocated_strategy_index(std::string* strategy_index);
  private:
  const std::string& _internal_strategy_index() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_strategy_index(const std::string& value);
  std::string* _internal_mutable_strategy_index();
  public:

  // .tickview_strategy.UpdateStrategyPara.UpdateAction update_action = 4;
  void clear_update_action();
  ::tickview_strategy::UpdateStrategyPara_UpdateAction update_action() const;
  void set_update_action(::tickview_strategy::UpdateStrategyPara_UpdateAction value);
  private:
  ::tickview_strategy::UpdateStrategyPara_UpdateAction _internal_update_action() const;
  void _internal_set_update_action(::tickview_strategy::UpdateStrategyPara_UpdateAction value);
  public:

  // @@protoc_insertion_point(class_scope:tickview_strategy.UpdateStrategyPara)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr strategy_exch_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr strategy_group_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr strategy_index_;
    int update_action_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_tickview_2dstrategy_2eproto;
};
// -------------------------------------------------------------------

class CloseAll final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:tickview_strategy.CloseAll) */ {
 public:
  inline CloseAll() : CloseAll(nullptr) {}
  ~CloseAll() override;
  explicit PROTOBUF_CONSTEXPR CloseAll(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  CloseAll(const CloseAll& from);
  CloseAll(CloseAll&& from) noexcept
    : CloseAll() {
    *this = ::std::move(from);
  }

  inline CloseAll& operator=(const CloseAll& from) {
    CopyFrom(from);
    return *this;
  }
  inline CloseAll& operator=(CloseAll&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CloseAll& default_instance() {
    return *internal_default_instance();
  }
  static inline const CloseAll* internal_default_instance() {
    return reinterpret_cast<const CloseAll*>(
               &_CloseAll_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    8;

  friend void swap(CloseAll& a, CloseAll& b) {
    a.Swap(&b);
  }
  inline void Swap(CloseAll* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CloseAll* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  CloseAll* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<CloseAll>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const CloseAll& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const CloseAll& from) {
    CloseAll::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CloseAll* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "tickview_strategy.CloseAll";
  }
  protected:
  explicit CloseAll(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef CloseAll_CloseAction CloseAction;
  static constexpr CloseAction reserve =
    CloseAll_CloseAction_reserve;
  static constexpr CloseAction can_open_again_in_this_day =
    CloseAll_CloseAction_can_open_again_in_this_day;
  static constexpr CloseAction cannot_open_again_in_this_day =
    CloseAll_CloseAction_cannot_open_again_in_this_day;
  static inline bool CloseAction_IsValid(int value) {
    return CloseAll_CloseAction_IsValid(value);
  }
  static constexpr CloseAction CloseAction_MIN =
    CloseAll_CloseAction_CloseAction_MIN;
  static constexpr CloseAction CloseAction_MAX =
    CloseAll_CloseAction_CloseAction_MAX;
  static constexpr int CloseAction_ARRAYSIZE =
    CloseAll_CloseAction_CloseAction_ARRAYSIZE;
  static inline const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
  CloseAction_descriptor() {
    return CloseAll_CloseAction_descriptor();
  }
  template<typename T>
  static inline const std::string& CloseAction_Name(T enum_t_value) {
    static_assert(::std::is_same<T, CloseAction>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function CloseAction_Name.");
    return CloseAll_CloseAction_Name(enum_t_value);
  }
  static inline bool CloseAction_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name,
      CloseAction* value) {
    return CloseAll_CloseAction_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  enum : int {
    kCloseActionFieldNumber = 1,
  };
  // .tickview_strategy.CloseAll.CloseAction close_action = 1;
  void clear_close_action();
  ::tickview_strategy::CloseAll_CloseAction close_action() const;
  void set_close_action(::tickview_strategy::CloseAll_CloseAction value);
  private:
  ::tickview_strategy::CloseAll_CloseAction _internal_close_action() const;
  void _internal_set_close_action(::tickview_strategy::CloseAll_CloseAction value);
  public:

  // @@protoc_insertion_point(class_scope:tickview_strategy.CloseAll)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    int close_action_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_tickview_2dstrategy_2eproto;
};
// -------------------------------------------------------------------

class UnexpectedMinVolume final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:tickview_strategy.UnexpectedMinVolume) */ {
 public:
  inline UnexpectedMinVolume() : UnexpectedMinVolume(nullptr) {}
  ~UnexpectedMinVolume() override;
  explicit PROTOBUF_CONSTEXPR UnexpectedMinVolume(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  UnexpectedMinVolume(const UnexpectedMinVolume& from);
  UnexpectedMinVolume(UnexpectedMinVolume&& from) noexcept
    : UnexpectedMinVolume() {
    *this = ::std::move(from);
  }

  inline UnexpectedMinVolume& operator=(const UnexpectedMinVolume& from) {
    CopyFrom(from);
    return *this;
  }
  inline UnexpectedMinVolume& operator=(UnexpectedMinVolume&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const UnexpectedMinVolume& default_instance() {
    return *internal_default_instance();
  }
  static inline const UnexpectedMinVolume* internal_default_instance() {
    return reinterpret_cast<const UnexpectedMinVolume*>(
               &_UnexpectedMinVolume_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    9;

  friend void swap(UnexpectedMinVolume& a, UnexpectedMinVolume& b) {
    a.Swap(&b);
  }
  inline void Swap(UnexpectedMinVolume* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(UnexpectedMinVolume* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  UnexpectedMinVolume* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<UnexpectedMinVolume>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const UnexpectedMinVolume& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const UnexpectedMinVolume& from) {
    UnexpectedMinVolume::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(UnexpectedMinVolume* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "tickview_strategy.UnexpectedMinVolume";
  }
  protected:
  explicit UnexpectedMinVolume(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kStrategyExchFieldNumber = 1,
    kStrategyGroupFieldNumber = 2,
    kStrategyInsFieldNumber = 3,
    kMinMarketVolumeFieldNumber = 4,
    kMinLimitVolumeFieldNumber = 5,
  };
  // string strategy_exch = 1;
  void clear_strategy_exch();
  const std::string& strategy_exch() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_strategy_exch(ArgT0&& arg0, ArgT... args);
  std::string* mutable_strategy_exch();
  PROTOBUF_NODISCARD std::string* release_strategy_exch();
  void set_allocated_strategy_exch(std::string* strategy_exch);
  private:
  const std::string& _internal_strategy_exch() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_strategy_exch(const std::string& value);
  std::string* _internal_mutable_strategy_exch();
  public:

  // string strategy_group = 2;
  void clear_strategy_group();
  const std::string& strategy_group() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_strategy_group(ArgT0&& arg0, ArgT... args);
  std::string* mutable_strategy_group();
  PROTOBUF_NODISCARD std::string* release_strategy_group();
  void set_allocated_strategy_group(std::string* strategy_group);
  private:
  const std::string& _internal_strategy_group() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_strategy_group(const std::string& value);
  std::string* _internal_mutable_strategy_group();
  public:

  // string strategy_ins = 3;
  void clear_strategy_ins();
  const std::string& strategy_ins() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_strategy_ins(ArgT0&& arg0, ArgT... args);
  std::string* mutable_strategy_ins();
  PROTOBUF_NODISCARD std::string* release_strategy_ins();
  void set_allocated_strategy_ins(std::string* strategy_ins);
  private:
  const std::string& _internal_strategy_ins() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_strategy_ins(const std::string& value);
  std::string* _internal_mutable_strategy_ins();
  public:

  // uint32 min_market_volume = 4;
  void clear_min_market_volume();
  uint32_t min_market_volume() const;
  void set_min_market_volume(uint32_t value);
  private:
  uint32_t _internal_min_market_volume() const;
  void _internal_set_min_market_volume(uint32_t value);
  public:

  // uint32 min_limit_volume = 5;
  void clear_min_limit_volume();
  uint32_t min_limit_volume() const;
  void set_min_limit_volume(uint32_t value);
  private:
  uint32_t _internal_min_limit_volume() const;
  void _internal_set_min_limit_volume(uint32_t value);
  public:

  // @@protoc_insertion_point(class_scope:tickview_strategy.UnexpectedMinVolume)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr strategy_exch_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr strategy_group_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr strategy_ins_;
    uint32_t min_market_volume_;
    uint32_t min_limit_volume_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_tickview_2dstrategy_2eproto;
};
// -------------------------------------------------------------------

class ClearDiagnosticEvent final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:tickview_strategy.ClearDiagnosticEvent) */ {
 public:
  inline ClearDiagnosticEvent() : ClearDiagnosticEvent(nullptr) {}
  ~ClearDiagnosticEvent() override;
  explicit PROTOBUF_CONSTEXPR ClearDiagnosticEvent(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ClearDiagnosticEvent(const ClearDiagnosticEvent& from);
  ClearDiagnosticEvent(ClearDiagnosticEvent&& from) noexcept
    : ClearDiagnosticEvent() {
    *this = ::std::move(from);
  }

  inline ClearDiagnosticEvent& operator=(const ClearDiagnosticEvent& from) {
    CopyFrom(from);
    return *this;
  }
  inline ClearDiagnosticEvent& operator=(ClearDiagnosticEvent&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ClearDiagnosticEvent& default_instance() {
    return *internal_default_instance();
  }
  static inline const ClearDiagnosticEvent* internal_default_instance() {
    return reinterpret_cast<const ClearDiagnosticEvent*>(
               &_ClearDiagnosticEvent_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    10;

  friend void swap(ClearDiagnosticEvent& a, ClearDiagnosticEvent& b) {
    a.Swap(&b);
  }
  inline void Swap(ClearDiagnosticEvent* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ClearDiagnosticEvent* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ClearDiagnosticEvent* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ClearDiagnosticEvent>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ClearDiagnosticEvent& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const ClearDiagnosticEvent& from) {
    ClearDiagnosticEvent::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ClearDiagnosticEvent* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "tickview_strategy.ClearDiagnosticEvent";
  }
  protected:
  explicit ClearDiagnosticEvent(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kDiagnosticEventIdFieldNumber = 1,
  };
  // uint32 diagnostic_event_id = 1;
  void clear_diagnostic_event_id();
  uint32_t diagnostic_event_id() const;
  void set_diagnostic_event_id(uint32_t value);
  private:
  uint32_t _internal_diagnostic_event_id() const;
  void _internal_set_diagnostic_event_id(uint32_t value);
  public:

  // @@protoc_insertion_point(class_scope:tickview_strategy.ClearDiagnosticEvent)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    uint32_t diagnostic_event_id_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_tickview_2dstrategy_2eproto;
};
// -------------------------------------------------------------------

class ClearOldRecord final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:tickview_strategy.ClearOldRecord) */ {
 public:
  inline ClearOldRecord() : ClearOldRecord(nullptr) {}
  ~ClearOldRecord() override;
  explicit PROTOBUF_CONSTEXPR ClearOldRecord(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ClearOldRecord(const ClearOldRecord& from);
  ClearOldRecord(ClearOldRecord&& from) noexcept
    : ClearOldRecord() {
    *this = ::std::move(from);
  }

  inline ClearOldRecord& operator=(const ClearOldRecord& from) {
    CopyFrom(from);
    return *this;
  }
  inline ClearOldRecord& operator=(ClearOldRecord&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ClearOldRecord& default_instance() {
    return *internal_default_instance();
  }
  static inline const ClearOldRecord* internal_default_instance() {
    return reinterpret_cast<const ClearOldRecord*>(
               &_ClearOldRecord_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    11;

  friend void swap(ClearOldRecord& a, ClearOldRecord& b) {
    a.Swap(&b);
  }
  inline void Swap(ClearOldRecord* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ClearOldRecord* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ClearOldRecord* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ClearOldRecord>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ClearOldRecord& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const ClearOldRecord& from) {
    ClearOldRecord::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ClearOldRecord* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "tickview_strategy.ClearOldRecord";
  }
  protected:
  explicit ClearOldRecord(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef ClearOldRecord_ClearAction ClearAction;
  static constexpr ClearAction reserve =
    ClearOldRecord_ClearAction_reserve;
  static constexpr ClearAction clear =
    ClearOldRecord_ClearAction_clear;
  static constexpr ClearAction noclear =
    ClearOldRecord_ClearAction_noclear;
  static inline bool ClearAction_IsValid(int value) {
    return ClearOldRecord_ClearAction_IsValid(value);
  }
  static constexpr ClearAction ClearAction_MIN =
    ClearOldRecord_ClearAction_ClearAction_MIN;
  static constexpr ClearAction ClearAction_MAX =
    ClearOldRecord_ClearAction_ClearAction_MAX;
  static constexpr int ClearAction_ARRAYSIZE =
    ClearOldRecord_ClearAction_ClearAction_ARRAYSIZE;
  static inline const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
  ClearAction_descriptor() {
    return ClearOldRecord_ClearAction_descriptor();
  }
  template<typename T>
  static inline const std::string& ClearAction_Name(T enum_t_value) {
    static_assert(::std::is_same<T, ClearAction>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function ClearAction_Name.");
    return ClearOldRecord_ClearAction_Name(enum_t_value);
  }
  static inline bool ClearAction_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name,
      ClearAction* value) {
    return ClearOldRecord_ClearAction_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  enum : int {
    kClearActionFieldNumber = 1,
  };
  // .tickview_strategy.ClearOldRecord.ClearAction clear_action = 1;
  void clear_clear_action();
  ::tickview_strategy::ClearOldRecord_ClearAction clear_action() const;
  void set_clear_action(::tickview_strategy::ClearOldRecord_ClearAction value);
  private:
  ::tickview_strategy::ClearOldRecord_ClearAction _internal_clear_action() const;
  void _internal_set_clear_action(::tickview_strategy::ClearOldRecord_ClearAction value);
  public:

  // @@protoc_insertion_point(class_scope:tickview_strategy.ClearOldRecord)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    int clear_action_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_tickview_2dstrategy_2eproto;
};
// -------------------------------------------------------------------

class SyncInstrumentSet final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:tickview_strategy.SyncInstrumentSet) */ {
 public:
  inline SyncInstrumentSet() : SyncInstrumentSet(nullptr) {}
  ~SyncInstrumentSet() override;
  explicit PROTOBUF_CONSTEXPR SyncInstrumentSet(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  SyncInstrumentSet(const SyncInstrumentSet& from);
  SyncInstrumentSet(SyncInstrumentSet&& from) noexcept
    : SyncInstrumentSet() {
    *this = ::std::move(from);
  }

  inline SyncInstrumentSet& operator=(const SyncInstrumentSet& from) {
    CopyFrom(from);
    return *this;
  }
  inline SyncInstrumentSet& operator=(SyncInstrumentSet&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SyncInstrumentSet& default_instance() {
    return *internal_default_instance();
  }
  static inline const SyncInstrumentSet* internal_default_instance() {
    return reinterpret_cast<const SyncInstrumentSet*>(
               &_SyncInstrumentSet_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    12;

  friend void swap(SyncInstrumentSet& a, SyncInstrumentSet& b) {
    a.Swap(&b);
  }
  inline void Swap(SyncInstrumentSet* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SyncInstrumentSet* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SyncInstrumentSet* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<SyncInstrumentSet>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const SyncInstrumentSet& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const SyncInstrumentSet& from) {
    SyncInstrumentSet::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SyncInstrumentSet* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "tickview_strategy.SyncInstrumentSet";
  }
  protected:
  explicit SyncInstrumentSet(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef SyncInstrumentSet_SyncAction SyncAction;
  static constexpr SyncAction reserve =
    SyncInstrumentSet_SyncAction_reserve;
  static constexpr SyncAction sync =
    SyncInstrumentSet_SyncAction_sync;
  static constexpr SyncAction nosync =
    SyncInstrumentSet_SyncAction_nosync;
  static inline bool SyncAction_IsValid(int value) {
    return SyncInstrumentSet_SyncAction_IsValid(value);
  }
  static constexpr SyncAction SyncAction_MIN =
    SyncInstrumentSet_SyncAction_SyncAction_MIN;
  static constexpr SyncAction SyncAction_MAX =
    SyncInstrumentSet_SyncAction_SyncAction_MAX;
  static constexpr int SyncAction_ARRAYSIZE =
    SyncInstrumentSet_SyncAction_SyncAction_ARRAYSIZE;
  static inline const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
  SyncAction_descriptor() {
    return SyncInstrumentSet_SyncAction_descriptor();
  }
  template<typename T>
  static inline const std::string& SyncAction_Name(T enum_t_value) {
    static_assert(::std::is_same<T, SyncAction>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function SyncAction_Name.");
    return SyncInstrumentSet_SyncAction_Name(enum_t_value);
  }
  static inline bool SyncAction_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name,
      SyncAction* value) {
    return SyncInstrumentSet_SyncAction_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  enum : int {
    kSyncActionFieldNumber = 1,
  };
  // .tickview_strategy.SyncInstrumentSet.SyncAction sync_action = 1;
  void clear_sync_action();
  ::tickview_strategy::SyncInstrumentSet_SyncAction sync_action() const;
  void set_sync_action(::tickview_strategy::SyncInstrumentSet_SyncAction value);
  private:
  ::tickview_strategy::SyncInstrumentSet_SyncAction _internal_sync_action() const;
  void _internal_set_sync_action(::tickview_strategy::SyncInstrumentSet_SyncAction value);
  public:

  // @@protoc_insertion_point(class_scope:tickview_strategy.SyncInstrumentSet)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    int sync_action_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_tickview_2dstrategy_2eproto;
};
// -------------------------------------------------------------------

class SyncTraderGroup final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:tickview_strategy.SyncTraderGroup) */ {
 public:
  inline SyncTraderGroup() : SyncTraderGroup(nullptr) {}
  ~SyncTraderGroup() override;
  explicit PROTOBUF_CONSTEXPR SyncTraderGroup(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  SyncTraderGroup(const SyncTraderGroup& from);
  SyncTraderGroup(SyncTraderGroup&& from) noexcept
    : SyncTraderGroup() {
    *this = ::std::move(from);
  }

  inline SyncTraderGroup& operator=(const SyncTraderGroup& from) {
    CopyFrom(from);
    return *this;
  }
  inline SyncTraderGroup& operator=(SyncTraderGroup&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SyncTraderGroup& default_instance() {
    return *internal_default_instance();
  }
  static inline const SyncTraderGroup* internal_default_instance() {
    return reinterpret_cast<const SyncTraderGroup*>(
               &_SyncTraderGroup_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    13;

  friend void swap(SyncTraderGroup& a, SyncTraderGroup& b) {
    a.Swap(&b);
  }
  inline void Swap(SyncTraderGroup* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SyncTraderGroup* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SyncTraderGroup* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<SyncTraderGroup>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const SyncTraderGroup& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const SyncTraderGroup& from) {
    SyncTraderGroup::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SyncTraderGroup* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "tickview_strategy.SyncTraderGroup";
  }
  protected:
  explicit SyncTraderGroup(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef SyncTraderGroup_SyncAction SyncAction;
  static constexpr SyncAction reserve =
    SyncTraderGroup_SyncAction_reserve;
  static constexpr SyncAction sync =
    SyncTraderGroup_SyncAction_sync;
  static constexpr SyncAction nosync =
    SyncTraderGroup_SyncAction_nosync;
  static inline bool SyncAction_IsValid(int value) {
    return SyncTraderGroup_SyncAction_IsValid(value);
  }
  static constexpr SyncAction SyncAction_MIN =
    SyncTraderGroup_SyncAction_SyncAction_MIN;
  static constexpr SyncAction SyncAction_MAX =
    SyncTraderGroup_SyncAction_SyncAction_MAX;
  static constexpr int SyncAction_ARRAYSIZE =
    SyncTraderGroup_SyncAction_SyncAction_ARRAYSIZE;
  static inline const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
  SyncAction_descriptor() {
    return SyncTraderGroup_SyncAction_descriptor();
  }
  template<typename T>
  static inline const std::string& SyncAction_Name(T enum_t_value) {
    static_assert(::std::is_same<T, SyncAction>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function SyncAction_Name.");
    return SyncTraderGroup_SyncAction_Name(enum_t_value);
  }
  static inline bool SyncAction_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name,
      SyncAction* value) {
    return SyncTraderGroup_SyncAction_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  enum : int {
    kSyncActionFieldNumber = 1,
  };
  // .tickview_strategy.SyncTraderGroup.SyncAction sync_action = 1;
  void clear_sync_action();
  ::tickview_strategy::SyncTraderGroup_SyncAction sync_action() const;
  void set_sync_action(::tickview_strategy::SyncTraderGroup_SyncAction value);
  private:
  ::tickview_strategy::SyncTraderGroup_SyncAction _internal_sync_action() const;
  void _internal_set_sync_action(::tickview_strategy::SyncTraderGroup_SyncAction value);
  public:

  // @@protoc_insertion_point(class_scope:tickview_strategy.SyncTraderGroup)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    int sync_action_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_tickview_2dstrategy_2eproto;
};
// -------------------------------------------------------------------

class HeavyAttack final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:tickview_strategy.HeavyAttack) */ {
 public:
  inline HeavyAttack() : HeavyAttack(nullptr) {}
  ~HeavyAttack() override;
  explicit PROTOBUF_CONSTEXPR HeavyAttack(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  HeavyAttack(const HeavyAttack& from);
  HeavyAttack(HeavyAttack&& from) noexcept
    : HeavyAttack() {
    *this = ::std::move(from);
  }

  inline HeavyAttack& operator=(const HeavyAttack& from) {
    CopyFrom(from);
    return *this;
  }
  inline HeavyAttack& operator=(HeavyAttack&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const HeavyAttack& default_instance() {
    return *internal_default_instance();
  }
  static inline const HeavyAttack* internal_default_instance() {
    return reinterpret_cast<const HeavyAttack*>(
               &_HeavyAttack_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    14;

  friend void swap(HeavyAttack& a, HeavyAttack& b) {
    a.Swap(&b);
  }
  inline void Swap(HeavyAttack* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(HeavyAttack* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  HeavyAttack* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<HeavyAttack>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const HeavyAttack& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const HeavyAttack& from) {
    HeavyAttack::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(HeavyAttack* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "tickview_strategy.HeavyAttack";
  }
  protected:
  explicit HeavyAttack(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kStrategyExchFieldNumber = 1,
    kStrategyGroupFieldNumber = 2,
    kStrategyInsFieldNumber = 3,
    kStrategyIndexFieldNumber = 4,
    kAttackAmplitudeFieldNumber = 6,
    kAttackNumberFieldNumber = 5,
  };
  // string strategy_exch = 1;
  void clear_strategy_exch();
  const std::string& strategy_exch() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_strategy_exch(ArgT0&& arg0, ArgT... args);
  std::string* mutable_strategy_exch();
  PROTOBUF_NODISCARD std::string* release_strategy_exch();
  void set_allocated_strategy_exch(std::string* strategy_exch);
  private:
  const std::string& _internal_strategy_exch() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_strategy_exch(const std::string& value);
  std::string* _internal_mutable_strategy_exch();
  public:

  // string strategy_group = 2;
  void clear_strategy_group();
  const std::string& strategy_group() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_strategy_group(ArgT0&& arg0, ArgT... args);
  std::string* mutable_strategy_group();
  PROTOBUF_NODISCARD std::string* release_strategy_group();
  void set_allocated_strategy_group(std::string* strategy_group);
  private:
  const std::string& _internal_strategy_group() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_strategy_group(const std::string& value);
  std::string* _internal_mutable_strategy_group();
  public:

  // string strategy_ins = 3;
  void clear_strategy_ins();
  const std::string& strategy_ins() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_strategy_ins(ArgT0&& arg0, ArgT... args);
  std::string* mutable_strategy_ins();
  PROTOBUF_NODISCARD std::string* release_strategy_ins();
  void set_allocated_strategy_ins(std::string* strategy_ins);
  private:
  const std::string& _internal_strategy_ins() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_strategy_ins(const std::string& value);
  std::string* _internal_mutable_strategy_ins();
  public:

  // string strategy_index = 4;
  void clear_strategy_index();
  const std::string& strategy_index() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_strategy_index(ArgT0&& arg0, ArgT... args);
  std::string* mutable_strategy_index();
  PROTOBUF_NODISCARD std::string* release_strategy_index();
  void set_allocated_strategy_index(std::string* strategy_index);
  private:
  const std::string& _internal_strategy_index() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_strategy_index(const std::string& value);
  std::string* _internal_mutable_strategy_index();
  public:

  // double attack_amplitude = 6;
  void clear_attack_amplitude();
  double attack_amplitude() const;
  void set_attack_amplitude(double value);
  private:
  double _internal_attack_amplitude() const;
  void _internal_set_attack_amplitude(double value);
  public:

  // uint32 attack_number = 5;
  void clear_attack_number();
  uint32_t attack_number() const;
  void set_attack_number(uint32_t value);
  private:
  uint32_t _internal_attack_number() const;
  void _internal_set_attack_number(uint32_t value);
  public:

  // @@protoc_insertion_point(class_scope:tickview_strategy.HeavyAttack)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr strategy_exch_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr strategy_group_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr strategy_ins_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr strategy_index_;
    double attack_amplitude_;
    uint32_t attack_number_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_tickview_2dstrategy_2eproto;
};
// -------------------------------------------------------------------

class FrontAdjust final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:tickview_strategy.FrontAdjust) */ {
 public:
  inline FrontAdjust() : FrontAdjust(nullptr) {}
  ~FrontAdjust() override;
  explicit PROTOBUF_CONSTEXPR FrontAdjust(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  FrontAdjust(const FrontAdjust& from);
  FrontAdjust(FrontAdjust&& from) noexcept
    : FrontAdjust() {
    *this = ::std::move(from);
  }

  inline FrontAdjust& operator=(const FrontAdjust& from) {
    CopyFrom(from);
    return *this;
  }
  inline FrontAdjust& operator=(FrontAdjust&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const FrontAdjust& default_instance() {
    return *internal_default_instance();
  }
  static inline const FrontAdjust* internal_default_instance() {
    return reinterpret_cast<const FrontAdjust*>(
               &_FrontAdjust_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    15;

  friend void swap(FrontAdjust& a, FrontAdjust& b) {
    a.Swap(&b);
  }
  inline void Swap(FrontAdjust* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(FrontAdjust* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  FrontAdjust* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<FrontAdjust>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const FrontAdjust& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const FrontAdjust& from) {
    FrontAdjust::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(FrontAdjust* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "tickview_strategy.FrontAdjust";
  }
  protected:
  explicit FrontAdjust(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kStrategyExchFieldNumber = 1,
    kStrategyGroupFieldNumber = 2,
    kStrategyInsFieldNumber = 3,
    kOldSharesFieldNumber = 4,
    kNewSharesFieldNumber = 5,
  };
  // string strategy_exch = 1;
  void clear_strategy_exch();
  const std::string& strategy_exch() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_strategy_exch(ArgT0&& arg0, ArgT... args);
  std::string* mutable_strategy_exch();
  PROTOBUF_NODISCARD std::string* release_strategy_exch();
  void set_allocated_strategy_exch(std::string* strategy_exch);
  private:
  const std::string& _internal_strategy_exch() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_strategy_exch(const std::string& value);
  std::string* _internal_mutable_strategy_exch();
  public:

  // string strategy_group = 2;
  void clear_strategy_group();
  const std::string& strategy_group() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_strategy_group(ArgT0&& arg0, ArgT... args);
  std::string* mutable_strategy_group();
  PROTOBUF_NODISCARD std::string* release_strategy_group();
  void set_allocated_strategy_group(std::string* strategy_group);
  private:
  const std::string& _internal_strategy_group() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_strategy_group(const std::string& value);
  std::string* _internal_mutable_strategy_group();
  public:

  // string strategy_ins = 3;
  void clear_strategy_ins();
  const std::string& strategy_ins() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_strategy_ins(ArgT0&& arg0, ArgT... args);
  std::string* mutable_strategy_ins();
  PROTOBUF_NODISCARD std::string* release_strategy_ins();
  void set_allocated_strategy_ins(std::string* strategy_ins);
  private:
  const std::string& _internal_strategy_ins() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_strategy_ins(const std::string& value);
  std::string* _internal_mutable_strategy_ins();
  public:

  // uint32 old_shares = 4;
  void clear_old_shares();
  uint32_t old_shares() const;
  void set_old_shares(uint32_t value);
  private:
  uint32_t _internal_old_shares() const;
  void _internal_set_old_shares(uint32_t value);
  public:

  // uint32 new_shares = 5;
  void clear_new_shares();
  uint32_t new_shares() const;
  void set_new_shares(uint32_t value);
  private:
  uint32_t _internal_new_shares() const;
  void _internal_set_new_shares(uint32_t value);
  public:

  // @@protoc_insertion_point(class_scope:tickview_strategy.FrontAdjust)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr strategy_exch_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr strategy_group_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr strategy_ins_;
    uint32_t old_shares_;
    uint32_t new_shares_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_tickview_2dstrategy_2eproto;
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// message

// .tickview_strategy.Level1ControlReq control_req = 1;
inline bool message::_internal_has_control_req() const {
  return MessageType_case() == kControlReq;
}
inline bool message::has_control_req() const {
  return _internal_has_control_req();
}
inline void message::set_has_control_req() {
  _impl_._oneof_case_[0] = kControlReq;
}
inline void message::clear_control_req() {
  if (_internal_has_control_req()) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.MessageType_.control_req_;
    }
    clear_has_MessageType();
  }
}
inline ::tickview_strategy::Level1ControlReq* message::release_control_req() {
  // @@protoc_insertion_point(field_release:tickview_strategy.message.control_req)
  if (_internal_has_control_req()) {
    clear_has_MessageType();
    ::tickview_strategy::Level1ControlReq* temp = _impl_.MessageType_.control_req_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.MessageType_.control_req_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::tickview_strategy::Level1ControlReq& message::_internal_control_req() const {
  return _internal_has_control_req()
      ? *_impl_.MessageType_.control_req_
      : reinterpret_cast< ::tickview_strategy::Level1ControlReq&>(::tickview_strategy::_Level1ControlReq_default_instance_);
}
inline const ::tickview_strategy::Level1ControlReq& message::control_req() const {
  // @@protoc_insertion_point(field_get:tickview_strategy.message.control_req)
  return _internal_control_req();
}
inline ::tickview_strategy::Level1ControlReq* message::unsafe_arena_release_control_req() {
  // @@protoc_insertion_point(field_unsafe_arena_release:tickview_strategy.message.control_req)
  if (_internal_has_control_req()) {
    clear_has_MessageType();
    ::tickview_strategy::Level1ControlReq* temp = _impl_.MessageType_.control_req_;
    _impl_.MessageType_.control_req_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void message::unsafe_arena_set_allocated_control_req(::tickview_strategy::Level1ControlReq* control_req) {
  clear_MessageType();
  if (control_req) {
    set_has_control_req();
    _impl_.MessageType_.control_req_ = control_req;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:tickview_strategy.message.control_req)
}
inline ::tickview_strategy::Level1ControlReq* message::_internal_mutable_control_req() {
  if (!_internal_has_control_req()) {
    clear_MessageType();
    set_has_control_req();
    _impl_.MessageType_.control_req_ = CreateMaybeMessage< ::tickview_strategy::Level1ControlReq >(GetArenaForAllocation());
  }
  return _impl_.MessageType_.control_req_;
}
inline ::tickview_strategy::Level1ControlReq* message::mutable_control_req() {
  ::tickview_strategy::Level1ControlReq* _msg = _internal_mutable_control_req();
  // @@protoc_insertion_point(field_mutable:tickview_strategy.message.control_req)
  return _msg;
}

// .tickview_strategy.OrderConditionMandatorySet order_condition = 2;
inline bool message::_internal_has_order_condition() const {
  return MessageType_case() == kOrderCondition;
}
inline bool message::has_order_condition() const {
  return _internal_has_order_condition();
}
inline void message::set_has_order_condition() {
  _impl_._oneof_case_[0] = kOrderCondition;
}
inline void message::clear_order_condition() {
  if (_internal_has_order_condition()) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.MessageType_.order_condition_;
    }
    clear_has_MessageType();
  }
}
inline ::tickview_strategy::OrderConditionMandatorySet* message::release_order_condition() {
  // @@protoc_insertion_point(field_release:tickview_strategy.message.order_condition)
  if (_internal_has_order_condition()) {
    clear_has_MessageType();
    ::tickview_strategy::OrderConditionMandatorySet* temp = _impl_.MessageType_.order_condition_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.MessageType_.order_condition_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::tickview_strategy::OrderConditionMandatorySet& message::_internal_order_condition() const {
  return _internal_has_order_condition()
      ? *_impl_.MessageType_.order_condition_
      : reinterpret_cast< ::tickview_strategy::OrderConditionMandatorySet&>(::tickview_strategy::_OrderConditionMandatorySet_default_instance_);
}
inline const ::tickview_strategy::OrderConditionMandatorySet& message::order_condition() const {
  // @@protoc_insertion_point(field_get:tickview_strategy.message.order_condition)
  return _internal_order_condition();
}
inline ::tickview_strategy::OrderConditionMandatorySet* message::unsafe_arena_release_order_condition() {
  // @@protoc_insertion_point(field_unsafe_arena_release:tickview_strategy.message.order_condition)
  if (_internal_has_order_condition()) {
    clear_has_MessageType();
    ::tickview_strategy::OrderConditionMandatorySet* temp = _impl_.MessageType_.order_condition_;
    _impl_.MessageType_.order_condition_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void message::unsafe_arena_set_allocated_order_condition(::tickview_strategy::OrderConditionMandatorySet* order_condition) {
  clear_MessageType();
  if (order_condition) {
    set_has_order_condition();
    _impl_.MessageType_.order_condition_ = order_condition;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:tickview_strategy.message.order_condition)
}
inline ::tickview_strategy::OrderConditionMandatorySet* message::_internal_mutable_order_condition() {
  if (!_internal_has_order_condition()) {
    clear_MessageType();
    set_has_order_condition();
    _impl_.MessageType_.order_condition_ = CreateMaybeMessage< ::tickview_strategy::OrderConditionMandatorySet >(GetArenaForAllocation());
  }
  return _impl_.MessageType_.order_condition_;
}
inline ::tickview_strategy::OrderConditionMandatorySet* message::mutable_order_condition() {
  ::tickview_strategy::OrderConditionMandatorySet* _msg = _internal_mutable_order_condition();
  // @@protoc_insertion_point(field_mutable:tickview_strategy.message.order_condition)
  return _msg;
}

// .tickview_strategy.BugInjection bug_injection = 3;
inline bool message::_internal_has_bug_injection() const {
  return MessageType_case() == kBugInjection;
}
inline bool message::has_bug_injection() const {
  return _internal_has_bug_injection();
}
inline void message::set_has_bug_injection() {
  _impl_._oneof_case_[0] = kBugInjection;
}
inline void message::clear_bug_injection() {
  if (_internal_has_bug_injection()) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.MessageType_.bug_injection_;
    }
    clear_has_MessageType();
  }
}
inline ::tickview_strategy::BugInjection* message::release_bug_injection() {
  // @@protoc_insertion_point(field_release:tickview_strategy.message.bug_injection)
  if (_internal_has_bug_injection()) {
    clear_has_MessageType();
    ::tickview_strategy::BugInjection* temp = _impl_.MessageType_.bug_injection_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.MessageType_.bug_injection_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::tickview_strategy::BugInjection& message::_internal_bug_injection() const {
  return _internal_has_bug_injection()
      ? *_impl_.MessageType_.bug_injection_
      : reinterpret_cast< ::tickview_strategy::BugInjection&>(::tickview_strategy::_BugInjection_default_instance_);
}
inline const ::tickview_strategy::BugInjection& message::bug_injection() const {
  // @@protoc_insertion_point(field_get:tickview_strategy.message.bug_injection)
  return _internal_bug_injection();
}
inline ::tickview_strategy::BugInjection* message::unsafe_arena_release_bug_injection() {
  // @@protoc_insertion_point(field_unsafe_arena_release:tickview_strategy.message.bug_injection)
  if (_internal_has_bug_injection()) {
    clear_has_MessageType();
    ::tickview_strategy::BugInjection* temp = _impl_.MessageType_.bug_injection_;
    _impl_.MessageType_.bug_injection_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void message::unsafe_arena_set_allocated_bug_injection(::tickview_strategy::BugInjection* bug_injection) {
  clear_MessageType();
  if (bug_injection) {
    set_has_bug_injection();
    _impl_.MessageType_.bug_injection_ = bug_injection;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:tickview_strategy.message.bug_injection)
}
inline ::tickview_strategy::BugInjection* message::_internal_mutable_bug_injection() {
  if (!_internal_has_bug_injection()) {
    clear_MessageType();
    set_has_bug_injection();
    _impl_.MessageType_.bug_injection_ = CreateMaybeMessage< ::tickview_strategy::BugInjection >(GetArenaForAllocation());
  }
  return _impl_.MessageType_.bug_injection_;
}
inline ::tickview_strategy::BugInjection* message::mutable_bug_injection() {
  ::tickview_strategy::BugInjection* _msg = _internal_mutable_bug_injection();
  // @@protoc_insertion_point(field_mutable:tickview_strategy.message.bug_injection)
  return _msg;
}

// .tickview_strategy.BatchControlReq batch_req = 4;
inline bool message::_internal_has_batch_req() const {
  return MessageType_case() == kBatchReq;
}
inline bool message::has_batch_req() const {
  return _internal_has_batch_req();
}
inline void message::set_has_batch_req() {
  _impl_._oneof_case_[0] = kBatchReq;
}
inline void message::clear_batch_req() {
  if (_internal_has_batch_req()) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.MessageType_.batch_req_;
    }
    clear_has_MessageType();
  }
}
inline ::tickview_strategy::BatchControlReq* message::release_batch_req() {
  // @@protoc_insertion_point(field_release:tickview_strategy.message.batch_req)
  if (_internal_has_batch_req()) {
    clear_has_MessageType();
    ::tickview_strategy::BatchControlReq* temp = _impl_.MessageType_.batch_req_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.MessageType_.batch_req_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::tickview_strategy::BatchControlReq& message::_internal_batch_req() const {
  return _internal_has_batch_req()
      ? *_impl_.MessageType_.batch_req_
      : reinterpret_cast< ::tickview_strategy::BatchControlReq&>(::tickview_strategy::_BatchControlReq_default_instance_);
}
inline const ::tickview_strategy::BatchControlReq& message::batch_req() const {
  // @@protoc_insertion_point(field_get:tickview_strategy.message.batch_req)
  return _internal_batch_req();
}
inline ::tickview_strategy::BatchControlReq* message::unsafe_arena_release_batch_req() {
  // @@protoc_insertion_point(field_unsafe_arena_release:tickview_strategy.message.batch_req)
  if (_internal_has_batch_req()) {
    clear_has_MessageType();
    ::tickview_strategy::BatchControlReq* temp = _impl_.MessageType_.batch_req_;
    _impl_.MessageType_.batch_req_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void message::unsafe_arena_set_allocated_batch_req(::tickview_strategy::BatchControlReq* batch_req) {
  clear_MessageType();
  if (batch_req) {
    set_has_batch_req();
    _impl_.MessageType_.batch_req_ = batch_req;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:tickview_strategy.message.batch_req)
}
inline ::tickview_strategy::BatchControlReq* message::_internal_mutable_batch_req() {
  if (!_internal_has_batch_req()) {
    clear_MessageType();
    set_has_batch_req();
    _impl_.MessageType_.batch_req_ = CreateMaybeMessage< ::tickview_strategy::BatchControlReq >(GetArenaForAllocation());
  }
  return _impl_.MessageType_.batch_req_;
}
inline ::tickview_strategy::BatchControlReq* message::mutable_batch_req() {
  ::tickview_strategy::BatchControlReq* _msg = _internal_mutable_batch_req();
  // @@protoc_insertion_point(field_mutable:tickview_strategy.message.batch_req)
  return _msg;
}

// .tickview_strategy.ProfilerControl profiler_control = 5;
inline bool message::_internal_has_profiler_control() const {
  return MessageType_case() == kProfilerControl;
}
inline bool message::has_profiler_control() const {
  return _internal_has_profiler_control();
}
inline void message::set_has_profiler_control() {
  _impl_._oneof_case_[0] = kProfilerControl;
}
inline void message::clear_profiler_control() {
  if (_internal_has_profiler_control()) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.MessageType_.profiler_control_;
    }
    clear_has_MessageType();
  }
}
inline ::tickview_strategy::ProfilerControl* message::release_profiler_control() {
  // @@protoc_insertion_point(field_release:tickview_strategy.message.profiler_control)
  if (_internal_has_profiler_control()) {
    clear_has_MessageType();
    ::tickview_strategy::ProfilerControl* temp = _impl_.MessageType_.profiler_control_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.MessageType_.profiler_control_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::tickview_strategy::ProfilerControl& message::_internal_profiler_control() const {
  return _internal_has_profiler_control()
      ? *_impl_.MessageType_.profiler_control_
      : reinterpret_cast< ::tickview_strategy::ProfilerControl&>(::tickview_strategy::_ProfilerControl_default_instance_);
}
inline const ::tickview_strategy::ProfilerControl& message::profiler_control() const {
  // @@protoc_insertion_point(field_get:tickview_strategy.message.profiler_control)
  return _internal_profiler_control();
}
inline ::tickview_strategy::ProfilerControl* message::unsafe_arena_release_profiler_control() {
  // @@protoc_insertion_point(field_unsafe_arena_release:tickview_strategy.message.profiler_control)
  if (_internal_has_profiler_control()) {
    clear_has_MessageType();
    ::tickview_strategy::ProfilerControl* temp = _impl_.MessageType_.profiler_control_;
    _impl_.MessageType_.profiler_control_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void message::unsafe_arena_set_allocated_profiler_control(::tickview_strategy::ProfilerControl* profiler_control) {
  clear_MessageType();
  if (profiler_control) {
    set_has_profiler_control();
    _impl_.MessageType_.profiler_control_ = profiler_control;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:tickview_strategy.message.profiler_control)
}
inline ::tickview_strategy::ProfilerControl* message::_internal_mutable_profiler_control() {
  if (!_internal_has_profiler_control()) {
    clear_MessageType();
    set_has_profiler_control();
    _impl_.MessageType_.profiler_control_ = CreateMaybeMessage< ::tickview_strategy::ProfilerControl >(GetArenaForAllocation());
  }
  return _impl_.MessageType_.profiler_control_;
}
inline ::tickview_strategy::ProfilerControl* message::mutable_profiler_control() {
  ::tickview_strategy::ProfilerControl* _msg = _internal_mutable_profiler_control();
  // @@protoc_insertion_point(field_mutable:tickview_strategy.message.profiler_control)
  return _msg;
}

// .tickview_strategy.UpdateProjectPara update_project_para = 6;
inline bool message::_internal_has_update_project_para() const {
  return MessageType_case() == kUpdateProjectPara;
}
inline bool message::has_update_project_para() const {
  return _internal_has_update_project_para();
}
inline void message::set_has_update_project_para() {
  _impl_._oneof_case_[0] = kUpdateProjectPara;
}
inline void message::clear_update_project_para() {
  if (_internal_has_update_project_para()) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.MessageType_.update_project_para_;
    }
    clear_has_MessageType();
  }
}
inline ::tickview_strategy::UpdateProjectPara* message::release_update_project_para() {
  // @@protoc_insertion_point(field_release:tickview_strategy.message.update_project_para)
  if (_internal_has_update_project_para()) {
    clear_has_MessageType();
    ::tickview_strategy::UpdateProjectPara* temp = _impl_.MessageType_.update_project_para_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.MessageType_.update_project_para_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::tickview_strategy::UpdateProjectPara& message::_internal_update_project_para() const {
  return _internal_has_update_project_para()
      ? *_impl_.MessageType_.update_project_para_
      : reinterpret_cast< ::tickview_strategy::UpdateProjectPara&>(::tickview_strategy::_UpdateProjectPara_default_instance_);
}
inline const ::tickview_strategy::UpdateProjectPara& message::update_project_para() const {
  // @@protoc_insertion_point(field_get:tickview_strategy.message.update_project_para)
  return _internal_update_project_para();
}
inline ::tickview_strategy::UpdateProjectPara* message::unsafe_arena_release_update_project_para() {
  // @@protoc_insertion_point(field_unsafe_arena_release:tickview_strategy.message.update_project_para)
  if (_internal_has_update_project_para()) {
    clear_has_MessageType();
    ::tickview_strategy::UpdateProjectPara* temp = _impl_.MessageType_.update_project_para_;
    _impl_.MessageType_.update_project_para_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void message::unsafe_arena_set_allocated_update_project_para(::tickview_strategy::UpdateProjectPara* update_project_para) {
  clear_MessageType();
  if (update_project_para) {
    set_has_update_project_para();
    _impl_.MessageType_.update_project_para_ = update_project_para;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:tickview_strategy.message.update_project_para)
}
inline ::tickview_strategy::UpdateProjectPara* message::_internal_mutable_update_project_para() {
  if (!_internal_has_update_project_para()) {
    clear_MessageType();
    set_has_update_project_para();
    _impl_.MessageType_.update_project_para_ = CreateMaybeMessage< ::tickview_strategy::UpdateProjectPara >(GetArenaForAllocation());
  }
  return _impl_.MessageType_.update_project_para_;
}
inline ::tickview_strategy::UpdateProjectPara* message::mutable_update_project_para() {
  ::tickview_strategy::UpdateProjectPara* _msg = _internal_mutable_update_project_para();
  // @@protoc_insertion_point(field_mutable:tickview_strategy.message.update_project_para)
  return _msg;
}

// .tickview_strategy.UpdateStrategyPara update_strategy_para = 7;
inline bool message::_internal_has_update_strategy_para() const {
  return MessageType_case() == kUpdateStrategyPara;
}
inline bool message::has_update_strategy_para() const {
  return _internal_has_update_strategy_para();
}
inline void message::set_has_update_strategy_para() {
  _impl_._oneof_case_[0] = kUpdateStrategyPara;
}
inline void message::clear_update_strategy_para() {
  if (_internal_has_update_strategy_para()) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.MessageType_.update_strategy_para_;
    }
    clear_has_MessageType();
  }
}
inline ::tickview_strategy::UpdateStrategyPara* message::release_update_strategy_para() {
  // @@protoc_insertion_point(field_release:tickview_strategy.message.update_strategy_para)
  if (_internal_has_update_strategy_para()) {
    clear_has_MessageType();
    ::tickview_strategy::UpdateStrategyPara* temp = _impl_.MessageType_.update_strategy_para_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.MessageType_.update_strategy_para_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::tickview_strategy::UpdateStrategyPara& message::_internal_update_strategy_para() const {
  return _internal_has_update_strategy_para()
      ? *_impl_.MessageType_.update_strategy_para_
      : reinterpret_cast< ::tickview_strategy::UpdateStrategyPara&>(::tickview_strategy::_UpdateStrategyPara_default_instance_);
}
inline const ::tickview_strategy::UpdateStrategyPara& message::update_strategy_para() const {
  // @@protoc_insertion_point(field_get:tickview_strategy.message.update_strategy_para)
  return _internal_update_strategy_para();
}
inline ::tickview_strategy::UpdateStrategyPara* message::unsafe_arena_release_update_strategy_para() {
  // @@protoc_insertion_point(field_unsafe_arena_release:tickview_strategy.message.update_strategy_para)
  if (_internal_has_update_strategy_para()) {
    clear_has_MessageType();
    ::tickview_strategy::UpdateStrategyPara* temp = _impl_.MessageType_.update_strategy_para_;
    _impl_.MessageType_.update_strategy_para_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void message::unsafe_arena_set_allocated_update_strategy_para(::tickview_strategy::UpdateStrategyPara* update_strategy_para) {
  clear_MessageType();
  if (update_strategy_para) {
    set_has_update_strategy_para();
    _impl_.MessageType_.update_strategy_para_ = update_strategy_para;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:tickview_strategy.message.update_strategy_para)
}
inline ::tickview_strategy::UpdateStrategyPara* message::_internal_mutable_update_strategy_para() {
  if (!_internal_has_update_strategy_para()) {
    clear_MessageType();
    set_has_update_strategy_para();
    _impl_.MessageType_.update_strategy_para_ = CreateMaybeMessage< ::tickview_strategy::UpdateStrategyPara >(GetArenaForAllocation());
  }
  return _impl_.MessageType_.update_strategy_para_;
}
inline ::tickview_strategy::UpdateStrategyPara* message::mutable_update_strategy_para() {
  ::tickview_strategy::UpdateStrategyPara* _msg = _internal_mutable_update_strategy_para();
  // @@protoc_insertion_point(field_mutable:tickview_strategy.message.update_strategy_para)
  return _msg;
}

// .tickview_strategy.CloseAll close_all = 8;
inline bool message::_internal_has_close_all() const {
  return MessageType_case() == kCloseAll;
}
inline bool message::has_close_all() const {
  return _internal_has_close_all();
}
inline void message::set_has_close_all() {
  _impl_._oneof_case_[0] = kCloseAll;
}
inline void message::clear_close_all() {
  if (_internal_has_close_all()) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.MessageType_.close_all_;
    }
    clear_has_MessageType();
  }
}
inline ::tickview_strategy::CloseAll* message::release_close_all() {
  // @@protoc_insertion_point(field_release:tickview_strategy.message.close_all)
  if (_internal_has_close_all()) {
    clear_has_MessageType();
    ::tickview_strategy::CloseAll* temp = _impl_.MessageType_.close_all_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.MessageType_.close_all_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::tickview_strategy::CloseAll& message::_internal_close_all() const {
  return _internal_has_close_all()
      ? *_impl_.MessageType_.close_all_
      : reinterpret_cast< ::tickview_strategy::CloseAll&>(::tickview_strategy::_CloseAll_default_instance_);
}
inline const ::tickview_strategy::CloseAll& message::close_all() const {
  // @@protoc_insertion_point(field_get:tickview_strategy.message.close_all)
  return _internal_close_all();
}
inline ::tickview_strategy::CloseAll* message::unsafe_arena_release_close_all() {
  // @@protoc_insertion_point(field_unsafe_arena_release:tickview_strategy.message.close_all)
  if (_internal_has_close_all()) {
    clear_has_MessageType();
    ::tickview_strategy::CloseAll* temp = _impl_.MessageType_.close_all_;
    _impl_.MessageType_.close_all_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void message::unsafe_arena_set_allocated_close_all(::tickview_strategy::CloseAll* close_all) {
  clear_MessageType();
  if (close_all) {
    set_has_close_all();
    _impl_.MessageType_.close_all_ = close_all;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:tickview_strategy.message.close_all)
}
inline ::tickview_strategy::CloseAll* message::_internal_mutable_close_all() {
  if (!_internal_has_close_all()) {
    clear_MessageType();
    set_has_close_all();
    _impl_.MessageType_.close_all_ = CreateMaybeMessage< ::tickview_strategy::CloseAll >(GetArenaForAllocation());
  }
  return _impl_.MessageType_.close_all_;
}
inline ::tickview_strategy::CloseAll* message::mutable_close_all() {
  ::tickview_strategy::CloseAll* _msg = _internal_mutable_close_all();
  // @@protoc_insertion_point(field_mutable:tickview_strategy.message.close_all)
  return _msg;
}

// .tickview_strategy.UnexpectedMinVolume unexpected_min_volume = 9;
inline bool message::_internal_has_unexpected_min_volume() const {
  return MessageType_case() == kUnexpectedMinVolume;
}
inline bool message::has_unexpected_min_volume() const {
  return _internal_has_unexpected_min_volume();
}
inline void message::set_has_unexpected_min_volume() {
  _impl_._oneof_case_[0] = kUnexpectedMinVolume;
}
inline void message::clear_unexpected_min_volume() {
  if (_internal_has_unexpected_min_volume()) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.MessageType_.unexpected_min_volume_;
    }
    clear_has_MessageType();
  }
}
inline ::tickview_strategy::UnexpectedMinVolume* message::release_unexpected_min_volume() {
  // @@protoc_insertion_point(field_release:tickview_strategy.message.unexpected_min_volume)
  if (_internal_has_unexpected_min_volume()) {
    clear_has_MessageType();
    ::tickview_strategy::UnexpectedMinVolume* temp = _impl_.MessageType_.unexpected_min_volume_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.MessageType_.unexpected_min_volume_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::tickview_strategy::UnexpectedMinVolume& message::_internal_unexpected_min_volume() const {
  return _internal_has_unexpected_min_volume()
      ? *_impl_.MessageType_.unexpected_min_volume_
      : reinterpret_cast< ::tickview_strategy::UnexpectedMinVolume&>(::tickview_strategy::_UnexpectedMinVolume_default_instance_);
}
inline const ::tickview_strategy::UnexpectedMinVolume& message::unexpected_min_volume() const {
  // @@protoc_insertion_point(field_get:tickview_strategy.message.unexpected_min_volume)
  return _internal_unexpected_min_volume();
}
inline ::tickview_strategy::UnexpectedMinVolume* message::unsafe_arena_release_unexpected_min_volume() {
  // @@protoc_insertion_point(field_unsafe_arena_release:tickview_strategy.message.unexpected_min_volume)
  if (_internal_has_unexpected_min_volume()) {
    clear_has_MessageType();
    ::tickview_strategy::UnexpectedMinVolume* temp = _impl_.MessageType_.unexpected_min_volume_;
    _impl_.MessageType_.unexpected_min_volume_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void message::unsafe_arena_set_allocated_unexpected_min_volume(::tickview_strategy::UnexpectedMinVolume* unexpected_min_volume) {
  clear_MessageType();
  if (unexpected_min_volume) {
    set_has_unexpected_min_volume();
    _impl_.MessageType_.unexpected_min_volume_ = unexpected_min_volume;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:tickview_strategy.message.unexpected_min_volume)
}
inline ::tickview_strategy::UnexpectedMinVolume* message::_internal_mutable_unexpected_min_volume() {
  if (!_internal_has_unexpected_min_volume()) {
    clear_MessageType();
    set_has_unexpected_min_volume();
    _impl_.MessageType_.unexpected_min_volume_ = CreateMaybeMessage< ::tickview_strategy::UnexpectedMinVolume >(GetArenaForAllocation());
  }
  return _impl_.MessageType_.unexpected_min_volume_;
}
inline ::tickview_strategy::UnexpectedMinVolume* message::mutable_unexpected_min_volume() {
  ::tickview_strategy::UnexpectedMinVolume* _msg = _internal_mutable_unexpected_min_volume();
  // @@protoc_insertion_point(field_mutable:tickview_strategy.message.unexpected_min_volume)
  return _msg;
}

// .tickview_strategy.ClearDiagnosticEvent clear_diagnostic_event = 10;
inline bool message::_internal_has_clear_diagnostic_event() const {
  return MessageType_case() == kClearDiagnosticEvent;
}
inline bool message::has_clear_diagnostic_event() const {
  return _internal_has_clear_diagnostic_event();
}
inline void message::set_has_clear_diagnostic_event() {
  _impl_._oneof_case_[0] = kClearDiagnosticEvent;
}
inline void message::clear_clear_diagnostic_event() {
  if (_internal_has_clear_diagnostic_event()) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.MessageType_.clear_diagnostic_event_;
    }
    clear_has_MessageType();
  }
}
inline ::tickview_strategy::ClearDiagnosticEvent* message::release_clear_diagnostic_event() {
  // @@protoc_insertion_point(field_release:tickview_strategy.message.clear_diagnostic_event)
  if (_internal_has_clear_diagnostic_event()) {
    clear_has_MessageType();
    ::tickview_strategy::ClearDiagnosticEvent* temp = _impl_.MessageType_.clear_diagnostic_event_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.MessageType_.clear_diagnostic_event_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::tickview_strategy::ClearDiagnosticEvent& message::_internal_clear_diagnostic_event() const {
  return _internal_has_clear_diagnostic_event()
      ? *_impl_.MessageType_.clear_diagnostic_event_
      : reinterpret_cast< ::tickview_strategy::ClearDiagnosticEvent&>(::tickview_strategy::_ClearDiagnosticEvent_default_instance_);
}
inline const ::tickview_strategy::ClearDiagnosticEvent& message::clear_diagnostic_event() const {
  // @@protoc_insertion_point(field_get:tickview_strategy.message.clear_diagnostic_event)
  return _internal_clear_diagnostic_event();
}
inline ::tickview_strategy::ClearDiagnosticEvent* message::unsafe_arena_release_clear_diagnostic_event() {
  // @@protoc_insertion_point(field_unsafe_arena_release:tickview_strategy.message.clear_diagnostic_event)
  if (_internal_has_clear_diagnostic_event()) {
    clear_has_MessageType();
    ::tickview_strategy::ClearDiagnosticEvent* temp = _impl_.MessageType_.clear_diagnostic_event_;
    _impl_.MessageType_.clear_diagnostic_event_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void message::unsafe_arena_set_allocated_clear_diagnostic_event(::tickview_strategy::ClearDiagnosticEvent* clear_diagnostic_event) {
  clear_MessageType();
  if (clear_diagnostic_event) {
    set_has_clear_diagnostic_event();
    _impl_.MessageType_.clear_diagnostic_event_ = clear_diagnostic_event;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:tickview_strategy.message.clear_diagnostic_event)
}
inline ::tickview_strategy::ClearDiagnosticEvent* message::_internal_mutable_clear_diagnostic_event() {
  if (!_internal_has_clear_diagnostic_event()) {
    clear_MessageType();
    set_has_clear_diagnostic_event();
    _impl_.MessageType_.clear_diagnostic_event_ = CreateMaybeMessage< ::tickview_strategy::ClearDiagnosticEvent >(GetArenaForAllocation());
  }
  return _impl_.MessageType_.clear_diagnostic_event_;
}
inline ::tickview_strategy::ClearDiagnosticEvent* message::mutable_clear_diagnostic_event() {
  ::tickview_strategy::ClearDiagnosticEvent* _msg = _internal_mutable_clear_diagnostic_event();
  // @@protoc_insertion_point(field_mutable:tickview_strategy.message.clear_diagnostic_event)
  return _msg;
}

// .tickview_strategy.ClearOldRecord clear_record = 11;
inline bool message::_internal_has_clear_record() const {
  return MessageType_case() == kClearRecord;
}
inline bool message::has_clear_record() const {
  return _internal_has_clear_record();
}
inline void message::set_has_clear_record() {
  _impl_._oneof_case_[0] = kClearRecord;
}
inline void message::clear_clear_record() {
  if (_internal_has_clear_record()) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.MessageType_.clear_record_;
    }
    clear_has_MessageType();
  }
}
inline ::tickview_strategy::ClearOldRecord* message::release_clear_record() {
  // @@protoc_insertion_point(field_release:tickview_strategy.message.clear_record)
  if (_internal_has_clear_record()) {
    clear_has_MessageType();
    ::tickview_strategy::ClearOldRecord* temp = _impl_.MessageType_.clear_record_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.MessageType_.clear_record_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::tickview_strategy::ClearOldRecord& message::_internal_clear_record() const {
  return _internal_has_clear_record()
      ? *_impl_.MessageType_.clear_record_
      : reinterpret_cast< ::tickview_strategy::ClearOldRecord&>(::tickview_strategy::_ClearOldRecord_default_instance_);
}
inline const ::tickview_strategy::ClearOldRecord& message::clear_record() const {
  // @@protoc_insertion_point(field_get:tickview_strategy.message.clear_record)
  return _internal_clear_record();
}
inline ::tickview_strategy::ClearOldRecord* message::unsafe_arena_release_clear_record() {
  // @@protoc_insertion_point(field_unsafe_arena_release:tickview_strategy.message.clear_record)
  if (_internal_has_clear_record()) {
    clear_has_MessageType();
    ::tickview_strategy::ClearOldRecord* temp = _impl_.MessageType_.clear_record_;
    _impl_.MessageType_.clear_record_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void message::unsafe_arena_set_allocated_clear_record(::tickview_strategy::ClearOldRecord* clear_record) {
  clear_MessageType();
  if (clear_record) {
    set_has_clear_record();
    _impl_.MessageType_.clear_record_ = clear_record;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:tickview_strategy.message.clear_record)
}
inline ::tickview_strategy::ClearOldRecord* message::_internal_mutable_clear_record() {
  if (!_internal_has_clear_record()) {
    clear_MessageType();
    set_has_clear_record();
    _impl_.MessageType_.clear_record_ = CreateMaybeMessage< ::tickview_strategy::ClearOldRecord >(GetArenaForAllocation());
  }
  return _impl_.MessageType_.clear_record_;
}
inline ::tickview_strategy::ClearOldRecord* message::mutable_clear_record() {
  ::tickview_strategy::ClearOldRecord* _msg = _internal_mutable_clear_record();
  // @@protoc_insertion_point(field_mutable:tickview_strategy.message.clear_record)
  return _msg;
}

// .tickview_strategy.SyncInstrumentSet sync_instrument = 12;
inline bool message::_internal_has_sync_instrument() const {
  return MessageType_case() == kSyncInstrument;
}
inline bool message::has_sync_instrument() const {
  return _internal_has_sync_instrument();
}
inline void message::set_has_sync_instrument() {
  _impl_._oneof_case_[0] = kSyncInstrument;
}
inline void message::clear_sync_instrument() {
  if (_internal_has_sync_instrument()) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.MessageType_.sync_instrument_;
    }
    clear_has_MessageType();
  }
}
inline ::tickview_strategy::SyncInstrumentSet* message::release_sync_instrument() {
  // @@protoc_insertion_point(field_release:tickview_strategy.message.sync_instrument)
  if (_internal_has_sync_instrument()) {
    clear_has_MessageType();
    ::tickview_strategy::SyncInstrumentSet* temp = _impl_.MessageType_.sync_instrument_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.MessageType_.sync_instrument_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::tickview_strategy::SyncInstrumentSet& message::_internal_sync_instrument() const {
  return _internal_has_sync_instrument()
      ? *_impl_.MessageType_.sync_instrument_
      : reinterpret_cast< ::tickview_strategy::SyncInstrumentSet&>(::tickview_strategy::_SyncInstrumentSet_default_instance_);
}
inline const ::tickview_strategy::SyncInstrumentSet& message::sync_instrument() const {
  // @@protoc_insertion_point(field_get:tickview_strategy.message.sync_instrument)
  return _internal_sync_instrument();
}
inline ::tickview_strategy::SyncInstrumentSet* message::unsafe_arena_release_sync_instrument() {
  // @@protoc_insertion_point(field_unsafe_arena_release:tickview_strategy.message.sync_instrument)
  if (_internal_has_sync_instrument()) {
    clear_has_MessageType();
    ::tickview_strategy::SyncInstrumentSet* temp = _impl_.MessageType_.sync_instrument_;
    _impl_.MessageType_.sync_instrument_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void message::unsafe_arena_set_allocated_sync_instrument(::tickview_strategy::SyncInstrumentSet* sync_instrument) {
  clear_MessageType();
  if (sync_instrument) {
    set_has_sync_instrument();
    _impl_.MessageType_.sync_instrument_ = sync_instrument;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:tickview_strategy.message.sync_instrument)
}
inline ::tickview_strategy::SyncInstrumentSet* message::_internal_mutable_sync_instrument() {
  if (!_internal_has_sync_instrument()) {
    clear_MessageType();
    set_has_sync_instrument();
    _impl_.MessageType_.sync_instrument_ = CreateMaybeMessage< ::tickview_strategy::SyncInstrumentSet >(GetArenaForAllocation());
  }
  return _impl_.MessageType_.sync_instrument_;
}
inline ::tickview_strategy::SyncInstrumentSet* message::mutable_sync_instrument() {
  ::tickview_strategy::SyncInstrumentSet* _msg = _internal_mutable_sync_instrument();
  // @@protoc_insertion_point(field_mutable:tickview_strategy.message.sync_instrument)
  return _msg;
}

// .tickview_strategy.SyncTraderGroup sync_trader_group = 13;
inline bool message::_internal_has_sync_trader_group() const {
  return MessageType_case() == kSyncTraderGroup;
}
inline bool message::has_sync_trader_group() const {
  return _internal_has_sync_trader_group();
}
inline void message::set_has_sync_trader_group() {
  _impl_._oneof_case_[0] = kSyncTraderGroup;
}
inline void message::clear_sync_trader_group() {
  if (_internal_has_sync_trader_group()) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.MessageType_.sync_trader_group_;
    }
    clear_has_MessageType();
  }
}
inline ::tickview_strategy::SyncTraderGroup* message::release_sync_trader_group() {
  // @@protoc_insertion_point(field_release:tickview_strategy.message.sync_trader_group)
  if (_internal_has_sync_trader_group()) {
    clear_has_MessageType();
    ::tickview_strategy::SyncTraderGroup* temp = _impl_.MessageType_.sync_trader_group_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.MessageType_.sync_trader_group_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::tickview_strategy::SyncTraderGroup& message::_internal_sync_trader_group() const {
  return _internal_has_sync_trader_group()
      ? *_impl_.MessageType_.sync_trader_group_
      : reinterpret_cast< ::tickview_strategy::SyncTraderGroup&>(::tickview_strategy::_SyncTraderGroup_default_instance_);
}
inline const ::tickview_strategy::SyncTraderGroup& message::sync_trader_group() const {
  // @@protoc_insertion_point(field_get:tickview_strategy.message.sync_trader_group)
  return _internal_sync_trader_group();
}
inline ::tickview_strategy::SyncTraderGroup* message::unsafe_arena_release_sync_trader_group() {
  // @@protoc_insertion_point(field_unsafe_arena_release:tickview_strategy.message.sync_trader_group)
  if (_internal_has_sync_trader_group()) {
    clear_has_MessageType();
    ::tickview_strategy::SyncTraderGroup* temp = _impl_.MessageType_.sync_trader_group_;
    _impl_.MessageType_.sync_trader_group_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void message::unsafe_arena_set_allocated_sync_trader_group(::tickview_strategy::SyncTraderGroup* sync_trader_group) {
  clear_MessageType();
  if (sync_trader_group) {
    set_has_sync_trader_group();
    _impl_.MessageType_.sync_trader_group_ = sync_trader_group;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:tickview_strategy.message.sync_trader_group)
}
inline ::tickview_strategy::SyncTraderGroup* message::_internal_mutable_sync_trader_group() {
  if (!_internal_has_sync_trader_group()) {
    clear_MessageType();
    set_has_sync_trader_group();
    _impl_.MessageType_.sync_trader_group_ = CreateMaybeMessage< ::tickview_strategy::SyncTraderGroup >(GetArenaForAllocation());
  }
  return _impl_.MessageType_.sync_trader_group_;
}
inline ::tickview_strategy::SyncTraderGroup* message::mutable_sync_trader_group() {
  ::tickview_strategy::SyncTraderGroup* _msg = _internal_mutable_sync_trader_group();
  // @@protoc_insertion_point(field_mutable:tickview_strategy.message.sync_trader_group)
  return _msg;
}

// .tickview_strategy.HeavyAttack heavy_attack = 14;
inline bool message::_internal_has_heavy_attack() const {
  return MessageType_case() == kHeavyAttack;
}
inline bool message::has_heavy_attack() const {
  return _internal_has_heavy_attack();
}
inline void message::set_has_heavy_attack() {
  _impl_._oneof_case_[0] = kHeavyAttack;
}
inline void message::clear_heavy_attack() {
  if (_internal_has_heavy_attack()) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.MessageType_.heavy_attack_;
    }
    clear_has_MessageType();
  }
}
inline ::tickview_strategy::HeavyAttack* message::release_heavy_attack() {
  // @@protoc_insertion_point(field_release:tickview_strategy.message.heavy_attack)
  if (_internal_has_heavy_attack()) {
    clear_has_MessageType();
    ::tickview_strategy::HeavyAttack* temp = _impl_.MessageType_.heavy_attack_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.MessageType_.heavy_attack_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::tickview_strategy::HeavyAttack& message::_internal_heavy_attack() const {
  return _internal_has_heavy_attack()
      ? *_impl_.MessageType_.heavy_attack_
      : reinterpret_cast< ::tickview_strategy::HeavyAttack&>(::tickview_strategy::_HeavyAttack_default_instance_);
}
inline const ::tickview_strategy::HeavyAttack& message::heavy_attack() const {
  // @@protoc_insertion_point(field_get:tickview_strategy.message.heavy_attack)
  return _internal_heavy_attack();
}
inline ::tickview_strategy::HeavyAttack* message::unsafe_arena_release_heavy_attack() {
  // @@protoc_insertion_point(field_unsafe_arena_release:tickview_strategy.message.heavy_attack)
  if (_internal_has_heavy_attack()) {
    clear_has_MessageType();
    ::tickview_strategy::HeavyAttack* temp = _impl_.MessageType_.heavy_attack_;
    _impl_.MessageType_.heavy_attack_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void message::unsafe_arena_set_allocated_heavy_attack(::tickview_strategy::HeavyAttack* heavy_attack) {
  clear_MessageType();
  if (heavy_attack) {
    set_has_heavy_attack();
    _impl_.MessageType_.heavy_attack_ = heavy_attack;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:tickview_strategy.message.heavy_attack)
}
inline ::tickview_strategy::HeavyAttack* message::_internal_mutable_heavy_attack() {
  if (!_internal_has_heavy_attack()) {
    clear_MessageType();
    set_has_heavy_attack();
    _impl_.MessageType_.heavy_attack_ = CreateMaybeMessage< ::tickview_strategy::HeavyAttack >(GetArenaForAllocation());
  }
  return _impl_.MessageType_.heavy_attack_;
}
inline ::tickview_strategy::HeavyAttack* message::mutable_heavy_attack() {
  ::tickview_strategy::HeavyAttack* _msg = _internal_mutable_heavy_attack();
  // @@protoc_insertion_point(field_mutable:tickview_strategy.message.heavy_attack)
  return _msg;
}

// .tickview_strategy.FrontAdjust front_adjust = 15;
inline bool message::_internal_has_front_adjust() const {
  return MessageType_case() == kFrontAdjust;
}
inline bool message::has_front_adjust() const {
  return _internal_has_front_adjust();
}
inline void message::set_has_front_adjust() {
  _impl_._oneof_case_[0] = kFrontAdjust;
}
inline void message::clear_front_adjust() {
  if (_internal_has_front_adjust()) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.MessageType_.front_adjust_;
    }
    clear_has_MessageType();
  }
}
inline ::tickview_strategy::FrontAdjust* message::release_front_adjust() {
  // @@protoc_insertion_point(field_release:tickview_strategy.message.front_adjust)
  if (_internal_has_front_adjust()) {
    clear_has_MessageType();
    ::tickview_strategy::FrontAdjust* temp = _impl_.MessageType_.front_adjust_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.MessageType_.front_adjust_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::tickview_strategy::FrontAdjust& message::_internal_front_adjust() const {
  return _internal_has_front_adjust()
      ? *_impl_.MessageType_.front_adjust_
      : reinterpret_cast< ::tickview_strategy::FrontAdjust&>(::tickview_strategy::_FrontAdjust_default_instance_);
}
inline const ::tickview_strategy::FrontAdjust& message::front_adjust() const {
  // @@protoc_insertion_point(field_get:tickview_strategy.message.front_adjust)
  return _internal_front_adjust();
}
inline ::tickview_strategy::FrontAdjust* message::unsafe_arena_release_front_adjust() {
  // @@protoc_insertion_point(field_unsafe_arena_release:tickview_strategy.message.front_adjust)
  if (_internal_has_front_adjust()) {
    clear_has_MessageType();
    ::tickview_strategy::FrontAdjust* temp = _impl_.MessageType_.front_adjust_;
    _impl_.MessageType_.front_adjust_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void message::unsafe_arena_set_allocated_front_adjust(::tickview_strategy::FrontAdjust* front_adjust) {
  clear_MessageType();
  if (front_adjust) {
    set_has_front_adjust();
    _impl_.MessageType_.front_adjust_ = front_adjust;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:tickview_strategy.message.front_adjust)
}
inline ::tickview_strategy::FrontAdjust* message::_internal_mutable_front_adjust() {
  if (!_internal_has_front_adjust()) {
    clear_MessageType();
    set_has_front_adjust();
    _impl_.MessageType_.front_adjust_ = CreateMaybeMessage< ::tickview_strategy::FrontAdjust >(GetArenaForAllocation());
  }
  return _impl_.MessageType_.front_adjust_;
}
inline ::tickview_strategy::FrontAdjust* message::mutable_front_adjust() {
  ::tickview_strategy::FrontAdjust* _msg = _internal_mutable_front_adjust();
  // @@protoc_insertion_point(field_mutable:tickview_strategy.message.front_adjust)
  return _msg;
}

inline bool message::has_MessageType() const {
  return MessageType_case() != MESSAGETYPE_NOT_SET;
}
inline void message::clear_has_MessageType() {
  _impl_._oneof_case_[0] = MESSAGETYPE_NOT_SET;
}
inline message::MessageTypeCase message::MessageType_case() const {
  return message::MessageTypeCase(_impl_._oneof_case_[0]);
}
// -------------------------------------------------------------------

// Level1ControlReq

// string strategy_name = 1;
inline void Level1ControlReq::clear_strategy_name() {
  _impl_.strategy_name_.ClearToEmpty();
}
inline const std::string& Level1ControlReq::strategy_name() const {
  // @@protoc_insertion_point(field_get:tickview_strategy.Level1ControlReq.strategy_name)
  return _internal_strategy_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Level1ControlReq::set_strategy_name(ArgT0&& arg0, ArgT... args) {
 
 _impl_.strategy_name_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:tickview_strategy.Level1ControlReq.strategy_name)
}
inline std::string* Level1ControlReq::mutable_strategy_name() {
  std::string* _s = _internal_mutable_strategy_name();
  // @@protoc_insertion_point(field_mutable:tickview_strategy.Level1ControlReq.strategy_name)
  return _s;
}
inline const std::string& Level1ControlReq::_internal_strategy_name() const {
  return _impl_.strategy_name_.Get();
}
inline void Level1ControlReq::_internal_set_strategy_name(const std::string& value) {
  
  _impl_.strategy_name_.Set(value, GetArenaForAllocation());
}
inline std::string* Level1ControlReq::_internal_mutable_strategy_name() {
  
  return _impl_.strategy_name_.Mutable(GetArenaForAllocation());
}
inline std::string* Level1ControlReq::release_strategy_name() {
  // @@protoc_insertion_point(field_release:tickview_strategy.Level1ControlReq.strategy_name)
  return _impl_.strategy_name_.Release();
}
inline void Level1ControlReq::set_allocated_strategy_name(std::string* strategy_name) {
  if (strategy_name != nullptr) {
    
  } else {
    
  }
  _impl_.strategy_name_.SetAllocated(strategy_name, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.strategy_name_.IsDefault()) {
    _impl_.strategy_name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:tickview_strategy.Level1ControlReq.strategy_name)
}

// string strategy_exch = 2;
inline void Level1ControlReq::clear_strategy_exch() {
  _impl_.strategy_exch_.ClearToEmpty();
}
inline const std::string& Level1ControlReq::strategy_exch() const {
  // @@protoc_insertion_point(field_get:tickview_strategy.Level1ControlReq.strategy_exch)
  return _internal_strategy_exch();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Level1ControlReq::set_strategy_exch(ArgT0&& arg0, ArgT... args) {
 
 _impl_.strategy_exch_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:tickview_strategy.Level1ControlReq.strategy_exch)
}
inline std::string* Level1ControlReq::mutable_strategy_exch() {
  std::string* _s = _internal_mutable_strategy_exch();
  // @@protoc_insertion_point(field_mutable:tickview_strategy.Level1ControlReq.strategy_exch)
  return _s;
}
inline const std::string& Level1ControlReq::_internal_strategy_exch() const {
  return _impl_.strategy_exch_.Get();
}
inline void Level1ControlReq::_internal_set_strategy_exch(const std::string& value) {
  
  _impl_.strategy_exch_.Set(value, GetArenaForAllocation());
}
inline std::string* Level1ControlReq::_internal_mutable_strategy_exch() {
  
  return _impl_.strategy_exch_.Mutable(GetArenaForAllocation());
}
inline std::string* Level1ControlReq::release_strategy_exch() {
  // @@protoc_insertion_point(field_release:tickview_strategy.Level1ControlReq.strategy_exch)
  return _impl_.strategy_exch_.Release();
}
inline void Level1ControlReq::set_allocated_strategy_exch(std::string* strategy_exch) {
  if (strategy_exch != nullptr) {
    
  } else {
    
  }
  _impl_.strategy_exch_.SetAllocated(strategy_exch, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.strategy_exch_.IsDefault()) {
    _impl_.strategy_exch_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:tickview_strategy.Level1ControlReq.strategy_exch)
}

// string strategy_group = 3;
inline void Level1ControlReq::clear_strategy_group() {
  _impl_.strategy_group_.ClearToEmpty();
}
inline const std::string& Level1ControlReq::strategy_group() const {
  // @@protoc_insertion_point(field_get:tickview_strategy.Level1ControlReq.strategy_group)
  return _internal_strategy_group();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Level1ControlReq::set_strategy_group(ArgT0&& arg0, ArgT... args) {
 
 _impl_.strategy_group_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:tickview_strategy.Level1ControlReq.strategy_group)
}
inline std::string* Level1ControlReq::mutable_strategy_group() {
  std::string* _s = _internal_mutable_strategy_group();
  // @@protoc_insertion_point(field_mutable:tickview_strategy.Level1ControlReq.strategy_group)
  return _s;
}
inline const std::string& Level1ControlReq::_internal_strategy_group() const {
  return _impl_.strategy_group_.Get();
}
inline void Level1ControlReq::_internal_set_strategy_group(const std::string& value) {
  
  _impl_.strategy_group_.Set(value, GetArenaForAllocation());
}
inline std::string* Level1ControlReq::_internal_mutable_strategy_group() {
  
  return _impl_.strategy_group_.Mutable(GetArenaForAllocation());
}
inline std::string* Level1ControlReq::release_strategy_group() {
  // @@protoc_insertion_point(field_release:tickview_strategy.Level1ControlReq.strategy_group)
  return _impl_.strategy_group_.Release();
}
inline void Level1ControlReq::set_allocated_strategy_group(std::string* strategy_group) {
  if (strategy_group != nullptr) {
    
  } else {
    
  }
  _impl_.strategy_group_.SetAllocated(strategy_group, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.strategy_group_.IsDefault()) {
    _impl_.strategy_group_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:tickview_strategy.Level1ControlReq.strategy_group)
}

// string strategy_index = 4;
inline void Level1ControlReq::clear_strategy_index() {
  _impl_.strategy_index_.ClearToEmpty();
}
inline const std::string& Level1ControlReq::strategy_index() const {
  // @@protoc_insertion_point(field_get:tickview_strategy.Level1ControlReq.strategy_index)
  return _internal_strategy_index();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Level1ControlReq::set_strategy_index(ArgT0&& arg0, ArgT... args) {
 
 _impl_.strategy_index_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:tickview_strategy.Level1ControlReq.strategy_index)
}
inline std::string* Level1ControlReq::mutable_strategy_index() {
  std::string* _s = _internal_mutable_strategy_index();
  // @@protoc_insertion_point(field_mutable:tickview_strategy.Level1ControlReq.strategy_index)
  return _s;
}
inline const std::string& Level1ControlReq::_internal_strategy_index() const {
  return _impl_.strategy_index_.Get();
}
inline void Level1ControlReq::_internal_set_strategy_index(const std::string& value) {
  
  _impl_.strategy_index_.Set(value, GetArenaForAllocation());
}
inline std::string* Level1ControlReq::_internal_mutable_strategy_index() {
  
  return _impl_.strategy_index_.Mutable(GetArenaForAllocation());
}
inline std::string* Level1ControlReq::release_strategy_index() {
  // @@protoc_insertion_point(field_release:tickview_strategy.Level1ControlReq.strategy_index)
  return _impl_.strategy_index_.Release();
}
inline void Level1ControlReq::set_allocated_strategy_index(std::string* strategy_index) {
  if (strategy_index != nullptr) {
    
  } else {
    
  }
  _impl_.strategy_index_.SetAllocated(strategy_index, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.strategy_index_.IsDefault()) {
    _impl_.strategy_index_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:tickview_strategy.Level1ControlReq.strategy_index)
}

// .tickview_strategy.Level1ControlReq.Indication indication = 5;
inline void Level1ControlReq::clear_indication() {
  _impl_.indication_ = 0;
}
inline ::tickview_strategy::Level1ControlReq_Indication Level1ControlReq::_internal_indication() const {
  return static_cast< ::tickview_strategy::Level1ControlReq_Indication >(_impl_.indication_);
}
inline ::tickview_strategy::Level1ControlReq_Indication Level1ControlReq::indication() const {
  // @@protoc_insertion_point(field_get:tickview_strategy.Level1ControlReq.indication)
  return _internal_indication();
}
inline void Level1ControlReq::_internal_set_indication(::tickview_strategy::Level1ControlReq_Indication value) {
  
  _impl_.indication_ = value;
}
inline void Level1ControlReq::set_indication(::tickview_strategy::Level1ControlReq_Indication value) {
  _internal_set_indication(value);
  // @@protoc_insertion_point(field_set:tickview_strategy.Level1ControlReq.indication)
}

// -------------------------------------------------------------------

// OrderConditionMandatorySet

// string strategy_exch = 1;
inline void OrderConditionMandatorySet::clear_strategy_exch() {
  _impl_.strategy_exch_.ClearToEmpty();
}
inline const std::string& OrderConditionMandatorySet::strategy_exch() const {
  // @@protoc_insertion_point(field_get:tickview_strategy.OrderConditionMandatorySet.strategy_exch)
  return _internal_strategy_exch();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void OrderConditionMandatorySet::set_strategy_exch(ArgT0&& arg0, ArgT... args) {
 
 _impl_.strategy_exch_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:tickview_strategy.OrderConditionMandatorySet.strategy_exch)
}
inline std::string* OrderConditionMandatorySet::mutable_strategy_exch() {
  std::string* _s = _internal_mutable_strategy_exch();
  // @@protoc_insertion_point(field_mutable:tickview_strategy.OrderConditionMandatorySet.strategy_exch)
  return _s;
}
inline const std::string& OrderConditionMandatorySet::_internal_strategy_exch() const {
  return _impl_.strategy_exch_.Get();
}
inline void OrderConditionMandatorySet::_internal_set_strategy_exch(const std::string& value) {
  
  _impl_.strategy_exch_.Set(value, GetArenaForAllocation());
}
inline std::string* OrderConditionMandatorySet::_internal_mutable_strategy_exch() {
  
  return _impl_.strategy_exch_.Mutable(GetArenaForAllocation());
}
inline std::string* OrderConditionMandatorySet::release_strategy_exch() {
  // @@protoc_insertion_point(field_release:tickview_strategy.OrderConditionMandatorySet.strategy_exch)
  return _impl_.strategy_exch_.Release();
}
inline void OrderConditionMandatorySet::set_allocated_strategy_exch(std::string* strategy_exch) {
  if (strategy_exch != nullptr) {
    
  } else {
    
  }
  _impl_.strategy_exch_.SetAllocated(strategy_exch, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.strategy_exch_.IsDefault()) {
    _impl_.strategy_exch_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:tickview_strategy.OrderConditionMandatorySet.strategy_exch)
}

// string strategy_group = 2;
inline void OrderConditionMandatorySet::clear_strategy_group() {
  _impl_.strategy_group_.ClearToEmpty();
}
inline const std::string& OrderConditionMandatorySet::strategy_group() const {
  // @@protoc_insertion_point(field_get:tickview_strategy.OrderConditionMandatorySet.strategy_group)
  return _internal_strategy_group();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void OrderConditionMandatorySet::set_strategy_group(ArgT0&& arg0, ArgT... args) {
 
 _impl_.strategy_group_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:tickview_strategy.OrderConditionMandatorySet.strategy_group)
}
inline std::string* OrderConditionMandatorySet::mutable_strategy_group() {
  std::string* _s = _internal_mutable_strategy_group();
  // @@protoc_insertion_point(field_mutable:tickview_strategy.OrderConditionMandatorySet.strategy_group)
  return _s;
}
inline const std::string& OrderConditionMandatorySet::_internal_strategy_group() const {
  return _impl_.strategy_group_.Get();
}
inline void OrderConditionMandatorySet::_internal_set_strategy_group(const std::string& value) {
  
  _impl_.strategy_group_.Set(value, GetArenaForAllocation());
}
inline std::string* OrderConditionMandatorySet::_internal_mutable_strategy_group() {
  
  return _impl_.strategy_group_.Mutable(GetArenaForAllocation());
}
inline std::string* OrderConditionMandatorySet::release_strategy_group() {
  // @@protoc_insertion_point(field_release:tickview_strategy.OrderConditionMandatorySet.strategy_group)
  return _impl_.strategy_group_.Release();
}
inline void OrderConditionMandatorySet::set_allocated_strategy_group(std::string* strategy_group) {
  if (strategy_group != nullptr) {
    
  } else {
    
  }
  _impl_.strategy_group_.SetAllocated(strategy_group, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.strategy_group_.IsDefault()) {
    _impl_.strategy_group_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:tickview_strategy.OrderConditionMandatorySet.strategy_group)
}

// string strategy_ins = 3;
inline void OrderConditionMandatorySet::clear_strategy_ins() {
  _impl_.strategy_ins_.ClearToEmpty();
}
inline const std::string& OrderConditionMandatorySet::strategy_ins() const {
  // @@protoc_insertion_point(field_get:tickview_strategy.OrderConditionMandatorySet.strategy_ins)
  return _internal_strategy_ins();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void OrderConditionMandatorySet::set_strategy_ins(ArgT0&& arg0, ArgT... args) {
 
 _impl_.strategy_ins_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:tickview_strategy.OrderConditionMandatorySet.strategy_ins)
}
inline std::string* OrderConditionMandatorySet::mutable_strategy_ins() {
  std::string* _s = _internal_mutable_strategy_ins();
  // @@protoc_insertion_point(field_mutable:tickview_strategy.OrderConditionMandatorySet.strategy_ins)
  return _s;
}
inline const std::string& OrderConditionMandatorySet::_internal_strategy_ins() const {
  return _impl_.strategy_ins_.Get();
}
inline void OrderConditionMandatorySet::_internal_set_strategy_ins(const std::string& value) {
  
  _impl_.strategy_ins_.Set(value, GetArenaForAllocation());
}
inline std::string* OrderConditionMandatorySet::_internal_mutable_strategy_ins() {
  
  return _impl_.strategy_ins_.Mutable(GetArenaForAllocation());
}
inline std::string* OrderConditionMandatorySet::release_strategy_ins() {
  // @@protoc_insertion_point(field_release:tickview_strategy.OrderConditionMandatorySet.strategy_ins)
  return _impl_.strategy_ins_.Release();
}
inline void OrderConditionMandatorySet::set_allocated_strategy_ins(std::string* strategy_ins) {
  if (strategy_ins != nullptr) {
    
  } else {
    
  }
  _impl_.strategy_ins_.SetAllocated(strategy_ins, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.strategy_ins_.IsDefault()) {
    _impl_.strategy_ins_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:tickview_strategy.OrderConditionMandatorySet.strategy_ins)
}

// string strategy_index = 4;
inline void OrderConditionMandatorySet::clear_strategy_index() {
  _impl_.strategy_index_.ClearToEmpty();
}
inline const std::string& OrderConditionMandatorySet::strategy_index() const {
  // @@protoc_insertion_point(field_get:tickview_strategy.OrderConditionMandatorySet.strategy_index)
  return _internal_strategy_index();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void OrderConditionMandatorySet::set_strategy_index(ArgT0&& arg0, ArgT... args) {
 
 _impl_.strategy_index_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:tickview_strategy.OrderConditionMandatorySet.strategy_index)
}
inline std::string* OrderConditionMandatorySet::mutable_strategy_index() {
  std::string* _s = _internal_mutable_strategy_index();
  // @@protoc_insertion_point(field_mutable:tickview_strategy.OrderConditionMandatorySet.strategy_index)
  return _s;
}
inline const std::string& OrderConditionMandatorySet::_internal_strategy_index() const {
  return _impl_.strategy_index_.Get();
}
inline void OrderConditionMandatorySet::_internal_set_strategy_index(const std::string& value) {
  
  _impl_.strategy_index_.Set(value, GetArenaForAllocation());
}
inline std::string* OrderConditionMandatorySet::_internal_mutable_strategy_index() {
  
  return _impl_.strategy_index_.Mutable(GetArenaForAllocation());
}
inline std::string* OrderConditionMandatorySet::release_strategy_index() {
  // @@protoc_insertion_point(field_release:tickview_strategy.OrderConditionMandatorySet.strategy_index)
  return _impl_.strategy_index_.Release();
}
inline void OrderConditionMandatorySet::set_allocated_strategy_index(std::string* strategy_index) {
  if (strategy_index != nullptr) {
    
  } else {
    
  }
  _impl_.strategy_index_.SetAllocated(strategy_index, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.strategy_index_.IsDefault()) {
    _impl_.strategy_index_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:tickview_strategy.OrderConditionMandatorySet.strategy_index)
}

// .tickview_strategy.OrderConditionMandatorySet.OrderCondition condition = 5;
inline void OrderConditionMandatorySet::clear_condition() {
  _impl_.condition_ = 0;
}
inline ::tickview_strategy::OrderConditionMandatorySet_OrderCondition OrderConditionMandatorySet::_internal_condition() const {
  return static_cast< ::tickview_strategy::OrderConditionMandatorySet_OrderCondition >(_impl_.condition_);
}
inline ::tickview_strategy::OrderConditionMandatorySet_OrderCondition OrderConditionMandatorySet::condition() const {
  // @@protoc_insertion_point(field_get:tickview_strategy.OrderConditionMandatorySet.condition)
  return _internal_condition();
}
inline void OrderConditionMandatorySet::_internal_set_condition(::tickview_strategy::OrderConditionMandatorySet_OrderCondition value) {
  
  _impl_.condition_ = value;
}
inline void OrderConditionMandatorySet::set_condition(::tickview_strategy::OrderConditionMandatorySet_OrderCondition value) {
  _internal_set_condition(value);
  // @@protoc_insertion_point(field_set:tickview_strategy.OrderConditionMandatorySet.condition)
}

// -------------------------------------------------------------------

// BugInjection

// string strategy_exch = 1;
inline void BugInjection::clear_strategy_exch() {
  _impl_.strategy_exch_.ClearToEmpty();
}
inline const std::string& BugInjection::strategy_exch() const {
  // @@protoc_insertion_point(field_get:tickview_strategy.BugInjection.strategy_exch)
  return _internal_strategy_exch();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void BugInjection::set_strategy_exch(ArgT0&& arg0, ArgT... args) {
 
 _impl_.strategy_exch_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:tickview_strategy.BugInjection.strategy_exch)
}
inline std::string* BugInjection::mutable_strategy_exch() {
  std::string* _s = _internal_mutable_strategy_exch();
  // @@protoc_insertion_point(field_mutable:tickview_strategy.BugInjection.strategy_exch)
  return _s;
}
inline const std::string& BugInjection::_internal_strategy_exch() const {
  return _impl_.strategy_exch_.Get();
}
inline void BugInjection::_internal_set_strategy_exch(const std::string& value) {
  
  _impl_.strategy_exch_.Set(value, GetArenaForAllocation());
}
inline std::string* BugInjection::_internal_mutable_strategy_exch() {
  
  return _impl_.strategy_exch_.Mutable(GetArenaForAllocation());
}
inline std::string* BugInjection::release_strategy_exch() {
  // @@protoc_insertion_point(field_release:tickview_strategy.BugInjection.strategy_exch)
  return _impl_.strategy_exch_.Release();
}
inline void BugInjection::set_allocated_strategy_exch(std::string* strategy_exch) {
  if (strategy_exch != nullptr) {
    
  } else {
    
  }
  _impl_.strategy_exch_.SetAllocated(strategy_exch, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.strategy_exch_.IsDefault()) {
    _impl_.strategy_exch_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:tickview_strategy.BugInjection.strategy_exch)
}

// string strategy_group = 2;
inline void BugInjection::clear_strategy_group() {
  _impl_.strategy_group_.ClearToEmpty();
}
inline const std::string& BugInjection::strategy_group() const {
  // @@protoc_insertion_point(field_get:tickview_strategy.BugInjection.strategy_group)
  return _internal_strategy_group();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void BugInjection::set_strategy_group(ArgT0&& arg0, ArgT... args) {
 
 _impl_.strategy_group_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:tickview_strategy.BugInjection.strategy_group)
}
inline std::string* BugInjection::mutable_strategy_group() {
  std::string* _s = _internal_mutable_strategy_group();
  // @@protoc_insertion_point(field_mutable:tickview_strategy.BugInjection.strategy_group)
  return _s;
}
inline const std::string& BugInjection::_internal_strategy_group() const {
  return _impl_.strategy_group_.Get();
}
inline void BugInjection::_internal_set_strategy_group(const std::string& value) {
  
  _impl_.strategy_group_.Set(value, GetArenaForAllocation());
}
inline std::string* BugInjection::_internal_mutable_strategy_group() {
  
  return _impl_.strategy_group_.Mutable(GetArenaForAllocation());
}
inline std::string* BugInjection::release_strategy_group() {
  // @@protoc_insertion_point(field_release:tickview_strategy.BugInjection.strategy_group)
  return _impl_.strategy_group_.Release();
}
inline void BugInjection::set_allocated_strategy_group(std::string* strategy_group) {
  if (strategy_group != nullptr) {
    
  } else {
    
  }
  _impl_.strategy_group_.SetAllocated(strategy_group, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.strategy_group_.IsDefault()) {
    _impl_.strategy_group_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:tickview_strategy.BugInjection.strategy_group)
}

// string strategy_ins = 3;
inline void BugInjection::clear_strategy_ins() {
  _impl_.strategy_ins_.ClearToEmpty();
}
inline const std::string& BugInjection::strategy_ins() const {
  // @@protoc_insertion_point(field_get:tickview_strategy.BugInjection.strategy_ins)
  return _internal_strategy_ins();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void BugInjection::set_strategy_ins(ArgT0&& arg0, ArgT... args) {
 
 _impl_.strategy_ins_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:tickview_strategy.BugInjection.strategy_ins)
}
inline std::string* BugInjection::mutable_strategy_ins() {
  std::string* _s = _internal_mutable_strategy_ins();
  // @@protoc_insertion_point(field_mutable:tickview_strategy.BugInjection.strategy_ins)
  return _s;
}
inline const std::string& BugInjection::_internal_strategy_ins() const {
  return _impl_.strategy_ins_.Get();
}
inline void BugInjection::_internal_set_strategy_ins(const std::string& value) {
  
  _impl_.strategy_ins_.Set(value, GetArenaForAllocation());
}
inline std::string* BugInjection::_internal_mutable_strategy_ins() {
  
  return _impl_.strategy_ins_.Mutable(GetArenaForAllocation());
}
inline std::string* BugInjection::release_strategy_ins() {
  // @@protoc_insertion_point(field_release:tickview_strategy.BugInjection.strategy_ins)
  return _impl_.strategy_ins_.Release();
}
inline void BugInjection::set_allocated_strategy_ins(std::string* strategy_ins) {
  if (strategy_ins != nullptr) {
    
  } else {
    
  }
  _impl_.strategy_ins_.SetAllocated(strategy_ins, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.strategy_ins_.IsDefault()) {
    _impl_.strategy_ins_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:tickview_strategy.BugInjection.strategy_ins)
}

// .tickview_strategy.BugInjection.InjectionType type = 4;
inline void BugInjection::clear_type() {
  _impl_.type_ = 0;
}
inline ::tickview_strategy::BugInjection_InjectionType BugInjection::_internal_type() const {
  return static_cast< ::tickview_strategy::BugInjection_InjectionType >(_impl_.type_);
}
inline ::tickview_strategy::BugInjection_InjectionType BugInjection::type() const {
  // @@protoc_insertion_point(field_get:tickview_strategy.BugInjection.type)
  return _internal_type();
}
inline void BugInjection::_internal_set_type(::tickview_strategy::BugInjection_InjectionType value) {
  
  _impl_.type_ = value;
}
inline void BugInjection::set_type(::tickview_strategy::BugInjection_InjectionType value) {
  _internal_set_type(value);
  // @@protoc_insertion_point(field_set:tickview_strategy.BugInjection.type)
}

// .tickview_strategy.BugInjection.Indication indication = 5;
inline void BugInjection::clear_indication() {
  _impl_.indication_ = 0;
}
inline ::tickview_strategy::BugInjection_Indication BugInjection::_internal_indication() const {
  return static_cast< ::tickview_strategy::BugInjection_Indication >(_impl_.indication_);
}
inline ::tickview_strategy::BugInjection_Indication BugInjection::indication() const {
  // @@protoc_insertion_point(field_get:tickview_strategy.BugInjection.indication)
  return _internal_indication();
}
inline void BugInjection::_internal_set_indication(::tickview_strategy::BugInjection_Indication value) {
  
  _impl_.indication_ = value;
}
inline void BugInjection::set_indication(::tickview_strategy::BugInjection_Indication value) {
  _internal_set_indication(value);
  // @@protoc_insertion_point(field_set:tickview_strategy.BugInjection.indication)
}

// -------------------------------------------------------------------

// BatchControlReq

// .tickview_strategy.BatchControlReq.Indication indication = 1;
inline void BatchControlReq::clear_indication() {
  _impl_.indication_ = 0;
}
inline ::tickview_strategy::BatchControlReq_Indication BatchControlReq::_internal_indication() const {
  return static_cast< ::tickview_strategy::BatchControlReq_Indication >(_impl_.indication_);
}
inline ::tickview_strategy::BatchControlReq_Indication BatchControlReq::indication() const {
  // @@protoc_insertion_point(field_get:tickview_strategy.BatchControlReq.indication)
  return _internal_indication();
}
inline void BatchControlReq::_internal_set_indication(::tickview_strategy::BatchControlReq_Indication value) {
  
  _impl_.indication_ = value;
}
inline void BatchControlReq::set_indication(::tickview_strategy::BatchControlReq_Indication value) {
  _internal_set_indication(value);
  // @@protoc_insertion_point(field_set:tickview_strategy.BatchControlReq.indication)
}

// -------------------------------------------------------------------

// ProfilerControl

// .tickview_strategy.ProfilerControl.ProfilerAction profiler_action = 1;
inline void ProfilerControl::clear_profiler_action() {
  _impl_.profiler_action_ = 0;
}
inline ::tickview_strategy::ProfilerControl_ProfilerAction ProfilerControl::_internal_profiler_action() const {
  return static_cast< ::tickview_strategy::ProfilerControl_ProfilerAction >(_impl_.profiler_action_);
}
inline ::tickview_strategy::ProfilerControl_ProfilerAction ProfilerControl::profiler_action() const {
  // @@protoc_insertion_point(field_get:tickview_strategy.ProfilerControl.profiler_action)
  return _internal_profiler_action();
}
inline void ProfilerControl::_internal_set_profiler_action(::tickview_strategy::ProfilerControl_ProfilerAction value) {
  
  _impl_.profiler_action_ = value;
}
inline void ProfilerControl::set_profiler_action(::tickview_strategy::ProfilerControl_ProfilerAction value) {
  _internal_set_profiler_action(value);
  // @@protoc_insertion_point(field_set:tickview_strategy.ProfilerControl.profiler_action)
}

// -------------------------------------------------------------------

// UpdateProjectPara

// .tickview_strategy.UpdateProjectPara.UpdateAction update_action = 1;
inline void UpdateProjectPara::clear_update_action() {
  _impl_.update_action_ = 0;
}
inline ::tickview_strategy::UpdateProjectPara_UpdateAction UpdateProjectPara::_internal_update_action() const {
  return static_cast< ::tickview_strategy::UpdateProjectPara_UpdateAction >(_impl_.update_action_);
}
inline ::tickview_strategy::UpdateProjectPara_UpdateAction UpdateProjectPara::update_action() const {
  // @@protoc_insertion_point(field_get:tickview_strategy.UpdateProjectPara.update_action)
  return _internal_update_action();
}
inline void UpdateProjectPara::_internal_set_update_action(::tickview_strategy::UpdateProjectPara_UpdateAction value) {
  
  _impl_.update_action_ = value;
}
inline void UpdateProjectPara::set_update_action(::tickview_strategy::UpdateProjectPara_UpdateAction value) {
  _internal_set_update_action(value);
  // @@protoc_insertion_point(field_set:tickview_strategy.UpdateProjectPara.update_action)
}

// -------------------------------------------------------------------

// UpdateStrategyPara

// string strategy_exch = 1;
inline void UpdateStrategyPara::clear_strategy_exch() {
  _impl_.strategy_exch_.ClearToEmpty();
}
inline const std::string& UpdateStrategyPara::strategy_exch() const {
  // @@protoc_insertion_point(field_get:tickview_strategy.UpdateStrategyPara.strategy_exch)
  return _internal_strategy_exch();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void UpdateStrategyPara::set_strategy_exch(ArgT0&& arg0, ArgT... args) {
 
 _impl_.strategy_exch_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:tickview_strategy.UpdateStrategyPara.strategy_exch)
}
inline std::string* UpdateStrategyPara::mutable_strategy_exch() {
  std::string* _s = _internal_mutable_strategy_exch();
  // @@protoc_insertion_point(field_mutable:tickview_strategy.UpdateStrategyPara.strategy_exch)
  return _s;
}
inline const std::string& UpdateStrategyPara::_internal_strategy_exch() const {
  return _impl_.strategy_exch_.Get();
}
inline void UpdateStrategyPara::_internal_set_strategy_exch(const std::string& value) {
  
  _impl_.strategy_exch_.Set(value, GetArenaForAllocation());
}
inline std::string* UpdateStrategyPara::_internal_mutable_strategy_exch() {
  
  return _impl_.strategy_exch_.Mutable(GetArenaForAllocation());
}
inline std::string* UpdateStrategyPara::release_strategy_exch() {
  // @@protoc_insertion_point(field_release:tickview_strategy.UpdateStrategyPara.strategy_exch)
  return _impl_.strategy_exch_.Release();
}
inline void UpdateStrategyPara::set_allocated_strategy_exch(std::string* strategy_exch) {
  if (strategy_exch != nullptr) {
    
  } else {
    
  }
  _impl_.strategy_exch_.SetAllocated(strategy_exch, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.strategy_exch_.IsDefault()) {
    _impl_.strategy_exch_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:tickview_strategy.UpdateStrategyPara.strategy_exch)
}

// string strategy_group = 2;
inline void UpdateStrategyPara::clear_strategy_group() {
  _impl_.strategy_group_.ClearToEmpty();
}
inline const std::string& UpdateStrategyPara::strategy_group() const {
  // @@protoc_insertion_point(field_get:tickview_strategy.UpdateStrategyPara.strategy_group)
  return _internal_strategy_group();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void UpdateStrategyPara::set_strategy_group(ArgT0&& arg0, ArgT... args) {
 
 _impl_.strategy_group_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:tickview_strategy.UpdateStrategyPara.strategy_group)
}
inline std::string* UpdateStrategyPara::mutable_strategy_group() {
  std::string* _s = _internal_mutable_strategy_group();
  // @@protoc_insertion_point(field_mutable:tickview_strategy.UpdateStrategyPara.strategy_group)
  return _s;
}
inline const std::string& UpdateStrategyPara::_internal_strategy_group() const {
  return _impl_.strategy_group_.Get();
}
inline void UpdateStrategyPara::_internal_set_strategy_group(const std::string& value) {
  
  _impl_.strategy_group_.Set(value, GetArenaForAllocation());
}
inline std::string* UpdateStrategyPara::_internal_mutable_strategy_group() {
  
  return _impl_.strategy_group_.Mutable(GetArenaForAllocation());
}
inline std::string* UpdateStrategyPara::release_strategy_group() {
  // @@protoc_insertion_point(field_release:tickview_strategy.UpdateStrategyPara.strategy_group)
  return _impl_.strategy_group_.Release();
}
inline void UpdateStrategyPara::set_allocated_strategy_group(std::string* strategy_group) {
  if (strategy_group != nullptr) {
    
  } else {
    
  }
  _impl_.strategy_group_.SetAllocated(strategy_group, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.strategy_group_.IsDefault()) {
    _impl_.strategy_group_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:tickview_strategy.UpdateStrategyPara.strategy_group)
}

// string strategy_index = 3;
inline void UpdateStrategyPara::clear_strategy_index() {
  _impl_.strategy_index_.ClearToEmpty();
}
inline const std::string& UpdateStrategyPara::strategy_index() const {
  // @@protoc_insertion_point(field_get:tickview_strategy.UpdateStrategyPara.strategy_index)
  return _internal_strategy_index();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void UpdateStrategyPara::set_strategy_index(ArgT0&& arg0, ArgT... args) {
 
 _impl_.strategy_index_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:tickview_strategy.UpdateStrategyPara.strategy_index)
}
inline std::string* UpdateStrategyPara::mutable_strategy_index() {
  std::string* _s = _internal_mutable_strategy_index();
  // @@protoc_insertion_point(field_mutable:tickview_strategy.UpdateStrategyPara.strategy_index)
  return _s;
}
inline const std::string& UpdateStrategyPara::_internal_strategy_index() const {
  return _impl_.strategy_index_.Get();
}
inline void UpdateStrategyPara::_internal_set_strategy_index(const std::string& value) {
  
  _impl_.strategy_index_.Set(value, GetArenaForAllocation());
}
inline std::string* UpdateStrategyPara::_internal_mutable_strategy_index() {
  
  return _impl_.strategy_index_.Mutable(GetArenaForAllocation());
}
inline std::string* UpdateStrategyPara::release_strategy_index() {
  // @@protoc_insertion_point(field_release:tickview_strategy.UpdateStrategyPara.strategy_index)
  return _impl_.strategy_index_.Release();
}
inline void UpdateStrategyPara::set_allocated_strategy_index(std::string* strategy_index) {
  if (strategy_index != nullptr) {
    
  } else {
    
  }
  _impl_.strategy_index_.SetAllocated(strategy_index, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.strategy_index_.IsDefault()) {
    _impl_.strategy_index_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:tickview_strategy.UpdateStrategyPara.strategy_index)
}

// .tickview_strategy.UpdateStrategyPara.UpdateAction update_action = 4;
inline void UpdateStrategyPara::clear_update_action() {
  _impl_.update_action_ = 0;
}
inline ::tickview_strategy::UpdateStrategyPara_UpdateAction UpdateStrategyPara::_internal_update_action() const {
  return static_cast< ::tickview_strategy::UpdateStrategyPara_UpdateAction >(_impl_.update_action_);
}
inline ::tickview_strategy::UpdateStrategyPara_UpdateAction UpdateStrategyPara::update_action() const {
  // @@protoc_insertion_point(field_get:tickview_strategy.UpdateStrategyPara.update_action)
  return _internal_update_action();
}
inline void UpdateStrategyPara::_internal_set_update_action(::tickview_strategy::UpdateStrategyPara_UpdateAction value) {
  
  _impl_.update_action_ = value;
}
inline void UpdateStrategyPara::set_update_action(::tickview_strategy::UpdateStrategyPara_UpdateAction value) {
  _internal_set_update_action(value);
  // @@protoc_insertion_point(field_set:tickview_strategy.UpdateStrategyPara.update_action)
}

// -------------------------------------------------------------------

// CloseAll

// .tickview_strategy.CloseAll.CloseAction close_action = 1;
inline void CloseAll::clear_close_action() {
  _impl_.close_action_ = 0;
}
inline ::tickview_strategy::CloseAll_CloseAction CloseAll::_internal_close_action() const {
  return static_cast< ::tickview_strategy::CloseAll_CloseAction >(_impl_.close_action_);
}
inline ::tickview_strategy::CloseAll_CloseAction CloseAll::close_action() const {
  // @@protoc_insertion_point(field_get:tickview_strategy.CloseAll.close_action)
  return _internal_close_action();
}
inline void CloseAll::_internal_set_close_action(::tickview_strategy::CloseAll_CloseAction value) {
  
  _impl_.close_action_ = value;
}
inline void CloseAll::set_close_action(::tickview_strategy::CloseAll_CloseAction value) {
  _internal_set_close_action(value);
  // @@protoc_insertion_point(field_set:tickview_strategy.CloseAll.close_action)
}

// -------------------------------------------------------------------

// UnexpectedMinVolume

// string strategy_exch = 1;
inline void UnexpectedMinVolume::clear_strategy_exch() {
  _impl_.strategy_exch_.ClearToEmpty();
}
inline const std::string& UnexpectedMinVolume::strategy_exch() const {
  // @@protoc_insertion_point(field_get:tickview_strategy.UnexpectedMinVolume.strategy_exch)
  return _internal_strategy_exch();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void UnexpectedMinVolume::set_strategy_exch(ArgT0&& arg0, ArgT... args) {
 
 _impl_.strategy_exch_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:tickview_strategy.UnexpectedMinVolume.strategy_exch)
}
inline std::string* UnexpectedMinVolume::mutable_strategy_exch() {
  std::string* _s = _internal_mutable_strategy_exch();
  // @@protoc_insertion_point(field_mutable:tickview_strategy.UnexpectedMinVolume.strategy_exch)
  return _s;
}
inline const std::string& UnexpectedMinVolume::_internal_strategy_exch() const {
  return _impl_.strategy_exch_.Get();
}
inline void UnexpectedMinVolume::_internal_set_strategy_exch(const std::string& value) {
  
  _impl_.strategy_exch_.Set(value, GetArenaForAllocation());
}
inline std::string* UnexpectedMinVolume::_internal_mutable_strategy_exch() {
  
  return _impl_.strategy_exch_.Mutable(GetArenaForAllocation());
}
inline std::string* UnexpectedMinVolume::release_strategy_exch() {
  // @@protoc_insertion_point(field_release:tickview_strategy.UnexpectedMinVolume.strategy_exch)
  return _impl_.strategy_exch_.Release();
}
inline void UnexpectedMinVolume::set_allocated_strategy_exch(std::string* strategy_exch) {
  if (strategy_exch != nullptr) {
    
  } else {
    
  }
  _impl_.strategy_exch_.SetAllocated(strategy_exch, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.strategy_exch_.IsDefault()) {
    _impl_.strategy_exch_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:tickview_strategy.UnexpectedMinVolume.strategy_exch)
}

// string strategy_group = 2;
inline void UnexpectedMinVolume::clear_strategy_group() {
  _impl_.strategy_group_.ClearToEmpty();
}
inline const std::string& UnexpectedMinVolume::strategy_group() const {
  // @@protoc_insertion_point(field_get:tickview_strategy.UnexpectedMinVolume.strategy_group)
  return _internal_strategy_group();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void UnexpectedMinVolume::set_strategy_group(ArgT0&& arg0, ArgT... args) {
 
 _impl_.strategy_group_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:tickview_strategy.UnexpectedMinVolume.strategy_group)
}
inline std::string* UnexpectedMinVolume::mutable_strategy_group() {
  std::string* _s = _internal_mutable_strategy_group();
  // @@protoc_insertion_point(field_mutable:tickview_strategy.UnexpectedMinVolume.strategy_group)
  return _s;
}
inline const std::string& UnexpectedMinVolume::_internal_strategy_group() const {
  return _impl_.strategy_group_.Get();
}
inline void UnexpectedMinVolume::_internal_set_strategy_group(const std::string& value) {
  
  _impl_.strategy_group_.Set(value, GetArenaForAllocation());
}
inline std::string* UnexpectedMinVolume::_internal_mutable_strategy_group() {
  
  return _impl_.strategy_group_.Mutable(GetArenaForAllocation());
}
inline std::string* UnexpectedMinVolume::release_strategy_group() {
  // @@protoc_insertion_point(field_release:tickview_strategy.UnexpectedMinVolume.strategy_group)
  return _impl_.strategy_group_.Release();
}
inline void UnexpectedMinVolume::set_allocated_strategy_group(std::string* strategy_group) {
  if (strategy_group != nullptr) {
    
  } else {
    
  }
  _impl_.strategy_group_.SetAllocated(strategy_group, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.strategy_group_.IsDefault()) {
    _impl_.strategy_group_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:tickview_strategy.UnexpectedMinVolume.strategy_group)
}

// string strategy_ins = 3;
inline void UnexpectedMinVolume::clear_strategy_ins() {
  _impl_.strategy_ins_.ClearToEmpty();
}
inline const std::string& UnexpectedMinVolume::strategy_ins() const {
  // @@protoc_insertion_point(field_get:tickview_strategy.UnexpectedMinVolume.strategy_ins)
  return _internal_strategy_ins();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void UnexpectedMinVolume::set_strategy_ins(ArgT0&& arg0, ArgT... args) {
 
 _impl_.strategy_ins_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:tickview_strategy.UnexpectedMinVolume.strategy_ins)
}
inline std::string* UnexpectedMinVolume::mutable_strategy_ins() {
  std::string* _s = _internal_mutable_strategy_ins();
  // @@protoc_insertion_point(field_mutable:tickview_strategy.UnexpectedMinVolume.strategy_ins)
  return _s;
}
inline const std::string& UnexpectedMinVolume::_internal_strategy_ins() const {
  return _impl_.strategy_ins_.Get();
}
inline void UnexpectedMinVolume::_internal_set_strategy_ins(const std::string& value) {
  
  _impl_.strategy_ins_.Set(value, GetArenaForAllocation());
}
inline std::string* UnexpectedMinVolume::_internal_mutable_strategy_ins() {
  
  return _impl_.strategy_ins_.Mutable(GetArenaForAllocation());
}
inline std::string* UnexpectedMinVolume::release_strategy_ins() {
  // @@protoc_insertion_point(field_release:tickview_strategy.UnexpectedMinVolume.strategy_ins)
  return _impl_.strategy_ins_.Release();
}
inline void UnexpectedMinVolume::set_allocated_strategy_ins(std::string* strategy_ins) {
  if (strategy_ins != nullptr) {
    
  } else {
    
  }
  _impl_.strategy_ins_.SetAllocated(strategy_ins, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.strategy_ins_.IsDefault()) {
    _impl_.strategy_ins_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:tickview_strategy.UnexpectedMinVolume.strategy_ins)
}

// uint32 min_market_volume = 4;
inline void UnexpectedMinVolume::clear_min_market_volume() {
  _impl_.min_market_volume_ = 0u;
}
inline uint32_t UnexpectedMinVolume::_internal_min_market_volume() const {
  return _impl_.min_market_volume_;
}
inline uint32_t UnexpectedMinVolume::min_market_volume() const {
  // @@protoc_insertion_point(field_get:tickview_strategy.UnexpectedMinVolume.min_market_volume)
  return _internal_min_market_volume();
}
inline void UnexpectedMinVolume::_internal_set_min_market_volume(uint32_t value) {
  
  _impl_.min_market_volume_ = value;
}
inline void UnexpectedMinVolume::set_min_market_volume(uint32_t value) {
  _internal_set_min_market_volume(value);
  // @@protoc_insertion_point(field_set:tickview_strategy.UnexpectedMinVolume.min_market_volume)
}

// uint32 min_limit_volume = 5;
inline void UnexpectedMinVolume::clear_min_limit_volume() {
  _impl_.min_limit_volume_ = 0u;
}
inline uint32_t UnexpectedMinVolume::_internal_min_limit_volume() const {
  return _impl_.min_limit_volume_;
}
inline uint32_t UnexpectedMinVolume::min_limit_volume() const {
  // @@protoc_insertion_point(field_get:tickview_strategy.UnexpectedMinVolume.min_limit_volume)
  return _internal_min_limit_volume();
}
inline void UnexpectedMinVolume::_internal_set_min_limit_volume(uint32_t value) {
  
  _impl_.min_limit_volume_ = value;
}
inline void UnexpectedMinVolume::set_min_limit_volume(uint32_t value) {
  _internal_set_min_limit_volume(value);
  // @@protoc_insertion_point(field_set:tickview_strategy.UnexpectedMinVolume.min_limit_volume)
}

// -------------------------------------------------------------------

// ClearDiagnosticEvent

// uint32 diagnostic_event_id = 1;
inline void ClearDiagnosticEvent::clear_diagnostic_event_id() {
  _impl_.diagnostic_event_id_ = 0u;
}
inline uint32_t ClearDiagnosticEvent::_internal_diagnostic_event_id() const {
  return _impl_.diagnostic_event_id_;
}
inline uint32_t ClearDiagnosticEvent::diagnostic_event_id() const {
  // @@protoc_insertion_point(field_get:tickview_strategy.ClearDiagnosticEvent.diagnostic_event_id)
  return _internal_diagnostic_event_id();
}
inline void ClearDiagnosticEvent::_internal_set_diagnostic_event_id(uint32_t value) {
  
  _impl_.diagnostic_event_id_ = value;
}
inline void ClearDiagnosticEvent::set_diagnostic_event_id(uint32_t value) {
  _internal_set_diagnostic_event_id(value);
  // @@protoc_insertion_point(field_set:tickview_strategy.ClearDiagnosticEvent.diagnostic_event_id)
}

// -------------------------------------------------------------------

// ClearOldRecord

// .tickview_strategy.ClearOldRecord.ClearAction clear_action = 1;
inline void ClearOldRecord::clear_clear_action() {
  _impl_.clear_action_ = 0;
}
inline ::tickview_strategy::ClearOldRecord_ClearAction ClearOldRecord::_internal_clear_action() const {
  return static_cast< ::tickview_strategy::ClearOldRecord_ClearAction >(_impl_.clear_action_);
}
inline ::tickview_strategy::ClearOldRecord_ClearAction ClearOldRecord::clear_action() const {
  // @@protoc_insertion_point(field_get:tickview_strategy.ClearOldRecord.clear_action)
  return _internal_clear_action();
}
inline void ClearOldRecord::_internal_set_clear_action(::tickview_strategy::ClearOldRecord_ClearAction value) {
  
  _impl_.clear_action_ = value;
}
inline void ClearOldRecord::set_clear_action(::tickview_strategy::ClearOldRecord_ClearAction value) {
  _internal_set_clear_action(value);
  // @@protoc_insertion_point(field_set:tickview_strategy.ClearOldRecord.clear_action)
}

// -------------------------------------------------------------------

// SyncInstrumentSet

// .tickview_strategy.SyncInstrumentSet.SyncAction sync_action = 1;
inline void SyncInstrumentSet::clear_sync_action() {
  _impl_.sync_action_ = 0;
}
inline ::tickview_strategy::SyncInstrumentSet_SyncAction SyncInstrumentSet::_internal_sync_action() const {
  return static_cast< ::tickview_strategy::SyncInstrumentSet_SyncAction >(_impl_.sync_action_);
}
inline ::tickview_strategy::SyncInstrumentSet_SyncAction SyncInstrumentSet::sync_action() const {
  // @@protoc_insertion_point(field_get:tickview_strategy.SyncInstrumentSet.sync_action)
  return _internal_sync_action();
}
inline void SyncInstrumentSet::_internal_set_sync_action(::tickview_strategy::SyncInstrumentSet_SyncAction value) {
  
  _impl_.sync_action_ = value;
}
inline void SyncInstrumentSet::set_sync_action(::tickview_strategy::SyncInstrumentSet_SyncAction value) {
  _internal_set_sync_action(value);
  // @@protoc_insertion_point(field_set:tickview_strategy.SyncInstrumentSet.sync_action)
}

// -------------------------------------------------------------------

// SyncTraderGroup

// .tickview_strategy.SyncTraderGroup.SyncAction sync_action = 1;
inline void SyncTraderGroup::clear_sync_action() {
  _impl_.sync_action_ = 0;
}
inline ::tickview_strategy::SyncTraderGroup_SyncAction SyncTraderGroup::_internal_sync_action() const {
  return static_cast< ::tickview_strategy::SyncTraderGroup_SyncAction >(_impl_.sync_action_);
}
inline ::tickview_strategy::SyncTraderGroup_SyncAction SyncTraderGroup::sync_action() const {
  // @@protoc_insertion_point(field_get:tickview_strategy.SyncTraderGroup.sync_action)
  return _internal_sync_action();
}
inline void SyncTraderGroup::_internal_set_sync_action(::tickview_strategy::SyncTraderGroup_SyncAction value) {
  
  _impl_.sync_action_ = value;
}
inline void SyncTraderGroup::set_sync_action(::tickview_strategy::SyncTraderGroup_SyncAction value) {
  _internal_set_sync_action(value);
  // @@protoc_insertion_point(field_set:tickview_strategy.SyncTraderGroup.sync_action)
}

// -------------------------------------------------------------------

// HeavyAttack

// string strategy_exch = 1;
inline void HeavyAttack::clear_strategy_exch() {
  _impl_.strategy_exch_.ClearToEmpty();
}
inline const std::string& HeavyAttack::strategy_exch() const {
  // @@protoc_insertion_point(field_get:tickview_strategy.HeavyAttack.strategy_exch)
  return _internal_strategy_exch();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void HeavyAttack::set_strategy_exch(ArgT0&& arg0, ArgT... args) {
 
 _impl_.strategy_exch_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:tickview_strategy.HeavyAttack.strategy_exch)
}
inline std::string* HeavyAttack::mutable_strategy_exch() {
  std::string* _s = _internal_mutable_strategy_exch();
  // @@protoc_insertion_point(field_mutable:tickview_strategy.HeavyAttack.strategy_exch)
  return _s;
}
inline const std::string& HeavyAttack::_internal_strategy_exch() const {
  return _impl_.strategy_exch_.Get();
}
inline void HeavyAttack::_internal_set_strategy_exch(const std::string& value) {
  
  _impl_.strategy_exch_.Set(value, GetArenaForAllocation());
}
inline std::string* HeavyAttack::_internal_mutable_strategy_exch() {
  
  return _impl_.strategy_exch_.Mutable(GetArenaForAllocation());
}
inline std::string* HeavyAttack::release_strategy_exch() {
  // @@protoc_insertion_point(field_release:tickview_strategy.HeavyAttack.strategy_exch)
  return _impl_.strategy_exch_.Release();
}
inline void HeavyAttack::set_allocated_strategy_exch(std::string* strategy_exch) {
  if (strategy_exch != nullptr) {
    
  } else {
    
  }
  _impl_.strategy_exch_.SetAllocated(strategy_exch, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.strategy_exch_.IsDefault()) {
    _impl_.strategy_exch_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:tickview_strategy.HeavyAttack.strategy_exch)
}

// string strategy_group = 2;
inline void HeavyAttack::clear_strategy_group() {
  _impl_.strategy_group_.ClearToEmpty();
}
inline const std::string& HeavyAttack::strategy_group() const {
  // @@protoc_insertion_point(field_get:tickview_strategy.HeavyAttack.strategy_group)
  return _internal_strategy_group();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void HeavyAttack::set_strategy_group(ArgT0&& arg0, ArgT... args) {
 
 _impl_.strategy_group_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:tickview_strategy.HeavyAttack.strategy_group)
}
inline std::string* HeavyAttack::mutable_strategy_group() {
  std::string* _s = _internal_mutable_strategy_group();
  // @@protoc_insertion_point(field_mutable:tickview_strategy.HeavyAttack.strategy_group)
  return _s;
}
inline const std::string& HeavyAttack::_internal_strategy_group() const {
  return _impl_.strategy_group_.Get();
}
inline void HeavyAttack::_internal_set_strategy_group(const std::string& value) {
  
  _impl_.strategy_group_.Set(value, GetArenaForAllocation());
}
inline std::string* HeavyAttack::_internal_mutable_strategy_group() {
  
  return _impl_.strategy_group_.Mutable(GetArenaForAllocation());
}
inline std::string* HeavyAttack::release_strategy_group() {
  // @@protoc_insertion_point(field_release:tickview_strategy.HeavyAttack.strategy_group)
  return _impl_.strategy_group_.Release();
}
inline void HeavyAttack::set_allocated_strategy_group(std::string* strategy_group) {
  if (strategy_group != nullptr) {
    
  } else {
    
  }
  _impl_.strategy_group_.SetAllocated(strategy_group, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.strategy_group_.IsDefault()) {
    _impl_.strategy_group_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:tickview_strategy.HeavyAttack.strategy_group)
}

// string strategy_ins = 3;
inline void HeavyAttack::clear_strategy_ins() {
  _impl_.strategy_ins_.ClearToEmpty();
}
inline const std::string& HeavyAttack::strategy_ins() const {
  // @@protoc_insertion_point(field_get:tickview_strategy.HeavyAttack.strategy_ins)
  return _internal_strategy_ins();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void HeavyAttack::set_strategy_ins(ArgT0&& arg0, ArgT... args) {
 
 _impl_.strategy_ins_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:tickview_strategy.HeavyAttack.strategy_ins)
}
inline std::string* HeavyAttack::mutable_strategy_ins() {
  std::string* _s = _internal_mutable_strategy_ins();
  // @@protoc_insertion_point(field_mutable:tickview_strategy.HeavyAttack.strategy_ins)
  return _s;
}
inline const std::string& HeavyAttack::_internal_strategy_ins() const {
  return _impl_.strategy_ins_.Get();
}
inline void HeavyAttack::_internal_set_strategy_ins(const std::string& value) {
  
  _impl_.strategy_ins_.Set(value, GetArenaForAllocation());
}
inline std::string* HeavyAttack::_internal_mutable_strategy_ins() {
  
  return _impl_.strategy_ins_.Mutable(GetArenaForAllocation());
}
inline std::string* HeavyAttack::release_strategy_ins() {
  // @@protoc_insertion_point(field_release:tickview_strategy.HeavyAttack.strategy_ins)
  return _impl_.strategy_ins_.Release();
}
inline void HeavyAttack::set_allocated_strategy_ins(std::string* strategy_ins) {
  if (strategy_ins != nullptr) {
    
  } else {
    
  }
  _impl_.strategy_ins_.SetAllocated(strategy_ins, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.strategy_ins_.IsDefault()) {
    _impl_.strategy_ins_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:tickview_strategy.HeavyAttack.strategy_ins)
}

// string strategy_index = 4;
inline void HeavyAttack::clear_strategy_index() {
  _impl_.strategy_index_.ClearToEmpty();
}
inline const std::string& HeavyAttack::strategy_index() const {
  // @@protoc_insertion_point(field_get:tickview_strategy.HeavyAttack.strategy_index)
  return _internal_strategy_index();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void HeavyAttack::set_strategy_index(ArgT0&& arg0, ArgT... args) {
 
 _impl_.strategy_index_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:tickview_strategy.HeavyAttack.strategy_index)
}
inline std::string* HeavyAttack::mutable_strategy_index() {
  std::string* _s = _internal_mutable_strategy_index();
  // @@protoc_insertion_point(field_mutable:tickview_strategy.HeavyAttack.strategy_index)
  return _s;
}
inline const std::string& HeavyAttack::_internal_strategy_index() const {
  return _impl_.strategy_index_.Get();
}
inline void HeavyAttack::_internal_set_strategy_index(const std::string& value) {
  
  _impl_.strategy_index_.Set(value, GetArenaForAllocation());
}
inline std::string* HeavyAttack::_internal_mutable_strategy_index() {
  
  return _impl_.strategy_index_.Mutable(GetArenaForAllocation());
}
inline std::string* HeavyAttack::release_strategy_index() {
  // @@protoc_insertion_point(field_release:tickview_strategy.HeavyAttack.strategy_index)
  return _impl_.strategy_index_.Release();
}
inline void HeavyAttack::set_allocated_strategy_index(std::string* strategy_index) {
  if (strategy_index != nullptr) {
    
  } else {
    
  }
  _impl_.strategy_index_.SetAllocated(strategy_index, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.strategy_index_.IsDefault()) {
    _impl_.strategy_index_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:tickview_strategy.HeavyAttack.strategy_index)
}

// uint32 attack_number = 5;
inline void HeavyAttack::clear_attack_number() {
  _impl_.attack_number_ = 0u;
}
inline uint32_t HeavyAttack::_internal_attack_number() const {
  return _impl_.attack_number_;
}
inline uint32_t HeavyAttack::attack_number() const {
  // @@protoc_insertion_point(field_get:tickview_strategy.HeavyAttack.attack_number)
  return _internal_attack_number();
}
inline void HeavyAttack::_internal_set_attack_number(uint32_t value) {
  
  _impl_.attack_number_ = value;
}
inline void HeavyAttack::set_attack_number(uint32_t value) {
  _internal_set_attack_number(value);
  // @@protoc_insertion_point(field_set:tickview_strategy.HeavyAttack.attack_number)
}

// double attack_amplitude = 6;
inline void HeavyAttack::clear_attack_amplitude() {
  _impl_.attack_amplitude_ = 0;
}
inline double HeavyAttack::_internal_attack_amplitude() const {
  return _impl_.attack_amplitude_;
}
inline double HeavyAttack::attack_amplitude() const {
  // @@protoc_insertion_point(field_get:tickview_strategy.HeavyAttack.attack_amplitude)
  return _internal_attack_amplitude();
}
inline void HeavyAttack::_internal_set_attack_amplitude(double value) {
  
  _impl_.attack_amplitude_ = value;
}
inline void HeavyAttack::set_attack_amplitude(double value) {
  _internal_set_attack_amplitude(value);
  // @@protoc_insertion_point(field_set:tickview_strategy.HeavyAttack.attack_amplitude)
}

// -------------------------------------------------------------------

// FrontAdjust

// string strategy_exch = 1;
inline void FrontAdjust::clear_strategy_exch() {
  _impl_.strategy_exch_.ClearToEmpty();
}
inline const std::string& FrontAdjust::strategy_exch() const {
  // @@protoc_insertion_point(field_get:tickview_strategy.FrontAdjust.strategy_exch)
  return _internal_strategy_exch();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void FrontAdjust::set_strategy_exch(ArgT0&& arg0, ArgT... args) {
 
 _impl_.strategy_exch_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:tickview_strategy.FrontAdjust.strategy_exch)
}
inline std::string* FrontAdjust::mutable_strategy_exch() {
  std::string* _s = _internal_mutable_strategy_exch();
  // @@protoc_insertion_point(field_mutable:tickview_strategy.FrontAdjust.strategy_exch)
  return _s;
}
inline const std::string& FrontAdjust::_internal_strategy_exch() const {
  return _impl_.strategy_exch_.Get();
}
inline void FrontAdjust::_internal_set_strategy_exch(const std::string& value) {
  
  _impl_.strategy_exch_.Set(value, GetArenaForAllocation());
}
inline std::string* FrontAdjust::_internal_mutable_strategy_exch() {
  
  return _impl_.strategy_exch_.Mutable(GetArenaForAllocation());
}
inline std::string* FrontAdjust::release_strategy_exch() {
  // @@protoc_insertion_point(field_release:tickview_strategy.FrontAdjust.strategy_exch)
  return _impl_.strategy_exch_.Release();
}
inline void FrontAdjust::set_allocated_strategy_exch(std::string* strategy_exch) {
  if (strategy_exch != nullptr) {
    
  } else {
    
  }
  _impl_.strategy_exch_.SetAllocated(strategy_exch, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.strategy_exch_.IsDefault()) {
    _impl_.strategy_exch_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:tickview_strategy.FrontAdjust.strategy_exch)
}

// string strategy_group = 2;
inline void FrontAdjust::clear_strategy_group() {
  _impl_.strategy_group_.ClearToEmpty();
}
inline const std::string& FrontAdjust::strategy_group() const {
  // @@protoc_insertion_point(field_get:tickview_strategy.FrontAdjust.strategy_group)
  return _internal_strategy_group();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void FrontAdjust::set_strategy_group(ArgT0&& arg0, ArgT... args) {
 
 _impl_.strategy_group_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:tickview_strategy.FrontAdjust.strategy_group)
}
inline std::string* FrontAdjust::mutable_strategy_group() {
  std::string* _s = _internal_mutable_strategy_group();
  // @@protoc_insertion_point(field_mutable:tickview_strategy.FrontAdjust.strategy_group)
  return _s;
}
inline const std::string& FrontAdjust::_internal_strategy_group() const {
  return _impl_.strategy_group_.Get();
}
inline void FrontAdjust::_internal_set_strategy_group(const std::string& value) {
  
  _impl_.strategy_group_.Set(value, GetArenaForAllocation());
}
inline std::string* FrontAdjust::_internal_mutable_strategy_group() {
  
  return _impl_.strategy_group_.Mutable(GetArenaForAllocation());
}
inline std::string* FrontAdjust::release_strategy_group() {
  // @@protoc_insertion_point(field_release:tickview_strategy.FrontAdjust.strategy_group)
  return _impl_.strategy_group_.Release();
}
inline void FrontAdjust::set_allocated_strategy_group(std::string* strategy_group) {
  if (strategy_group != nullptr) {
    
  } else {
    
  }
  _impl_.strategy_group_.SetAllocated(strategy_group, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.strategy_group_.IsDefault()) {
    _impl_.strategy_group_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:tickview_strategy.FrontAdjust.strategy_group)
}

// string strategy_ins = 3;
inline void FrontAdjust::clear_strategy_ins() {
  _impl_.strategy_ins_.ClearToEmpty();
}
inline const std::string& FrontAdjust::strategy_ins() const {
  // @@protoc_insertion_point(field_get:tickview_strategy.FrontAdjust.strategy_ins)
  return _internal_strategy_ins();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void FrontAdjust::set_strategy_ins(ArgT0&& arg0, ArgT... args) {
 
 _impl_.strategy_ins_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:tickview_strategy.FrontAdjust.strategy_ins)
}
inline std::string* FrontAdjust::mutable_strategy_ins() {
  std::string* _s = _internal_mutable_strategy_ins();
  // @@protoc_insertion_point(field_mutable:tickview_strategy.FrontAdjust.strategy_ins)
  return _s;
}
inline const std::string& FrontAdjust::_internal_strategy_ins() const {
  return _impl_.strategy_ins_.Get();
}
inline void FrontAdjust::_internal_set_strategy_ins(const std::string& value) {
  
  _impl_.strategy_ins_.Set(value, GetArenaForAllocation());
}
inline std::string* FrontAdjust::_internal_mutable_strategy_ins() {
  
  return _impl_.strategy_ins_.Mutable(GetArenaForAllocation());
}
inline std::string* FrontAdjust::release_strategy_ins() {
  // @@protoc_insertion_point(field_release:tickview_strategy.FrontAdjust.strategy_ins)
  return _impl_.strategy_ins_.Release();
}
inline void FrontAdjust::set_allocated_strategy_ins(std::string* strategy_ins) {
  if (strategy_ins != nullptr) {
    
  } else {
    
  }
  _impl_.strategy_ins_.SetAllocated(strategy_ins, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.strategy_ins_.IsDefault()) {
    _impl_.strategy_ins_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:tickview_strategy.FrontAdjust.strategy_ins)
}

// uint32 old_shares = 4;
inline void FrontAdjust::clear_old_shares() {
  _impl_.old_shares_ = 0u;
}
inline uint32_t FrontAdjust::_internal_old_shares() const {
  return _impl_.old_shares_;
}
inline uint32_t FrontAdjust::old_shares() const {
  // @@protoc_insertion_point(field_get:tickview_strategy.FrontAdjust.old_shares)
  return _internal_old_shares();
}
inline void FrontAdjust::_internal_set_old_shares(uint32_t value) {
  
  _impl_.old_shares_ = value;
}
inline void FrontAdjust::set_old_shares(uint32_t value) {
  _internal_set_old_shares(value);
  // @@protoc_insertion_point(field_set:tickview_strategy.FrontAdjust.old_shares)
}

// uint32 new_shares = 5;
inline void FrontAdjust::clear_new_shares() {
  _impl_.new_shares_ = 0u;
}
inline uint32_t FrontAdjust::_internal_new_shares() const {
  return _impl_.new_shares_;
}
inline uint32_t FrontAdjust::new_shares() const {
  // @@protoc_insertion_point(field_get:tickview_strategy.FrontAdjust.new_shares)
  return _internal_new_shares();
}
inline void FrontAdjust::_internal_set_new_shares(uint32_t value) {
  
  _impl_.new_shares_ = value;
}
inline void FrontAdjust::set_new_shares(uint32_t value) {
  _internal_set_new_shares(value);
  // @@protoc_insertion_point(field_set:tickview_strategy.FrontAdjust.new_shares)
}

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace tickview_strategy

PROTOBUF_NAMESPACE_OPEN

template <> struct is_proto_enum< ::tickview_strategy::Level1ControlReq_Indication> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::tickview_strategy::Level1ControlReq_Indication>() {
  return ::tickview_strategy::Level1ControlReq_Indication_descriptor();
}
template <> struct is_proto_enum< ::tickview_strategy::OrderConditionMandatorySet_OrderCondition> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::tickview_strategy::OrderConditionMandatorySet_OrderCondition>() {
  return ::tickview_strategy::OrderConditionMandatorySet_OrderCondition_descriptor();
}
template <> struct is_proto_enum< ::tickview_strategy::BugInjection_InjectionType> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::tickview_strategy::BugInjection_InjectionType>() {
  return ::tickview_strategy::BugInjection_InjectionType_descriptor();
}
template <> struct is_proto_enum< ::tickview_strategy::BugInjection_Indication> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::tickview_strategy::BugInjection_Indication>() {
  return ::tickview_strategy::BugInjection_Indication_descriptor();
}
template <> struct is_proto_enum< ::tickview_strategy::BatchControlReq_Indication> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::tickview_strategy::BatchControlReq_Indication>() {
  return ::tickview_strategy::BatchControlReq_Indication_descriptor();
}
template <> struct is_proto_enum< ::tickview_strategy::ProfilerControl_ProfilerAction> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::tickview_strategy::ProfilerControl_ProfilerAction>() {
  return ::tickview_strategy::ProfilerControl_ProfilerAction_descriptor();
}
template <> struct is_proto_enum< ::tickview_strategy::UpdateProjectPara_UpdateAction> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::tickview_strategy::UpdateProjectPara_UpdateAction>() {
  return ::tickview_strategy::UpdateProjectPara_UpdateAction_descriptor();
}
template <> struct is_proto_enum< ::tickview_strategy::UpdateStrategyPara_UpdateAction> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::tickview_strategy::UpdateStrategyPara_UpdateAction>() {
  return ::tickview_strategy::UpdateStrategyPara_UpdateAction_descriptor();
}
template <> struct is_proto_enum< ::tickview_strategy::CloseAll_CloseAction> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::tickview_strategy::CloseAll_CloseAction>() {
  return ::tickview_strategy::CloseAll_CloseAction_descriptor();
}
template <> struct is_proto_enum< ::tickview_strategy::ClearOldRecord_ClearAction> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::tickview_strategy::ClearOldRecord_ClearAction>() {
  return ::tickview_strategy::ClearOldRecord_ClearAction_descriptor();
}
template <> struct is_proto_enum< ::tickview_strategy::SyncInstrumentSet_SyncAction> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::tickview_strategy::SyncInstrumentSet_SyncAction>() {
  return ::tickview_strategy::SyncInstrumentSet_SyncAction_descriptor();
}
template <> struct is_proto_enum< ::tickview_strategy::SyncTraderGroup_SyncAction> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::tickview_strategy::SyncTraderGroup_SyncAction>() {
  return ::tickview_strategy::SyncTraderGroup_SyncAction_descriptor();
}

PROTOBUF_NAMESPACE_CLOSE

// @@protoc_insertion_point(global_scope)

#include <google/protobuf/port_undef.inc>
#endif  // GOOGLE_PROTOBUF_INCLUDED_GOOGLE_PROTOBUF_INCLUDED_tickview_2dstrategy_2eproto
