// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: ipc.proto

#ifndef GOOGLE_PROTOBUF_INCLUDED_ipc_2eproto
#define GOOGLE_PROTOBUF_INCLUDED_ipc_2eproto

#include <limits>
#include <string>

#include <google/protobuf/port_def.inc>
#if PROTOBUF_VERSION < 3021000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers. Please update
#error your headers.
#endif
#if 3021005 < PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers. Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/port_undef.inc>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/metadata_lite.h>
#include <google/protobuf/generated_message_reflection.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/generated_enum_reflection.h>
#include <google/protobuf/unknown_field_set.h>
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>
#define PROTOBUF_INTERNAL_EXPORT_ipc_2eproto
PROTOBUF_NAMESPACE_OPEN
namespace internal {
class AnyMetadata;
}  // namespace internal
PROTOBUF_NAMESPACE_CLOSE

// Internal implementation detail -- do not use these members.
struct TableStruct_ipc_2eproto {
  static const uint32_t offsets[];
};
extern const ::PROTOBUF_NAMESPACE_ID::internal::DescriptorTable descriptor_table_ipc_2eproto;
namespace ipc {
class AccountStatusReq;
struct AccountStatusReqDefaultTypeInternal;
extern AccountStatusReqDefaultTypeInternal _AccountStatusReq_default_instance_;
class ItpMsg;
struct ItpMsgDefaultTypeInternal;
extern ItpMsgDefaultTypeInternal _ItpMsg_default_instance_;
class OrderIndex;
struct OrderIndexDefaultTypeInternal;
extern OrderIndexDefaultTypeInternal _OrderIndex_default_instance_;
class SendEmail;
struct SendEmailDefaultTypeInternal;
extern SendEmailDefaultTypeInternal _SendEmail_default_instance_;
class UpdateCapital;
struct UpdateCapitalDefaultTypeInternal;
extern UpdateCapitalDefaultTypeInternal _UpdateCapital_default_instance_;
class message;
struct messageDefaultTypeInternal;
extern messageDefaultTypeInternal _message_default_instance_;
}  // namespace ipc
PROTOBUF_NAMESPACE_OPEN
template<> ::ipc::AccountStatusReq* Arena::CreateMaybeMessage<::ipc::AccountStatusReq>(Arena*);
template<> ::ipc::ItpMsg* Arena::CreateMaybeMessage<::ipc::ItpMsg>(Arena*);
template<> ::ipc::OrderIndex* Arena::CreateMaybeMessage<::ipc::OrderIndex>(Arena*);
template<> ::ipc::SendEmail* Arena::CreateMaybeMessage<::ipc::SendEmail>(Arena*);
template<> ::ipc::UpdateCapital* Arena::CreateMaybeMessage<::ipc::UpdateCapital>(Arena*);
template<> ::ipc::message* Arena::CreateMaybeMessage<::ipc::message>(Arena*);
PROTOBUF_NAMESPACE_CLOSE
namespace ipc {

enum AccountStatusReq_Indication : int {
  AccountStatusReq_Indication_reserve = 0,
  AccountStatusReq_Indication_start = 1,
  AccountStatusReq_Indication_stop = 2,
  AccountStatusReq_Indication_AccountStatusReq_Indication_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  AccountStatusReq_Indication_AccountStatusReq_Indication_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
bool AccountStatusReq_Indication_IsValid(int value);
constexpr AccountStatusReq_Indication AccountStatusReq_Indication_Indication_MIN = AccountStatusReq_Indication_reserve;
constexpr AccountStatusReq_Indication AccountStatusReq_Indication_Indication_MAX = AccountStatusReq_Indication_stop;
constexpr int AccountStatusReq_Indication_Indication_ARRAYSIZE = AccountStatusReq_Indication_Indication_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* AccountStatusReq_Indication_descriptor();
template<typename T>
inline const std::string& AccountStatusReq_Indication_Name(T enum_t_value) {
  static_assert(::std::is_same<T, AccountStatusReq_Indication>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function AccountStatusReq_Indication_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    AccountStatusReq_Indication_descriptor(), enum_t_value);
}
inline bool AccountStatusReq_Indication_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, AccountStatusReq_Indication* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<AccountStatusReq_Indication>(
    AccountStatusReq_Indication_descriptor(), name, value);
}
// ===================================================================

class message final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:ipc.message) */ {
 public:
  inline message() : message(nullptr) {}
  ~message() override;
  explicit PROTOBUF_CONSTEXPR message(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  message(const message& from);
  message(message&& from) noexcept
    : message() {
    *this = ::std::move(from);
  }

  inline message& operator=(const message& from) {
    CopyFrom(from);
    return *this;
  }
  inline message& operator=(message&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const message& default_instance() {
    return *internal_default_instance();
  }
  enum MessageTypeCase {
    kItpMsg = 1,
    kOrderIndex = 2,
    kAccountStatusReq = 3,
    kSendEmail = 4,
    kUpdateCapital = 5,
    MESSAGETYPE_NOT_SET = 0,
  };

  static inline const message* internal_default_instance() {
    return reinterpret_cast<const message*>(
               &_message_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  friend void swap(message& a, message& b) {
    a.Swap(&b);
  }
  inline void Swap(message* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(message* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  message* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<message>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const message& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const message& from) {
    message::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(message* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "ipc.message";
  }
  protected:
  explicit message(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kItpMsgFieldNumber = 1,
    kOrderIndexFieldNumber = 2,
    kAccountStatusReqFieldNumber = 3,
    kSendEmailFieldNumber = 4,
    kUpdateCapitalFieldNumber = 5,
  };
  // .ipc.ItpMsg itp_msg = 1;
  bool has_itp_msg() const;
  private:
  bool _internal_has_itp_msg() const;
  public:
  void clear_itp_msg();
  const ::ipc::ItpMsg& itp_msg() const;
  PROTOBUF_NODISCARD ::ipc::ItpMsg* release_itp_msg();
  ::ipc::ItpMsg* mutable_itp_msg();
  void set_allocated_itp_msg(::ipc::ItpMsg* itp_msg);
  private:
  const ::ipc::ItpMsg& _internal_itp_msg() const;
  ::ipc::ItpMsg* _internal_mutable_itp_msg();
  public:
  void unsafe_arena_set_allocated_itp_msg(
      ::ipc::ItpMsg* itp_msg);
  ::ipc::ItpMsg* unsafe_arena_release_itp_msg();

  // .ipc.OrderIndex order_index = 2;
  bool has_order_index() const;
  private:
  bool _internal_has_order_index() const;
  public:
  void clear_order_index();
  const ::ipc::OrderIndex& order_index() const;
  PROTOBUF_NODISCARD ::ipc::OrderIndex* release_order_index();
  ::ipc::OrderIndex* mutable_order_index();
  void set_allocated_order_index(::ipc::OrderIndex* order_index);
  private:
  const ::ipc::OrderIndex& _internal_order_index() const;
  ::ipc::OrderIndex* _internal_mutable_order_index();
  public:
  void unsafe_arena_set_allocated_order_index(
      ::ipc::OrderIndex* order_index);
  ::ipc::OrderIndex* unsafe_arena_release_order_index();

  // .ipc.AccountStatusReq account_status_req = 3;
  bool has_account_status_req() const;
  private:
  bool _internal_has_account_status_req() const;
  public:
  void clear_account_status_req();
  const ::ipc::AccountStatusReq& account_status_req() const;
  PROTOBUF_NODISCARD ::ipc::AccountStatusReq* release_account_status_req();
  ::ipc::AccountStatusReq* mutable_account_status_req();
  void set_allocated_account_status_req(::ipc::AccountStatusReq* account_status_req);
  private:
  const ::ipc::AccountStatusReq& _internal_account_status_req() const;
  ::ipc::AccountStatusReq* _internal_mutable_account_status_req();
  public:
  void unsafe_arena_set_allocated_account_status_req(
      ::ipc::AccountStatusReq* account_status_req);
  ::ipc::AccountStatusReq* unsafe_arena_release_account_status_req();

  // .ipc.SendEmail send_email = 4;
  bool has_send_email() const;
  private:
  bool _internal_has_send_email() const;
  public:
  void clear_send_email();
  const ::ipc::SendEmail& send_email() const;
  PROTOBUF_NODISCARD ::ipc::SendEmail* release_send_email();
  ::ipc::SendEmail* mutable_send_email();
  void set_allocated_send_email(::ipc::SendEmail* send_email);
  private:
  const ::ipc::SendEmail& _internal_send_email() const;
  ::ipc::SendEmail* _internal_mutable_send_email();
  public:
  void unsafe_arena_set_allocated_send_email(
      ::ipc::SendEmail* send_email);
  ::ipc::SendEmail* unsafe_arena_release_send_email();

  // .ipc.UpdateCapital update_capital = 5;
  bool has_update_capital() const;
  private:
  bool _internal_has_update_capital() const;
  public:
  void clear_update_capital();
  const ::ipc::UpdateCapital& update_capital() const;
  PROTOBUF_NODISCARD ::ipc::UpdateCapital* release_update_capital();
  ::ipc::UpdateCapital* mutable_update_capital();
  void set_allocated_update_capital(::ipc::UpdateCapital* update_capital);
  private:
  const ::ipc::UpdateCapital& _internal_update_capital() const;
  ::ipc::UpdateCapital* _internal_mutable_update_capital();
  public:
  void unsafe_arena_set_allocated_update_capital(
      ::ipc::UpdateCapital* update_capital);
  ::ipc::UpdateCapital* unsafe_arena_release_update_capital();

  void clear_MessageType();
  MessageTypeCase MessageType_case() const;
  // @@protoc_insertion_point(class_scope:ipc.message)
 private:
  class _Internal;
  void set_has_itp_msg();
  void set_has_order_index();
  void set_has_account_status_req();
  void set_has_send_email();
  void set_has_update_capital();

  inline bool has_MessageType() const;
  inline void clear_has_MessageType();

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    union MessageTypeUnion {
      constexpr MessageTypeUnion() : _constinit_{} {}
        ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized _constinit_;
      ::ipc::ItpMsg* itp_msg_;
      ::ipc::OrderIndex* order_index_;
      ::ipc::AccountStatusReq* account_status_req_;
      ::ipc::SendEmail* send_email_;
      ::ipc::UpdateCapital* update_capital_;
    } MessageType_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    uint32_t _oneof_case_[1];

  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_ipc_2eproto;
};
// -------------------------------------------------------------------

class ItpMsg final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:ipc.ItpMsg) */ {
 public:
  inline ItpMsg() : ItpMsg(nullptr) {}
  ~ItpMsg() override;
  explicit PROTOBUF_CONSTEXPR ItpMsg(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ItpMsg(const ItpMsg& from);
  ItpMsg(ItpMsg&& from) noexcept
    : ItpMsg() {
    *this = ::std::move(from);
  }

  inline ItpMsg& operator=(const ItpMsg& from) {
    CopyFrom(from);
    return *this;
  }
  inline ItpMsg& operator=(ItpMsg&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ItpMsg& default_instance() {
    return *internal_default_instance();
  }
  static inline const ItpMsg* internal_default_instance() {
    return reinterpret_cast<const ItpMsg*>(
               &_ItpMsg_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  friend void swap(ItpMsg& a, ItpMsg& b) {
    a.Swap(&b);
  }
  inline void Swap(ItpMsg* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ItpMsg* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ItpMsg* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ItpMsg>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ItpMsg& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const ItpMsg& from) {
    ItpMsg::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ItpMsg* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "ipc.ItpMsg";
  }
  protected:
  explicit ItpMsg(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kUserIdFieldNumber = 3,
    kAddressFieldNumber = 1,
    kRspInfoFieldNumber = 2,
    kSessionIdFieldNumber = 4,
    kIsLastFieldNumber = 5,
  };
  // string user_id = 3;
  void clear_user_id();
  const std::string& user_id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_user_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_user_id();
  PROTOBUF_NODISCARD std::string* release_user_id();
  void set_allocated_user_id(std::string* user_id);
  private:
  const std::string& _internal_user_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_user_id(const std::string& value);
  std::string* _internal_mutable_user_id();
  public:

  // int64 address = 1;
  void clear_address();
  int64_t address() const;
  void set_address(int64_t value);
  private:
  int64_t _internal_address() const;
  void _internal_set_address(int64_t value);
  public:

  // int64 rsp_info = 2;
  void clear_rsp_info();
  int64_t rsp_info() const;
  void set_rsp_info(int64_t value);
  private:
  int64_t _internal_rsp_info() const;
  void _internal_set_rsp_info(int64_t value);
  public:

  // uint64 session_id = 4;
  void clear_session_id();
  uint64_t session_id() const;
  void set_session_id(uint64_t value);
  private:
  uint64_t _internal_session_id() const;
  void _internal_set_session_id(uint64_t value);
  public:

  // bool is_last = 5;
  void clear_is_last();
  bool is_last() const;
  void set_is_last(bool value);
  private:
  bool _internal_is_last() const;
  void _internal_set_is_last(bool value);
  public:

  // @@protoc_insertion_point(class_scope:ipc.ItpMsg)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr user_id_;
    int64_t address_;
    int64_t rsp_info_;
    uint64_t session_id_;
    bool is_last_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_ipc_2eproto;
};
// -------------------------------------------------------------------

class OrderIndex final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:ipc.OrderIndex) */ {
 public:
  inline OrderIndex() : OrderIndex(nullptr) {}
  ~OrderIndex() override;
  explicit PROTOBUF_CONSTEXPR OrderIndex(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  OrderIndex(const OrderIndex& from);
  OrderIndex(OrderIndex&& from) noexcept
    : OrderIndex() {
    *this = ::std::move(from);
  }

  inline OrderIndex& operator=(const OrderIndex& from) {
    CopyFrom(from);
    return *this;
  }
  inline OrderIndex& operator=(OrderIndex&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const OrderIndex& default_instance() {
    return *internal_default_instance();
  }
  static inline const OrderIndex* internal_default_instance() {
    return reinterpret_cast<const OrderIndex*>(
               &_OrderIndex_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  friend void swap(OrderIndex& a, OrderIndex& b) {
    a.Swap(&b);
  }
  inline void Swap(OrderIndex* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(OrderIndex* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  OrderIndex* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<OrderIndex>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const OrderIndex& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const OrderIndex& from) {
    OrderIndex::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(OrderIndex* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "ipc.OrderIndex";
  }
  protected:
  explicit OrderIndex(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kInsFieldNumber = 1,
    kIndexFieldNumber = 2,
  };
  // string ins = 1;
  void clear_ins();
  const std::string& ins() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_ins(ArgT0&& arg0, ArgT... args);
  std::string* mutable_ins();
  PROTOBUF_NODISCARD std::string* release_ins();
  void set_allocated_ins(std::string* ins);
  private:
  const std::string& _internal_ins() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_ins(const std::string& value);
  std::string* _internal_mutable_ins();
  public:

  // string index = 2;
  void clear_index();
  const std::string& index() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_index(ArgT0&& arg0, ArgT... args);
  std::string* mutable_index();
  PROTOBUF_NODISCARD std::string* release_index();
  void set_allocated_index(std::string* index);
  private:
  const std::string& _internal_index() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_index(const std::string& value);
  std::string* _internal_mutable_index();
  public:

  // @@protoc_insertion_point(class_scope:ipc.OrderIndex)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr ins_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr index_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_ipc_2eproto;
};
// -------------------------------------------------------------------

class AccountStatusReq final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:ipc.AccountStatusReq) */ {
 public:
  inline AccountStatusReq() : AccountStatusReq(nullptr) {}
  ~AccountStatusReq() override;
  explicit PROTOBUF_CONSTEXPR AccountStatusReq(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  AccountStatusReq(const AccountStatusReq& from);
  AccountStatusReq(AccountStatusReq&& from) noexcept
    : AccountStatusReq() {
    *this = ::std::move(from);
  }

  inline AccountStatusReq& operator=(const AccountStatusReq& from) {
    CopyFrom(from);
    return *this;
  }
  inline AccountStatusReq& operator=(AccountStatusReq&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const AccountStatusReq& default_instance() {
    return *internal_default_instance();
  }
  static inline const AccountStatusReq* internal_default_instance() {
    return reinterpret_cast<const AccountStatusReq*>(
               &_AccountStatusReq_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  friend void swap(AccountStatusReq& a, AccountStatusReq& b) {
    a.Swap(&b);
  }
  inline void Swap(AccountStatusReq* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(AccountStatusReq* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  AccountStatusReq* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<AccountStatusReq>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const AccountStatusReq& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const AccountStatusReq& from) {
    AccountStatusReq::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(AccountStatusReq* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "ipc.AccountStatusReq";
  }
  protected:
  explicit AccountStatusReq(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef AccountStatusReq_Indication Indication;
  static constexpr Indication reserve =
    AccountStatusReq_Indication_reserve;
  static constexpr Indication start =
    AccountStatusReq_Indication_start;
  static constexpr Indication stop =
    AccountStatusReq_Indication_stop;
  static inline bool Indication_IsValid(int value) {
    return AccountStatusReq_Indication_IsValid(value);
  }
  static constexpr Indication Indication_MIN =
    AccountStatusReq_Indication_Indication_MIN;
  static constexpr Indication Indication_MAX =
    AccountStatusReq_Indication_Indication_MAX;
  static constexpr int Indication_ARRAYSIZE =
    AccountStatusReq_Indication_Indication_ARRAYSIZE;
  static inline const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
  Indication_descriptor() {
    return AccountStatusReq_Indication_descriptor();
  }
  template<typename T>
  static inline const std::string& Indication_Name(T enum_t_value) {
    static_assert(::std::is_same<T, Indication>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function Indication_Name.");
    return AccountStatusReq_Indication_Name(enum_t_value);
  }
  static inline bool Indication_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name,
      Indication* value) {
    return AccountStatusReq_Indication_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  enum : int {
    kIndicationFieldNumber = 1,
  };
  // .ipc.AccountStatusReq.Indication indication = 1;
  void clear_indication();
  ::ipc::AccountStatusReq_Indication indication() const;
  void set_indication(::ipc::AccountStatusReq_Indication value);
  private:
  ::ipc::AccountStatusReq_Indication _internal_indication() const;
  void _internal_set_indication(::ipc::AccountStatusReq_Indication value);
  public:

  // @@protoc_insertion_point(class_scope:ipc.AccountStatusReq)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    int indication_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_ipc_2eproto;
};
// -------------------------------------------------------------------

class SendEmail final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:ipc.SendEmail) */ {
 public:
  inline SendEmail() : SendEmail(nullptr) {}
  ~SendEmail() override;
  explicit PROTOBUF_CONSTEXPR SendEmail(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  SendEmail(const SendEmail& from);
  SendEmail(SendEmail&& from) noexcept
    : SendEmail() {
    *this = ::std::move(from);
  }

  inline SendEmail& operator=(const SendEmail& from) {
    CopyFrom(from);
    return *this;
  }
  inline SendEmail& operator=(SendEmail&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SendEmail& default_instance() {
    return *internal_default_instance();
  }
  static inline const SendEmail* internal_default_instance() {
    return reinterpret_cast<const SendEmail*>(
               &_SendEmail_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    4;

  friend void swap(SendEmail& a, SendEmail& b) {
    a.Swap(&b);
  }
  inline void Swap(SendEmail* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SendEmail* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SendEmail* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<SendEmail>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const SendEmail& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const SendEmail& from) {
    SendEmail::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SendEmail* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "ipc.SendEmail";
  }
  protected:
  explicit SendEmail(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kHeadFieldNumber = 1,
    kBodyFieldNumber = 2,
  };
  // string head = 1;
  void clear_head();
  const std::string& head() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_head(ArgT0&& arg0, ArgT... args);
  std::string* mutable_head();
  PROTOBUF_NODISCARD std::string* release_head();
  void set_allocated_head(std::string* head);
  private:
  const std::string& _internal_head() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_head(const std::string& value);
  std::string* _internal_mutable_head();
  public:

  // string body = 2;
  void clear_body();
  const std::string& body() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_body(ArgT0&& arg0, ArgT... args);
  std::string* mutable_body();
  PROTOBUF_NODISCARD std::string* release_body();
  void set_allocated_body(std::string* body);
  private:
  const std::string& _internal_body() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_body(const std::string& value);
  std::string* _internal_mutable_body();
  public:

  // @@protoc_insertion_point(class_scope:ipc.SendEmail)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr head_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr body_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_ipc_2eproto;
};
// -------------------------------------------------------------------

class UpdateCapital final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:ipc.UpdateCapital) */ {
 public:
  inline UpdateCapital() : UpdateCapital(nullptr) {}
  ~UpdateCapital() override;
  explicit PROTOBUF_CONSTEXPR UpdateCapital(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  UpdateCapital(const UpdateCapital& from);
  UpdateCapital(UpdateCapital&& from) noexcept
    : UpdateCapital() {
    *this = ::std::move(from);
  }

  inline UpdateCapital& operator=(const UpdateCapital& from) {
    CopyFrom(from);
    return *this;
  }
  inline UpdateCapital& operator=(UpdateCapital&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const UpdateCapital& default_instance() {
    return *internal_default_instance();
  }
  static inline const UpdateCapital* internal_default_instance() {
    return reinterpret_cast<const UpdateCapital*>(
               &_UpdateCapital_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    5;

  friend void swap(UpdateCapital& a, UpdateCapital& b) {
    a.Swap(&b);
  }
  inline void Swap(UpdateCapital* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(UpdateCapital* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  UpdateCapital* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<UpdateCapital>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const UpdateCapital& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const UpdateCapital& from) {
    UpdateCapital::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(UpdateCapital* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "ipc.UpdateCapital";
  }
  protected:
  explicit UpdateCapital(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kInsFieldNumber = 1,
    kIndexFieldNumber = 2,
    kProfitFieldNumber = 3,
  };
  // string ins = 1;
  void clear_ins();
  const std::string& ins() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_ins(ArgT0&& arg0, ArgT... args);
  std::string* mutable_ins();
  PROTOBUF_NODISCARD std::string* release_ins();
  void set_allocated_ins(std::string* ins);
  private:
  const std::string& _internal_ins() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_ins(const std::string& value);
  std::string* _internal_mutable_ins();
  public:

  // string index = 2;
  void clear_index();
  const std::string& index() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_index(ArgT0&& arg0, ArgT... args);
  std::string* mutable_index();
  PROTOBUF_NODISCARD std::string* release_index();
  void set_allocated_index(std::string* index);
  private:
  const std::string& _internal_index() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_index(const std::string& value);
  std::string* _internal_mutable_index();
  public:

  // double profit = 3;
  void clear_profit();
  double profit() const;
  void set_profit(double value);
  private:
  double _internal_profit() const;
  void _internal_set_profit(double value);
  public:

  // @@protoc_insertion_point(class_scope:ipc.UpdateCapital)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr ins_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr index_;
    double profit_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_ipc_2eproto;
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// message

// .ipc.ItpMsg itp_msg = 1;
inline bool message::_internal_has_itp_msg() const {
  return MessageType_case() == kItpMsg;
}
inline bool message::has_itp_msg() const {
  return _internal_has_itp_msg();
}
inline void message::set_has_itp_msg() {
  _impl_._oneof_case_[0] = kItpMsg;
}
inline void message::clear_itp_msg() {
  if (_internal_has_itp_msg()) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.MessageType_.itp_msg_;
    }
    clear_has_MessageType();
  }
}
inline ::ipc::ItpMsg* message::release_itp_msg() {
  // @@protoc_insertion_point(field_release:ipc.message.itp_msg)
  if (_internal_has_itp_msg()) {
    clear_has_MessageType();
    ::ipc::ItpMsg* temp = _impl_.MessageType_.itp_msg_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.MessageType_.itp_msg_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::ipc::ItpMsg& message::_internal_itp_msg() const {
  return _internal_has_itp_msg()
      ? *_impl_.MessageType_.itp_msg_
      : reinterpret_cast< ::ipc::ItpMsg&>(::ipc::_ItpMsg_default_instance_);
}
inline const ::ipc::ItpMsg& message::itp_msg() const {
  // @@protoc_insertion_point(field_get:ipc.message.itp_msg)
  return _internal_itp_msg();
}
inline ::ipc::ItpMsg* message::unsafe_arena_release_itp_msg() {
  // @@protoc_insertion_point(field_unsafe_arena_release:ipc.message.itp_msg)
  if (_internal_has_itp_msg()) {
    clear_has_MessageType();
    ::ipc::ItpMsg* temp = _impl_.MessageType_.itp_msg_;
    _impl_.MessageType_.itp_msg_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void message::unsafe_arena_set_allocated_itp_msg(::ipc::ItpMsg* itp_msg) {
  clear_MessageType();
  if (itp_msg) {
    set_has_itp_msg();
    _impl_.MessageType_.itp_msg_ = itp_msg;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:ipc.message.itp_msg)
}
inline ::ipc::ItpMsg* message::_internal_mutable_itp_msg() {
  if (!_internal_has_itp_msg()) {
    clear_MessageType();
    set_has_itp_msg();
    _impl_.MessageType_.itp_msg_ = CreateMaybeMessage< ::ipc::ItpMsg >(GetArenaForAllocation());
  }
  return _impl_.MessageType_.itp_msg_;
}
inline ::ipc::ItpMsg* message::mutable_itp_msg() {
  ::ipc::ItpMsg* _msg = _internal_mutable_itp_msg();
  // @@protoc_insertion_point(field_mutable:ipc.message.itp_msg)
  return _msg;
}

// .ipc.OrderIndex order_index = 2;
inline bool message::_internal_has_order_index() const {
  return MessageType_case() == kOrderIndex;
}
inline bool message::has_order_index() const {
  return _internal_has_order_index();
}
inline void message::set_has_order_index() {
  _impl_._oneof_case_[0] = kOrderIndex;
}
inline void message::clear_order_index() {
  if (_internal_has_order_index()) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.MessageType_.order_index_;
    }
    clear_has_MessageType();
  }
}
inline ::ipc::OrderIndex* message::release_order_index() {
  // @@protoc_insertion_point(field_release:ipc.message.order_index)
  if (_internal_has_order_index()) {
    clear_has_MessageType();
    ::ipc::OrderIndex* temp = _impl_.MessageType_.order_index_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.MessageType_.order_index_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::ipc::OrderIndex& message::_internal_order_index() const {
  return _internal_has_order_index()
      ? *_impl_.MessageType_.order_index_
      : reinterpret_cast< ::ipc::OrderIndex&>(::ipc::_OrderIndex_default_instance_);
}
inline const ::ipc::OrderIndex& message::order_index() const {
  // @@protoc_insertion_point(field_get:ipc.message.order_index)
  return _internal_order_index();
}
inline ::ipc::OrderIndex* message::unsafe_arena_release_order_index() {
  // @@protoc_insertion_point(field_unsafe_arena_release:ipc.message.order_index)
  if (_internal_has_order_index()) {
    clear_has_MessageType();
    ::ipc::OrderIndex* temp = _impl_.MessageType_.order_index_;
    _impl_.MessageType_.order_index_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void message::unsafe_arena_set_allocated_order_index(::ipc::OrderIndex* order_index) {
  clear_MessageType();
  if (order_index) {
    set_has_order_index();
    _impl_.MessageType_.order_index_ = order_index;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:ipc.message.order_index)
}
inline ::ipc::OrderIndex* message::_internal_mutable_order_index() {
  if (!_internal_has_order_index()) {
    clear_MessageType();
    set_has_order_index();
    _impl_.MessageType_.order_index_ = CreateMaybeMessage< ::ipc::OrderIndex >(GetArenaForAllocation());
  }
  return _impl_.MessageType_.order_index_;
}
inline ::ipc::OrderIndex* message::mutable_order_index() {
  ::ipc::OrderIndex* _msg = _internal_mutable_order_index();
  // @@protoc_insertion_point(field_mutable:ipc.message.order_index)
  return _msg;
}

// .ipc.AccountStatusReq account_status_req = 3;
inline bool message::_internal_has_account_status_req() const {
  return MessageType_case() == kAccountStatusReq;
}
inline bool message::has_account_status_req() const {
  return _internal_has_account_status_req();
}
inline void message::set_has_account_status_req() {
  _impl_._oneof_case_[0] = kAccountStatusReq;
}
inline void message::clear_account_status_req() {
  if (_internal_has_account_status_req()) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.MessageType_.account_status_req_;
    }
    clear_has_MessageType();
  }
}
inline ::ipc::AccountStatusReq* message::release_account_status_req() {
  // @@protoc_insertion_point(field_release:ipc.message.account_status_req)
  if (_internal_has_account_status_req()) {
    clear_has_MessageType();
    ::ipc::AccountStatusReq* temp = _impl_.MessageType_.account_status_req_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.MessageType_.account_status_req_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::ipc::AccountStatusReq& message::_internal_account_status_req() const {
  return _internal_has_account_status_req()
      ? *_impl_.MessageType_.account_status_req_
      : reinterpret_cast< ::ipc::AccountStatusReq&>(::ipc::_AccountStatusReq_default_instance_);
}
inline const ::ipc::AccountStatusReq& message::account_status_req() const {
  // @@protoc_insertion_point(field_get:ipc.message.account_status_req)
  return _internal_account_status_req();
}
inline ::ipc::AccountStatusReq* message::unsafe_arena_release_account_status_req() {
  // @@protoc_insertion_point(field_unsafe_arena_release:ipc.message.account_status_req)
  if (_internal_has_account_status_req()) {
    clear_has_MessageType();
    ::ipc::AccountStatusReq* temp = _impl_.MessageType_.account_status_req_;
    _impl_.MessageType_.account_status_req_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void message::unsafe_arena_set_allocated_account_status_req(::ipc::AccountStatusReq* account_status_req) {
  clear_MessageType();
  if (account_status_req) {
    set_has_account_status_req();
    _impl_.MessageType_.account_status_req_ = account_status_req;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:ipc.message.account_status_req)
}
inline ::ipc::AccountStatusReq* message::_internal_mutable_account_status_req() {
  if (!_internal_has_account_status_req()) {
    clear_MessageType();
    set_has_account_status_req();
    _impl_.MessageType_.account_status_req_ = CreateMaybeMessage< ::ipc::AccountStatusReq >(GetArenaForAllocation());
  }
  return _impl_.MessageType_.account_status_req_;
}
inline ::ipc::AccountStatusReq* message::mutable_account_status_req() {
  ::ipc::AccountStatusReq* _msg = _internal_mutable_account_status_req();
  // @@protoc_insertion_point(field_mutable:ipc.message.account_status_req)
  return _msg;
}

// .ipc.SendEmail send_email = 4;
inline bool message::_internal_has_send_email() const {
  return MessageType_case() == kSendEmail;
}
inline bool message::has_send_email() const {
  return _internal_has_send_email();
}
inline void message::set_has_send_email() {
  _impl_._oneof_case_[0] = kSendEmail;
}
inline void message::clear_send_email() {
  if (_internal_has_send_email()) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.MessageType_.send_email_;
    }
    clear_has_MessageType();
  }
}
inline ::ipc::SendEmail* message::release_send_email() {
  // @@protoc_insertion_point(field_release:ipc.message.send_email)
  if (_internal_has_send_email()) {
    clear_has_MessageType();
    ::ipc::SendEmail* temp = _impl_.MessageType_.send_email_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.MessageType_.send_email_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::ipc::SendEmail& message::_internal_send_email() const {
  return _internal_has_send_email()
      ? *_impl_.MessageType_.send_email_
      : reinterpret_cast< ::ipc::SendEmail&>(::ipc::_SendEmail_default_instance_);
}
inline const ::ipc::SendEmail& message::send_email() const {
  // @@protoc_insertion_point(field_get:ipc.message.send_email)
  return _internal_send_email();
}
inline ::ipc::SendEmail* message::unsafe_arena_release_send_email() {
  // @@protoc_insertion_point(field_unsafe_arena_release:ipc.message.send_email)
  if (_internal_has_send_email()) {
    clear_has_MessageType();
    ::ipc::SendEmail* temp = _impl_.MessageType_.send_email_;
    _impl_.MessageType_.send_email_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void message::unsafe_arena_set_allocated_send_email(::ipc::SendEmail* send_email) {
  clear_MessageType();
  if (send_email) {
    set_has_send_email();
    _impl_.MessageType_.send_email_ = send_email;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:ipc.message.send_email)
}
inline ::ipc::SendEmail* message::_internal_mutable_send_email() {
  if (!_internal_has_send_email()) {
    clear_MessageType();
    set_has_send_email();
    _impl_.MessageType_.send_email_ = CreateMaybeMessage< ::ipc::SendEmail >(GetArenaForAllocation());
  }
  return _impl_.MessageType_.send_email_;
}
inline ::ipc::SendEmail* message::mutable_send_email() {
  ::ipc::SendEmail* _msg = _internal_mutable_send_email();
  // @@protoc_insertion_point(field_mutable:ipc.message.send_email)
  return _msg;
}

// .ipc.UpdateCapital update_capital = 5;
inline bool message::_internal_has_update_capital() const {
  return MessageType_case() == kUpdateCapital;
}
inline bool message::has_update_capital() const {
  return _internal_has_update_capital();
}
inline void message::set_has_update_capital() {
  _impl_._oneof_case_[0] = kUpdateCapital;
}
inline void message::clear_update_capital() {
  if (_internal_has_update_capital()) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.MessageType_.update_capital_;
    }
    clear_has_MessageType();
  }
}
inline ::ipc::UpdateCapital* message::release_update_capital() {
  // @@protoc_insertion_point(field_release:ipc.message.update_capital)
  if (_internal_has_update_capital()) {
    clear_has_MessageType();
    ::ipc::UpdateCapital* temp = _impl_.MessageType_.update_capital_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.MessageType_.update_capital_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::ipc::UpdateCapital& message::_internal_update_capital() const {
  return _internal_has_update_capital()
      ? *_impl_.MessageType_.update_capital_
      : reinterpret_cast< ::ipc::UpdateCapital&>(::ipc::_UpdateCapital_default_instance_);
}
inline const ::ipc::UpdateCapital& message::update_capital() const {
  // @@protoc_insertion_point(field_get:ipc.message.update_capital)
  return _internal_update_capital();
}
inline ::ipc::UpdateCapital* message::unsafe_arena_release_update_capital() {
  // @@protoc_insertion_point(field_unsafe_arena_release:ipc.message.update_capital)
  if (_internal_has_update_capital()) {
    clear_has_MessageType();
    ::ipc::UpdateCapital* temp = _impl_.MessageType_.update_capital_;
    _impl_.MessageType_.update_capital_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void message::unsafe_arena_set_allocated_update_capital(::ipc::UpdateCapital* update_capital) {
  clear_MessageType();
  if (update_capital) {
    set_has_update_capital();
    _impl_.MessageType_.update_capital_ = update_capital;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:ipc.message.update_capital)
}
inline ::ipc::UpdateCapital* message::_internal_mutable_update_capital() {
  if (!_internal_has_update_capital()) {
    clear_MessageType();
    set_has_update_capital();
    _impl_.MessageType_.update_capital_ = CreateMaybeMessage< ::ipc::UpdateCapital >(GetArenaForAllocation());
  }
  return _impl_.MessageType_.update_capital_;
}
inline ::ipc::UpdateCapital* message::mutable_update_capital() {
  ::ipc::UpdateCapital* _msg = _internal_mutable_update_capital();
  // @@protoc_insertion_point(field_mutable:ipc.message.update_capital)
  return _msg;
}

inline bool message::has_MessageType() const {
  return MessageType_case() != MESSAGETYPE_NOT_SET;
}
inline void message::clear_has_MessageType() {
  _impl_._oneof_case_[0] = MESSAGETYPE_NOT_SET;
}
inline message::MessageTypeCase message::MessageType_case() const {
  return message::MessageTypeCase(_impl_._oneof_case_[0]);
}
// -------------------------------------------------------------------

// ItpMsg

// int64 address = 1;
inline void ItpMsg::clear_address() {
  _impl_.address_ = int64_t{0};
}
inline int64_t ItpMsg::_internal_address() const {
  return _impl_.address_;
}
inline int64_t ItpMsg::address() const {
  // @@protoc_insertion_point(field_get:ipc.ItpMsg.address)
  return _internal_address();
}
inline void ItpMsg::_internal_set_address(int64_t value) {
  
  _impl_.address_ = value;
}
inline void ItpMsg::set_address(int64_t value) {
  _internal_set_address(value);
  // @@protoc_insertion_point(field_set:ipc.ItpMsg.address)
}

// int64 rsp_info = 2;
inline void ItpMsg::clear_rsp_info() {
  _impl_.rsp_info_ = int64_t{0};
}
inline int64_t ItpMsg::_internal_rsp_info() const {
  return _impl_.rsp_info_;
}
inline int64_t ItpMsg::rsp_info() const {
  // @@protoc_insertion_point(field_get:ipc.ItpMsg.rsp_info)
  return _internal_rsp_info();
}
inline void ItpMsg::_internal_set_rsp_info(int64_t value) {
  
  _impl_.rsp_info_ = value;
}
inline void ItpMsg::set_rsp_info(int64_t value) {
  _internal_set_rsp_info(value);
  // @@protoc_insertion_point(field_set:ipc.ItpMsg.rsp_info)
}

// string user_id = 3;
inline void ItpMsg::clear_user_id() {
  _impl_.user_id_.ClearToEmpty();
}
inline const std::string& ItpMsg::user_id() const {
  // @@protoc_insertion_point(field_get:ipc.ItpMsg.user_id)
  return _internal_user_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ItpMsg::set_user_id(ArgT0&& arg0, ArgT... args) {
 
 _impl_.user_id_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:ipc.ItpMsg.user_id)
}
inline std::string* ItpMsg::mutable_user_id() {
  std::string* _s = _internal_mutable_user_id();
  // @@protoc_insertion_point(field_mutable:ipc.ItpMsg.user_id)
  return _s;
}
inline const std::string& ItpMsg::_internal_user_id() const {
  return _impl_.user_id_.Get();
}
inline void ItpMsg::_internal_set_user_id(const std::string& value) {
  
  _impl_.user_id_.Set(value, GetArenaForAllocation());
}
inline std::string* ItpMsg::_internal_mutable_user_id() {
  
  return _impl_.user_id_.Mutable(GetArenaForAllocation());
}
inline std::string* ItpMsg::release_user_id() {
  // @@protoc_insertion_point(field_release:ipc.ItpMsg.user_id)
  return _impl_.user_id_.Release();
}
inline void ItpMsg::set_allocated_user_id(std::string* user_id) {
  if (user_id != nullptr) {
    
  } else {
    
  }
  _impl_.user_id_.SetAllocated(user_id, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.user_id_.IsDefault()) {
    _impl_.user_id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:ipc.ItpMsg.user_id)
}

// uint64 session_id = 4;
inline void ItpMsg::clear_session_id() {
  _impl_.session_id_ = uint64_t{0u};
}
inline uint64_t ItpMsg::_internal_session_id() const {
  return _impl_.session_id_;
}
inline uint64_t ItpMsg::session_id() const {
  // @@protoc_insertion_point(field_get:ipc.ItpMsg.session_id)
  return _internal_session_id();
}
inline void ItpMsg::_internal_set_session_id(uint64_t value) {
  
  _impl_.session_id_ = value;
}
inline void ItpMsg::set_session_id(uint64_t value) {
  _internal_set_session_id(value);
  // @@protoc_insertion_point(field_set:ipc.ItpMsg.session_id)
}

// bool is_last = 5;
inline void ItpMsg::clear_is_last() {
  _impl_.is_last_ = false;
}
inline bool ItpMsg::_internal_is_last() const {
  return _impl_.is_last_;
}
inline bool ItpMsg::is_last() const {
  // @@protoc_insertion_point(field_get:ipc.ItpMsg.is_last)
  return _internal_is_last();
}
inline void ItpMsg::_internal_set_is_last(bool value) {
  
  _impl_.is_last_ = value;
}
inline void ItpMsg::set_is_last(bool value) {
  _internal_set_is_last(value);
  // @@protoc_insertion_point(field_set:ipc.ItpMsg.is_last)
}

// -------------------------------------------------------------------

// OrderIndex

// string ins = 1;
inline void OrderIndex::clear_ins() {
  _impl_.ins_.ClearToEmpty();
}
inline const std::string& OrderIndex::ins() const {
  // @@protoc_insertion_point(field_get:ipc.OrderIndex.ins)
  return _internal_ins();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void OrderIndex::set_ins(ArgT0&& arg0, ArgT... args) {
 
 _impl_.ins_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:ipc.OrderIndex.ins)
}
inline std::string* OrderIndex::mutable_ins() {
  std::string* _s = _internal_mutable_ins();
  // @@protoc_insertion_point(field_mutable:ipc.OrderIndex.ins)
  return _s;
}
inline const std::string& OrderIndex::_internal_ins() const {
  return _impl_.ins_.Get();
}
inline void OrderIndex::_internal_set_ins(const std::string& value) {
  
  _impl_.ins_.Set(value, GetArenaForAllocation());
}
inline std::string* OrderIndex::_internal_mutable_ins() {
  
  return _impl_.ins_.Mutable(GetArenaForAllocation());
}
inline std::string* OrderIndex::release_ins() {
  // @@protoc_insertion_point(field_release:ipc.OrderIndex.ins)
  return _impl_.ins_.Release();
}
inline void OrderIndex::set_allocated_ins(std::string* ins) {
  if (ins != nullptr) {
    
  } else {
    
  }
  _impl_.ins_.SetAllocated(ins, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.ins_.IsDefault()) {
    _impl_.ins_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:ipc.OrderIndex.ins)
}

// string index = 2;
inline void OrderIndex::clear_index() {
  _impl_.index_.ClearToEmpty();
}
inline const std::string& OrderIndex::index() const {
  // @@protoc_insertion_point(field_get:ipc.OrderIndex.index)
  return _internal_index();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void OrderIndex::set_index(ArgT0&& arg0, ArgT... args) {
 
 _impl_.index_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:ipc.OrderIndex.index)
}
inline std::string* OrderIndex::mutable_index() {
  std::string* _s = _internal_mutable_index();
  // @@protoc_insertion_point(field_mutable:ipc.OrderIndex.index)
  return _s;
}
inline const std::string& OrderIndex::_internal_index() const {
  return _impl_.index_.Get();
}
inline void OrderIndex::_internal_set_index(const std::string& value) {
  
  _impl_.index_.Set(value, GetArenaForAllocation());
}
inline std::string* OrderIndex::_internal_mutable_index() {
  
  return _impl_.index_.Mutable(GetArenaForAllocation());
}
inline std::string* OrderIndex::release_index() {
  // @@protoc_insertion_point(field_release:ipc.OrderIndex.index)
  return _impl_.index_.Release();
}
inline void OrderIndex::set_allocated_index(std::string* index) {
  if (index != nullptr) {
    
  } else {
    
  }
  _impl_.index_.SetAllocated(index, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.index_.IsDefault()) {
    _impl_.index_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:ipc.OrderIndex.index)
}

// -------------------------------------------------------------------

// AccountStatusReq

// .ipc.AccountStatusReq.Indication indication = 1;
inline void AccountStatusReq::clear_indication() {
  _impl_.indication_ = 0;
}
inline ::ipc::AccountStatusReq_Indication AccountStatusReq::_internal_indication() const {
  return static_cast< ::ipc::AccountStatusReq_Indication >(_impl_.indication_);
}
inline ::ipc::AccountStatusReq_Indication AccountStatusReq::indication() const {
  // @@protoc_insertion_point(field_get:ipc.AccountStatusReq.indication)
  return _internal_indication();
}
inline void AccountStatusReq::_internal_set_indication(::ipc::AccountStatusReq_Indication value) {
  
  _impl_.indication_ = value;
}
inline void AccountStatusReq::set_indication(::ipc::AccountStatusReq_Indication value) {
  _internal_set_indication(value);
  // @@protoc_insertion_point(field_set:ipc.AccountStatusReq.indication)
}

// -------------------------------------------------------------------

// SendEmail

// string head = 1;
inline void SendEmail::clear_head() {
  _impl_.head_.ClearToEmpty();
}
inline const std::string& SendEmail::head() const {
  // @@protoc_insertion_point(field_get:ipc.SendEmail.head)
  return _internal_head();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void SendEmail::set_head(ArgT0&& arg0, ArgT... args) {
 
 _impl_.head_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:ipc.SendEmail.head)
}
inline std::string* SendEmail::mutable_head() {
  std::string* _s = _internal_mutable_head();
  // @@protoc_insertion_point(field_mutable:ipc.SendEmail.head)
  return _s;
}
inline const std::string& SendEmail::_internal_head() const {
  return _impl_.head_.Get();
}
inline void SendEmail::_internal_set_head(const std::string& value) {
  
  _impl_.head_.Set(value, GetArenaForAllocation());
}
inline std::string* SendEmail::_internal_mutable_head() {
  
  return _impl_.head_.Mutable(GetArenaForAllocation());
}
inline std::string* SendEmail::release_head() {
  // @@protoc_insertion_point(field_release:ipc.SendEmail.head)
  return _impl_.head_.Release();
}
inline void SendEmail::set_allocated_head(std::string* head) {
  if (head != nullptr) {
    
  } else {
    
  }
  _impl_.head_.SetAllocated(head, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.head_.IsDefault()) {
    _impl_.head_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:ipc.SendEmail.head)
}

// string body = 2;
inline void SendEmail::clear_body() {
  _impl_.body_.ClearToEmpty();
}
inline const std::string& SendEmail::body() const {
  // @@protoc_insertion_point(field_get:ipc.SendEmail.body)
  return _internal_body();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void SendEmail::set_body(ArgT0&& arg0, ArgT... args) {
 
 _impl_.body_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:ipc.SendEmail.body)
}
inline std::string* SendEmail::mutable_body() {
  std::string* _s = _internal_mutable_body();
  // @@protoc_insertion_point(field_mutable:ipc.SendEmail.body)
  return _s;
}
inline const std::string& SendEmail::_internal_body() const {
  return _impl_.body_.Get();
}
inline void SendEmail::_internal_set_body(const std::string& value) {
  
  _impl_.body_.Set(value, GetArenaForAllocation());
}
inline std::string* SendEmail::_internal_mutable_body() {
  
  return _impl_.body_.Mutable(GetArenaForAllocation());
}
inline std::string* SendEmail::release_body() {
  // @@protoc_insertion_point(field_release:ipc.SendEmail.body)
  return _impl_.body_.Release();
}
inline void SendEmail::set_allocated_body(std::string* body) {
  if (body != nullptr) {
    
  } else {
    
  }
  _impl_.body_.SetAllocated(body, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.body_.IsDefault()) {
    _impl_.body_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:ipc.SendEmail.body)
}

// -------------------------------------------------------------------

// UpdateCapital

// string ins = 1;
inline void UpdateCapital::clear_ins() {
  _impl_.ins_.ClearToEmpty();
}
inline const std::string& UpdateCapital::ins() const {
  // @@protoc_insertion_point(field_get:ipc.UpdateCapital.ins)
  return _internal_ins();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void UpdateCapital::set_ins(ArgT0&& arg0, ArgT... args) {
 
 _impl_.ins_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:ipc.UpdateCapital.ins)
}
inline std::string* UpdateCapital::mutable_ins() {
  std::string* _s = _internal_mutable_ins();
  // @@protoc_insertion_point(field_mutable:ipc.UpdateCapital.ins)
  return _s;
}
inline const std::string& UpdateCapital::_internal_ins() const {
  return _impl_.ins_.Get();
}
inline void UpdateCapital::_internal_set_ins(const std::string& value) {
  
  _impl_.ins_.Set(value, GetArenaForAllocation());
}
inline std::string* UpdateCapital::_internal_mutable_ins() {
  
  return _impl_.ins_.Mutable(GetArenaForAllocation());
}
inline std::string* UpdateCapital::release_ins() {
  // @@protoc_insertion_point(field_release:ipc.UpdateCapital.ins)
  return _impl_.ins_.Release();
}
inline void UpdateCapital::set_allocated_ins(std::string* ins) {
  if (ins != nullptr) {
    
  } else {
    
  }
  _impl_.ins_.SetAllocated(ins, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.ins_.IsDefault()) {
    _impl_.ins_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:ipc.UpdateCapital.ins)
}

// string index = 2;
inline void UpdateCapital::clear_index() {
  _impl_.index_.ClearToEmpty();
}
inline const std::string& UpdateCapital::index() const {
  // @@protoc_insertion_point(field_get:ipc.UpdateCapital.index)
  return _internal_index();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void UpdateCapital::set_index(ArgT0&& arg0, ArgT... args) {
 
 _impl_.index_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:ipc.UpdateCapital.index)
}
inline std::string* UpdateCapital::mutable_index() {
  std::string* _s = _internal_mutable_index();
  // @@protoc_insertion_point(field_mutable:ipc.UpdateCapital.index)
  return _s;
}
inline const std::string& UpdateCapital::_internal_index() const {
  return _impl_.index_.Get();
}
inline void UpdateCapital::_internal_set_index(const std::string& value) {
  
  _impl_.index_.Set(value, GetArenaForAllocation());
}
inline std::string* UpdateCapital::_internal_mutable_index() {
  
  return _impl_.index_.Mutable(GetArenaForAllocation());
}
inline std::string* UpdateCapital::release_index() {
  // @@protoc_insertion_point(field_release:ipc.UpdateCapital.index)
  return _impl_.index_.Release();
}
inline void UpdateCapital::set_allocated_index(std::string* index) {
  if (index != nullptr) {
    
  } else {
    
  }
  _impl_.index_.SetAllocated(index, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.index_.IsDefault()) {
    _impl_.index_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:ipc.UpdateCapital.index)
}

// double profit = 3;
inline void UpdateCapital::clear_profit() {
  _impl_.profit_ = 0;
}
inline double UpdateCapital::_internal_profit() const {
  return _impl_.profit_;
}
inline double UpdateCapital::profit() const {
  // @@protoc_insertion_point(field_get:ipc.UpdateCapital.profit)
  return _internal_profit();
}
inline void UpdateCapital::_internal_set_profit(double value) {
  
  _impl_.profit_ = value;
}
inline void UpdateCapital::set_profit(double value) {
  _internal_set_profit(value);
  // @@protoc_insertion_point(field_set:ipc.UpdateCapital.profit)
}

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace ipc

PROTOBUF_NAMESPACE_OPEN

template <> struct is_proto_enum< ::ipc::AccountStatusReq_Indication> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::ipc::AccountStatusReq_Indication>() {
  return ::ipc::AccountStatusReq_Indication_descriptor();
}

PROTOBUF_NAMESPACE_CLOSE

// @@protoc_insertion_point(global_scope)

#include <google/protobuf/port_undef.inc>
#endif  // GOOGLE_PROTOBUF_INCLUDED_GOOGLE_PROTOBUF_INCLUDED_ipc_2eproto
