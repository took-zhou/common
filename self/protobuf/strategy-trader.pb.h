// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: strategy-trader.proto

#ifndef GOOGLE_PROTOBUF_INCLUDED_strategy_2dtrader_2eproto
#define GOOGLE_PROTOBUF_INCLUDED_strategy_2dtrader_2eproto

#include <limits>
#include <string>

#include <google/protobuf/port_def.inc>
#if PROTOBUF_VERSION < 3021000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers. Please update
#error your headers.
#endif
#if 3021005 < PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers. Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/port_undef.inc>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/metadata_lite.h>
#include <google/protobuf/generated_message_reflection.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/generated_enum_reflection.h>
#include <google/protobuf/unknown_field_set.h>
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>
#define PROTOBUF_INTERNAL_EXPORT_strategy_2dtrader_2eproto
PROTOBUF_NAMESPACE_OPEN
namespace internal {
class AnyMetadata;
}  // namespace internal
PROTOBUF_NAMESPACE_CLOSE

// Internal implementation detail -- do not use these members.
struct TableStruct_strategy_2dtrader_2eproto {
  static const uint32_t offsets[];
};
extern const ::PROTOBUF_NAMESPACE_ID::internal::DescriptorTable descriptor_table_strategy_2dtrader_2eproto;
namespace strategy_trader {
class AccountSetRsp;
struct AccountSetRspDefaultTypeInternal;
extern AccountSetRspDefaultTypeInternal _AccountSetRsp_default_instance_;
class AccountStatusRsp;
struct AccountStatusRspDefaultTypeInternal;
extern AccountStatusRspDefaultTypeInternal _AccountStatusRsp_default_instance_;
class ActiveSafetyReq;
struct ActiveSafetyReqDefaultTypeInternal;
extern ActiveSafetyReqDefaultTypeInternal _ActiveSafetyReq_default_instance_;
class ActiveSafetyRsp;
struct ActiveSafetyRspDefaultTypeInternal;
extern ActiveSafetyRspDefaultTypeInternal _ActiveSafetyRsp_default_instance_;
class CheckStrategyAliveReq;
struct CheckStrategyAliveReqDefaultTypeInternal;
extern CheckStrategyAliveReqDefaultTypeInternal _CheckStrategyAliveReq_default_instance_;
class CheckStrategyAliveRsp;
struct CheckStrategyAliveRspDefaultTypeInternal;
extern CheckStrategyAliveRspDefaultTypeInternal _CheckStrategyAliveRsp_default_instance_;
class CheckTraderAliveReq;
struct CheckTraderAliveReqDefaultTypeInternal;
extern CheckTraderAliveReqDefaultTypeInternal _CheckTraderAliveReq_default_instance_;
class CheckTraderAliveRsp;
struct CheckTraderAliveRspDefaultTypeInternal;
extern CheckTraderAliveRspDefaultTypeInternal _CheckTraderAliveRsp_default_instance_;
class CommissionRateRsp;
struct CommissionRateRspDefaultTypeInternal;
extern CommissionRateRspDefaultTypeInternal _CommissionRateRsp_default_instance_;
class GroupSizeReq;
struct GroupSizeReqDefaultTypeInternal;
extern GroupSizeReqDefaultTypeInternal _GroupSizeReq_default_instance_;
class GroupSizeRsp;
struct GroupSizeRspDefaultTypeInternal;
extern GroupSizeRspDefaultTypeInternal _GroupSizeRsp_default_instance_;
class InstrumentInfo;
struct InstrumentInfoDefaultTypeInternal;
extern InstrumentInfoDefaultTypeInternal _InstrumentInfo_default_instance_;
class MarginRateRsp;
struct MarginRateRspDefaultTypeInternal;
extern MarginRateRspDefaultTypeInternal _MarginRateRsp_default_instance_;
class Order;
struct OrderDefaultTypeInternal;
extern OrderDefaultTypeInternal _Order_default_instance_;
class OrderCancelReq;
struct OrderCancelReqDefaultTypeInternal;
extern OrderCancelReqDefaultTypeInternal _OrderCancelReq_default_instance_;
class OrderCancelRsp;
struct OrderCancelRspDefaultTypeInternal;
extern OrderCancelRspDefaultTypeInternal _OrderCancelRsp_default_instance_;
class OrderInsertReq;
struct OrderInsertReqDefaultTypeInternal;
extern OrderInsertReqDefaultTypeInternal _OrderInsertReq_default_instance_;
class OrderInsertRsp;
struct OrderInsertRspDefaultTypeInternal;
extern OrderInsertRspDefaultTypeInternal _OrderInsertRsp_default_instance_;
class OrderPositionReq;
struct OrderPositionReqDefaultTypeInternal;
extern OrderPositionReqDefaultTypeInternal _OrderPositionReq_default_instance_;
class OrderPositionRsp;
struct OrderPositionRspDefaultTypeInternal;
extern OrderPositionRspDefaultTypeInternal _OrderPositionRsp_default_instance_;
class RspInfo;
struct RspInfoDefaultTypeInternal;
extern RspInfoDefaultTypeInternal _RspInfo_default_instance_;
class TransactionCostReq;
struct TransactionCostReqDefaultTypeInternal;
extern TransactionCostReqDefaultTypeInternal _TransactionCostReq_default_instance_;
class message;
struct messageDefaultTypeInternal;
extern messageDefaultTypeInternal _message_default_instance_;
}  // namespace strategy_trader
PROTOBUF_NAMESPACE_OPEN
template<> ::strategy_trader::AccountSetRsp* Arena::CreateMaybeMessage<::strategy_trader::AccountSetRsp>(Arena*);
template<> ::strategy_trader::AccountStatusRsp* Arena::CreateMaybeMessage<::strategy_trader::AccountStatusRsp>(Arena*);
template<> ::strategy_trader::ActiveSafetyReq* Arena::CreateMaybeMessage<::strategy_trader::ActiveSafetyReq>(Arena*);
template<> ::strategy_trader::ActiveSafetyRsp* Arena::CreateMaybeMessage<::strategy_trader::ActiveSafetyRsp>(Arena*);
template<> ::strategy_trader::CheckStrategyAliveReq* Arena::CreateMaybeMessage<::strategy_trader::CheckStrategyAliveReq>(Arena*);
template<> ::strategy_trader::CheckStrategyAliveRsp* Arena::CreateMaybeMessage<::strategy_trader::CheckStrategyAliveRsp>(Arena*);
template<> ::strategy_trader::CheckTraderAliveReq* Arena::CreateMaybeMessage<::strategy_trader::CheckTraderAliveReq>(Arena*);
template<> ::strategy_trader::CheckTraderAliveRsp* Arena::CreateMaybeMessage<::strategy_trader::CheckTraderAliveRsp>(Arena*);
template<> ::strategy_trader::CommissionRateRsp* Arena::CreateMaybeMessage<::strategy_trader::CommissionRateRsp>(Arena*);
template<> ::strategy_trader::GroupSizeReq* Arena::CreateMaybeMessage<::strategy_trader::GroupSizeReq>(Arena*);
template<> ::strategy_trader::GroupSizeRsp* Arena::CreateMaybeMessage<::strategy_trader::GroupSizeRsp>(Arena*);
template<> ::strategy_trader::InstrumentInfo* Arena::CreateMaybeMessage<::strategy_trader::InstrumentInfo>(Arena*);
template<> ::strategy_trader::MarginRateRsp* Arena::CreateMaybeMessage<::strategy_trader::MarginRateRsp>(Arena*);
template<> ::strategy_trader::Order* Arena::CreateMaybeMessage<::strategy_trader::Order>(Arena*);
template<> ::strategy_trader::OrderCancelReq* Arena::CreateMaybeMessage<::strategy_trader::OrderCancelReq>(Arena*);
template<> ::strategy_trader::OrderCancelRsp* Arena::CreateMaybeMessage<::strategy_trader::OrderCancelRsp>(Arena*);
template<> ::strategy_trader::OrderInsertReq* Arena::CreateMaybeMessage<::strategy_trader::OrderInsertReq>(Arena*);
template<> ::strategy_trader::OrderInsertRsp* Arena::CreateMaybeMessage<::strategy_trader::OrderInsertRsp>(Arena*);
template<> ::strategy_trader::OrderPositionReq* Arena::CreateMaybeMessage<::strategy_trader::OrderPositionReq>(Arena*);
template<> ::strategy_trader::OrderPositionRsp* Arena::CreateMaybeMessage<::strategy_trader::OrderPositionRsp>(Arena*);
template<> ::strategy_trader::RspInfo* Arena::CreateMaybeMessage<::strategy_trader::RspInfo>(Arena*);
template<> ::strategy_trader::TransactionCostReq* Arena::CreateMaybeMessage<::strategy_trader::TransactionCostReq>(Arena*);
template<> ::strategy_trader::message* Arena::CreateMaybeMessage<::strategy_trader::message>(Arena*);
PROTOBUF_NAMESPACE_CLOSE
namespace strategy_trader {

enum ActiveSafetyReq_MessageType : int {
  ActiveSafetyReq_MessageType_reserve = 0,
  ActiveSafetyReq_MessageType_isrun = 1,
  ActiveSafetyReq_MessageType_ActiveSafetyReq_MessageType_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  ActiveSafetyReq_MessageType_ActiveSafetyReq_MessageType_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
bool ActiveSafetyReq_MessageType_IsValid(int value);
constexpr ActiveSafetyReq_MessageType ActiveSafetyReq_MessageType_MessageType_MIN = ActiveSafetyReq_MessageType_reserve;
constexpr ActiveSafetyReq_MessageType ActiveSafetyReq_MessageType_MessageType_MAX = ActiveSafetyReq_MessageType_isrun;
constexpr int ActiveSafetyReq_MessageType_MessageType_ARRAYSIZE = ActiveSafetyReq_MessageType_MessageType_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* ActiveSafetyReq_MessageType_descriptor();
template<typename T>
inline const std::string& ActiveSafetyReq_MessageType_Name(T enum_t_value) {
  static_assert(::std::is_same<T, ActiveSafetyReq_MessageType>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function ActiveSafetyReq_MessageType_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    ActiveSafetyReq_MessageType_descriptor(), enum_t_value);
}
inline bool ActiveSafetyReq_MessageType_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, ActiveSafetyReq_MessageType* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<ActiveSafetyReq_MessageType>(
    ActiveSafetyReq_MessageType_descriptor(), name, value);
}
enum Level : int {
  Level_INVALID = 0,
  ALL = 1,
  SINGLE = 2,
  Level_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  Level_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
bool Level_IsValid(int value);
constexpr Level Level_MIN = Level_INVALID;
constexpr Level Level_MAX = SINGLE;
constexpr int Level_ARRAYSIZE = Level_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* Level_descriptor();
template<typename T>
inline const std::string& Level_Name(T enum_t_value) {
  static_assert(::std::is_same<T, Level>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function Level_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    Level_descriptor(), enum_t_value);
}
inline bool Level_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, Level* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<Level>(
    Level_descriptor(), name, value);
}
enum FailedReason : int {
  FailedReason_INVALID = 0,
  Strategy_Ind_Error = 1,
  Order_Fill_Error = 2,
  Order_Cancel = 3,
  Fund_Shortage_Error = 4,
  No_Opened_Order = 5,
  No_Trading_Time = 6,
  No_Enough_Capital = 7,
  Account_Assign_Error = 8,
  FailedReason_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  FailedReason_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
bool FailedReason_IsValid(int value);
constexpr FailedReason FailedReason_MIN = FailedReason_INVALID;
constexpr FailedReason FailedReason_MAX = Account_Assign_Error;
constexpr int FailedReason_ARRAYSIZE = FailedReason_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* FailedReason_descriptor();
template<typename T>
inline const std::string& FailedReason_Name(T enum_t_value) {
  static_assert(::std::is_same<T, FailedReason>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function FailedReason_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    FailedReason_descriptor(), enum_t_value);
}
inline bool FailedReason_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, FailedReason* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<FailedReason>(
    FailedReason_descriptor(), name, value);
}
enum Result : int {
  Result_INVALID = 0,
  success = 1,
  failed = 2,
  Result_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  Result_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
bool Result_IsValid(int value);
constexpr Result Result_MIN = Result_INVALID;
constexpr Result Result_MAX = failed;
constexpr int Result_ARRAYSIZE = Result_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* Result_descriptor();
template<typename T>
inline const std::string& Result_Name(T enum_t_value) {
  static_assert(::std::is_same<T, Result>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function Result_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    Result_descriptor(), enum_t_value);
}
inline bool Result_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, Result* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<Result>(
    Result_descriptor(), name, value);
}
enum Direction : int {
  Direction_INVALID = 0,
  BUY = 1,
  SELL = 2,
  Direction_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  Direction_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
bool Direction_IsValid(int value);
constexpr Direction Direction_MIN = Direction_INVALID;
constexpr Direction Direction_MAX = SELL;
constexpr int Direction_ARRAYSIZE = Direction_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* Direction_descriptor();
template<typename T>
inline const std::string& Direction_Name(T enum_t_value) {
  static_assert(::std::is_same<T, Direction>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function Direction_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    Direction_descriptor(), enum_t_value);
}
inline bool Direction_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, Direction* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<Direction>(
    Direction_descriptor(), name, value);
}
enum OrderType : int {
  OrderType_INVALID = 0,
  limit_LIMIT = 1,
  Limit_FAK = 2,
  limit_FOK = 3,
  AnyPrice_Fok = 4,
  AnyPrice_Fak = 5,
  OrderType_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  OrderType_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
bool OrderType_IsValid(int value);
constexpr OrderType OrderType_MIN = OrderType_INVALID;
constexpr OrderType OrderType_MAX = AnyPrice_Fak;
constexpr int OrderType_ARRAYSIZE = OrderType_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* OrderType_descriptor();
template<typename T>
inline const std::string& OrderType_Name(T enum_t_value) {
  static_assert(::std::is_same<T, OrderType>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function OrderType_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    OrderType_descriptor(), enum_t_value);
}
inline bool OrderType_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, OrderType* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<OrderType>(
    OrderType_descriptor(), name, value);
}
enum CombOffsetType : int {
  INVALID = 0,
  OPEN = 1,
  CLOSE = 2,
  CLOSE_YESTERDAY = 3,
  CLOSE_TODAY = 4,
  CombOffsetType_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  CombOffsetType_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
bool CombOffsetType_IsValid(int value);
constexpr CombOffsetType CombOffsetType_MIN = INVALID;
constexpr CombOffsetType CombOffsetType_MAX = CLOSE_TODAY;
constexpr int CombOffsetType_ARRAYSIZE = CombOffsetType_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* CombOffsetType_descriptor();
template<typename T>
inline const std::string& CombOffsetType_Name(T enum_t_value) {
  static_assert(::std::is_same<T, CombOffsetType>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function CombOffsetType_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    CombOffsetType_descriptor(), enum_t_value);
}
inline bool CombOffsetType_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, CombOffsetType* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<CombOffsetType>(
    CombOffsetType_descriptor(), name, value);
}
// ===================================================================

class message final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:strategy_trader.message) */ {
 public:
  inline message() : message(nullptr) {}
  ~message() override;
  explicit PROTOBUF_CONSTEXPR message(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  message(const message& from);
  message(message&& from) noexcept
    : message() {
    *this = ::std::move(from);
  }

  inline message& operator=(const message& from) {
    CopyFrom(from);
    return *this;
  }
  inline message& operator=(message&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const message& default_instance() {
    return *internal_default_instance();
  }
  enum MessageTypeCase {
    kOrderInsertReq = 1,
    kOrderInsertRsp = 2,
    kAccountStatusRsp = 3,
    kOrderCancelReq = 4,
    kOrderCancelRsp = 5,
    kTransactionCostReq = 6,
    kCommissionRateRsp = 7,
    kMarginRateRsp = 8,
    kAccountSetRsp = 9,
    kActiveReq = 10,
    kActiveRsp = 11,
    kStrategyAliveReq = 12,
    kStrategyAliveRsp = 13,
    kTraderAliveReq = 14,
    kTraderAliveRsp = 15,
    kPositionReq = 16,
    kPositionRsp = 17,
    kGroupSizeReq = 18,
    kGroupSizeRsp = 19,
    MESSAGETYPE_NOT_SET = 0,
  };

  static inline const message* internal_default_instance() {
    return reinterpret_cast<const message*>(
               &_message_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  friend void swap(message& a, message& b) {
    a.Swap(&b);
  }
  inline void Swap(message* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(message* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  message* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<message>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const message& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const message& from) {
    message::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(message* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "strategy_trader.message";
  }
  protected:
  explicit message(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kOrderInsertReqFieldNumber = 1,
    kOrderInsertRspFieldNumber = 2,
    kAccountStatusRspFieldNumber = 3,
    kOrderCancelReqFieldNumber = 4,
    kOrderCancelRspFieldNumber = 5,
    kTransactionCostReqFieldNumber = 6,
    kCommissionRateRspFieldNumber = 7,
    kMarginRateRspFieldNumber = 8,
    kAccountSetRspFieldNumber = 9,
    kActiveReqFieldNumber = 10,
    kActiveRspFieldNumber = 11,
    kStrategyAliveReqFieldNumber = 12,
    kStrategyAliveRspFieldNumber = 13,
    kTraderAliveReqFieldNumber = 14,
    kTraderAliveRspFieldNumber = 15,
    kPositionReqFieldNumber = 16,
    kPositionRspFieldNumber = 17,
    kGroupSizeReqFieldNumber = 18,
    kGroupSizeRspFieldNumber = 19,
  };
  // .strategy_trader.OrderInsertReq order_insert_req = 1;
  bool has_order_insert_req() const;
  private:
  bool _internal_has_order_insert_req() const;
  public:
  void clear_order_insert_req();
  const ::strategy_trader::OrderInsertReq& order_insert_req() const;
  PROTOBUF_NODISCARD ::strategy_trader::OrderInsertReq* release_order_insert_req();
  ::strategy_trader::OrderInsertReq* mutable_order_insert_req();
  void set_allocated_order_insert_req(::strategy_trader::OrderInsertReq* order_insert_req);
  private:
  const ::strategy_trader::OrderInsertReq& _internal_order_insert_req() const;
  ::strategy_trader::OrderInsertReq* _internal_mutable_order_insert_req();
  public:
  void unsafe_arena_set_allocated_order_insert_req(
      ::strategy_trader::OrderInsertReq* order_insert_req);
  ::strategy_trader::OrderInsertReq* unsafe_arena_release_order_insert_req();

  // .strategy_trader.OrderInsertRsp order_insert_rsp = 2;
  bool has_order_insert_rsp() const;
  private:
  bool _internal_has_order_insert_rsp() const;
  public:
  void clear_order_insert_rsp();
  const ::strategy_trader::OrderInsertRsp& order_insert_rsp() const;
  PROTOBUF_NODISCARD ::strategy_trader::OrderInsertRsp* release_order_insert_rsp();
  ::strategy_trader::OrderInsertRsp* mutable_order_insert_rsp();
  void set_allocated_order_insert_rsp(::strategy_trader::OrderInsertRsp* order_insert_rsp);
  private:
  const ::strategy_trader::OrderInsertRsp& _internal_order_insert_rsp() const;
  ::strategy_trader::OrderInsertRsp* _internal_mutable_order_insert_rsp();
  public:
  void unsafe_arena_set_allocated_order_insert_rsp(
      ::strategy_trader::OrderInsertRsp* order_insert_rsp);
  ::strategy_trader::OrderInsertRsp* unsafe_arena_release_order_insert_rsp();

  // .strategy_trader.AccountStatusRsp account_status_rsp = 3;
  bool has_account_status_rsp() const;
  private:
  bool _internal_has_account_status_rsp() const;
  public:
  void clear_account_status_rsp();
  const ::strategy_trader::AccountStatusRsp& account_status_rsp() const;
  PROTOBUF_NODISCARD ::strategy_trader::AccountStatusRsp* release_account_status_rsp();
  ::strategy_trader::AccountStatusRsp* mutable_account_status_rsp();
  void set_allocated_account_status_rsp(::strategy_trader::AccountStatusRsp* account_status_rsp);
  private:
  const ::strategy_trader::AccountStatusRsp& _internal_account_status_rsp() const;
  ::strategy_trader::AccountStatusRsp* _internal_mutable_account_status_rsp();
  public:
  void unsafe_arena_set_allocated_account_status_rsp(
      ::strategy_trader::AccountStatusRsp* account_status_rsp);
  ::strategy_trader::AccountStatusRsp* unsafe_arena_release_account_status_rsp();

  // .strategy_trader.OrderCancelReq order_cancel_req = 4;
  bool has_order_cancel_req() const;
  private:
  bool _internal_has_order_cancel_req() const;
  public:
  void clear_order_cancel_req();
  const ::strategy_trader::OrderCancelReq& order_cancel_req() const;
  PROTOBUF_NODISCARD ::strategy_trader::OrderCancelReq* release_order_cancel_req();
  ::strategy_trader::OrderCancelReq* mutable_order_cancel_req();
  void set_allocated_order_cancel_req(::strategy_trader::OrderCancelReq* order_cancel_req);
  private:
  const ::strategy_trader::OrderCancelReq& _internal_order_cancel_req() const;
  ::strategy_trader::OrderCancelReq* _internal_mutable_order_cancel_req();
  public:
  void unsafe_arena_set_allocated_order_cancel_req(
      ::strategy_trader::OrderCancelReq* order_cancel_req);
  ::strategy_trader::OrderCancelReq* unsafe_arena_release_order_cancel_req();

  // .strategy_trader.OrderCancelRsp order_cancel_rsp = 5;
  bool has_order_cancel_rsp() const;
  private:
  bool _internal_has_order_cancel_rsp() const;
  public:
  void clear_order_cancel_rsp();
  const ::strategy_trader::OrderCancelRsp& order_cancel_rsp() const;
  PROTOBUF_NODISCARD ::strategy_trader::OrderCancelRsp* release_order_cancel_rsp();
  ::strategy_trader::OrderCancelRsp* mutable_order_cancel_rsp();
  void set_allocated_order_cancel_rsp(::strategy_trader::OrderCancelRsp* order_cancel_rsp);
  private:
  const ::strategy_trader::OrderCancelRsp& _internal_order_cancel_rsp() const;
  ::strategy_trader::OrderCancelRsp* _internal_mutable_order_cancel_rsp();
  public:
  void unsafe_arena_set_allocated_order_cancel_rsp(
      ::strategy_trader::OrderCancelRsp* order_cancel_rsp);
  ::strategy_trader::OrderCancelRsp* unsafe_arena_release_order_cancel_rsp();

  // .strategy_trader.TransactionCostReq transaction_cost_req = 6;
  bool has_transaction_cost_req() const;
  private:
  bool _internal_has_transaction_cost_req() const;
  public:
  void clear_transaction_cost_req();
  const ::strategy_trader::TransactionCostReq& transaction_cost_req() const;
  PROTOBUF_NODISCARD ::strategy_trader::TransactionCostReq* release_transaction_cost_req();
  ::strategy_trader::TransactionCostReq* mutable_transaction_cost_req();
  void set_allocated_transaction_cost_req(::strategy_trader::TransactionCostReq* transaction_cost_req);
  private:
  const ::strategy_trader::TransactionCostReq& _internal_transaction_cost_req() const;
  ::strategy_trader::TransactionCostReq* _internal_mutable_transaction_cost_req();
  public:
  void unsafe_arena_set_allocated_transaction_cost_req(
      ::strategy_trader::TransactionCostReq* transaction_cost_req);
  ::strategy_trader::TransactionCostReq* unsafe_arena_release_transaction_cost_req();

  // .strategy_trader.CommissionRateRsp commission_rate_rsp = 7;
  bool has_commission_rate_rsp() const;
  private:
  bool _internal_has_commission_rate_rsp() const;
  public:
  void clear_commission_rate_rsp();
  const ::strategy_trader::CommissionRateRsp& commission_rate_rsp() const;
  PROTOBUF_NODISCARD ::strategy_trader::CommissionRateRsp* release_commission_rate_rsp();
  ::strategy_trader::CommissionRateRsp* mutable_commission_rate_rsp();
  void set_allocated_commission_rate_rsp(::strategy_trader::CommissionRateRsp* commission_rate_rsp);
  private:
  const ::strategy_trader::CommissionRateRsp& _internal_commission_rate_rsp() const;
  ::strategy_trader::CommissionRateRsp* _internal_mutable_commission_rate_rsp();
  public:
  void unsafe_arena_set_allocated_commission_rate_rsp(
      ::strategy_trader::CommissionRateRsp* commission_rate_rsp);
  ::strategy_trader::CommissionRateRsp* unsafe_arena_release_commission_rate_rsp();

  // .strategy_trader.MarginRateRsp margin_rate_rsp = 8;
  bool has_margin_rate_rsp() const;
  private:
  bool _internal_has_margin_rate_rsp() const;
  public:
  void clear_margin_rate_rsp();
  const ::strategy_trader::MarginRateRsp& margin_rate_rsp() const;
  PROTOBUF_NODISCARD ::strategy_trader::MarginRateRsp* release_margin_rate_rsp();
  ::strategy_trader::MarginRateRsp* mutable_margin_rate_rsp();
  void set_allocated_margin_rate_rsp(::strategy_trader::MarginRateRsp* margin_rate_rsp);
  private:
  const ::strategy_trader::MarginRateRsp& _internal_margin_rate_rsp() const;
  ::strategy_trader::MarginRateRsp* _internal_mutable_margin_rate_rsp();
  public:
  void unsafe_arena_set_allocated_margin_rate_rsp(
      ::strategy_trader::MarginRateRsp* margin_rate_rsp);
  ::strategy_trader::MarginRateRsp* unsafe_arena_release_margin_rate_rsp();

  // .strategy_trader.AccountSetRsp account_set_rsp = 9;
  bool has_account_set_rsp() const;
  private:
  bool _internal_has_account_set_rsp() const;
  public:
  void clear_account_set_rsp();
  const ::strategy_trader::AccountSetRsp& account_set_rsp() const;
  PROTOBUF_NODISCARD ::strategy_trader::AccountSetRsp* release_account_set_rsp();
  ::strategy_trader::AccountSetRsp* mutable_account_set_rsp();
  void set_allocated_account_set_rsp(::strategy_trader::AccountSetRsp* account_set_rsp);
  private:
  const ::strategy_trader::AccountSetRsp& _internal_account_set_rsp() const;
  ::strategy_trader::AccountSetRsp* _internal_mutable_account_set_rsp();
  public:
  void unsafe_arena_set_allocated_account_set_rsp(
      ::strategy_trader::AccountSetRsp* account_set_rsp);
  ::strategy_trader::AccountSetRsp* unsafe_arena_release_account_set_rsp();

  // .strategy_trader.ActiveSafetyReq active_req = 10;
  bool has_active_req() const;
  private:
  bool _internal_has_active_req() const;
  public:
  void clear_active_req();
  const ::strategy_trader::ActiveSafetyReq& active_req() const;
  PROTOBUF_NODISCARD ::strategy_trader::ActiveSafetyReq* release_active_req();
  ::strategy_trader::ActiveSafetyReq* mutable_active_req();
  void set_allocated_active_req(::strategy_trader::ActiveSafetyReq* active_req);
  private:
  const ::strategy_trader::ActiveSafetyReq& _internal_active_req() const;
  ::strategy_trader::ActiveSafetyReq* _internal_mutable_active_req();
  public:
  void unsafe_arena_set_allocated_active_req(
      ::strategy_trader::ActiveSafetyReq* active_req);
  ::strategy_trader::ActiveSafetyReq* unsafe_arena_release_active_req();

  // .strategy_trader.ActiveSafetyRsp active_rsp = 11;
  bool has_active_rsp() const;
  private:
  bool _internal_has_active_rsp() const;
  public:
  void clear_active_rsp();
  const ::strategy_trader::ActiveSafetyRsp& active_rsp() const;
  PROTOBUF_NODISCARD ::strategy_trader::ActiveSafetyRsp* release_active_rsp();
  ::strategy_trader::ActiveSafetyRsp* mutable_active_rsp();
  void set_allocated_active_rsp(::strategy_trader::ActiveSafetyRsp* active_rsp);
  private:
  const ::strategy_trader::ActiveSafetyRsp& _internal_active_rsp() const;
  ::strategy_trader::ActiveSafetyRsp* _internal_mutable_active_rsp();
  public:
  void unsafe_arena_set_allocated_active_rsp(
      ::strategy_trader::ActiveSafetyRsp* active_rsp);
  ::strategy_trader::ActiveSafetyRsp* unsafe_arena_release_active_rsp();

  // .strategy_trader.CheckStrategyAliveReq strategy_alive_req = 12;
  bool has_strategy_alive_req() const;
  private:
  bool _internal_has_strategy_alive_req() const;
  public:
  void clear_strategy_alive_req();
  const ::strategy_trader::CheckStrategyAliveReq& strategy_alive_req() const;
  PROTOBUF_NODISCARD ::strategy_trader::CheckStrategyAliveReq* release_strategy_alive_req();
  ::strategy_trader::CheckStrategyAliveReq* mutable_strategy_alive_req();
  void set_allocated_strategy_alive_req(::strategy_trader::CheckStrategyAliveReq* strategy_alive_req);
  private:
  const ::strategy_trader::CheckStrategyAliveReq& _internal_strategy_alive_req() const;
  ::strategy_trader::CheckStrategyAliveReq* _internal_mutable_strategy_alive_req();
  public:
  void unsafe_arena_set_allocated_strategy_alive_req(
      ::strategy_trader::CheckStrategyAliveReq* strategy_alive_req);
  ::strategy_trader::CheckStrategyAliveReq* unsafe_arena_release_strategy_alive_req();

  // .strategy_trader.CheckStrategyAliveRsp strategy_alive_rsp = 13;
  bool has_strategy_alive_rsp() const;
  private:
  bool _internal_has_strategy_alive_rsp() const;
  public:
  void clear_strategy_alive_rsp();
  const ::strategy_trader::CheckStrategyAliveRsp& strategy_alive_rsp() const;
  PROTOBUF_NODISCARD ::strategy_trader::CheckStrategyAliveRsp* release_strategy_alive_rsp();
  ::strategy_trader::CheckStrategyAliveRsp* mutable_strategy_alive_rsp();
  void set_allocated_strategy_alive_rsp(::strategy_trader::CheckStrategyAliveRsp* strategy_alive_rsp);
  private:
  const ::strategy_trader::CheckStrategyAliveRsp& _internal_strategy_alive_rsp() const;
  ::strategy_trader::CheckStrategyAliveRsp* _internal_mutable_strategy_alive_rsp();
  public:
  void unsafe_arena_set_allocated_strategy_alive_rsp(
      ::strategy_trader::CheckStrategyAliveRsp* strategy_alive_rsp);
  ::strategy_trader::CheckStrategyAliveRsp* unsafe_arena_release_strategy_alive_rsp();

  // .strategy_trader.CheckTraderAliveReq trader_alive_req = 14;
  bool has_trader_alive_req() const;
  private:
  bool _internal_has_trader_alive_req() const;
  public:
  void clear_trader_alive_req();
  const ::strategy_trader::CheckTraderAliveReq& trader_alive_req() const;
  PROTOBUF_NODISCARD ::strategy_trader::CheckTraderAliveReq* release_trader_alive_req();
  ::strategy_trader::CheckTraderAliveReq* mutable_trader_alive_req();
  void set_allocated_trader_alive_req(::strategy_trader::CheckTraderAliveReq* trader_alive_req);
  private:
  const ::strategy_trader::CheckTraderAliveReq& _internal_trader_alive_req() const;
  ::strategy_trader::CheckTraderAliveReq* _internal_mutable_trader_alive_req();
  public:
  void unsafe_arena_set_allocated_trader_alive_req(
      ::strategy_trader::CheckTraderAliveReq* trader_alive_req);
  ::strategy_trader::CheckTraderAliveReq* unsafe_arena_release_trader_alive_req();

  // .strategy_trader.CheckTraderAliveRsp trader_alive_rsp = 15;
  bool has_trader_alive_rsp() const;
  private:
  bool _internal_has_trader_alive_rsp() const;
  public:
  void clear_trader_alive_rsp();
  const ::strategy_trader::CheckTraderAliveRsp& trader_alive_rsp() const;
  PROTOBUF_NODISCARD ::strategy_trader::CheckTraderAliveRsp* release_trader_alive_rsp();
  ::strategy_trader::CheckTraderAliveRsp* mutable_trader_alive_rsp();
  void set_allocated_trader_alive_rsp(::strategy_trader::CheckTraderAliveRsp* trader_alive_rsp);
  private:
  const ::strategy_trader::CheckTraderAliveRsp& _internal_trader_alive_rsp() const;
  ::strategy_trader::CheckTraderAliveRsp* _internal_mutable_trader_alive_rsp();
  public:
  void unsafe_arena_set_allocated_trader_alive_rsp(
      ::strategy_trader::CheckTraderAliveRsp* trader_alive_rsp);
  ::strategy_trader::CheckTraderAliveRsp* unsafe_arena_release_trader_alive_rsp();

  // .strategy_trader.OrderPositionReq position_req = 16;
  bool has_position_req() const;
  private:
  bool _internal_has_position_req() const;
  public:
  void clear_position_req();
  const ::strategy_trader::OrderPositionReq& position_req() const;
  PROTOBUF_NODISCARD ::strategy_trader::OrderPositionReq* release_position_req();
  ::strategy_trader::OrderPositionReq* mutable_position_req();
  void set_allocated_position_req(::strategy_trader::OrderPositionReq* position_req);
  private:
  const ::strategy_trader::OrderPositionReq& _internal_position_req() const;
  ::strategy_trader::OrderPositionReq* _internal_mutable_position_req();
  public:
  void unsafe_arena_set_allocated_position_req(
      ::strategy_trader::OrderPositionReq* position_req);
  ::strategy_trader::OrderPositionReq* unsafe_arena_release_position_req();

  // .strategy_trader.OrderPositionRsp position_rsp = 17;
  bool has_position_rsp() const;
  private:
  bool _internal_has_position_rsp() const;
  public:
  void clear_position_rsp();
  const ::strategy_trader::OrderPositionRsp& position_rsp() const;
  PROTOBUF_NODISCARD ::strategy_trader::OrderPositionRsp* release_position_rsp();
  ::strategy_trader::OrderPositionRsp* mutable_position_rsp();
  void set_allocated_position_rsp(::strategy_trader::OrderPositionRsp* position_rsp);
  private:
  const ::strategy_trader::OrderPositionRsp& _internal_position_rsp() const;
  ::strategy_trader::OrderPositionRsp* _internal_mutable_position_rsp();
  public:
  void unsafe_arena_set_allocated_position_rsp(
      ::strategy_trader::OrderPositionRsp* position_rsp);
  ::strategy_trader::OrderPositionRsp* unsafe_arena_release_position_rsp();

  // .strategy_trader.GroupSizeReq group_size_req = 18;
  bool has_group_size_req() const;
  private:
  bool _internal_has_group_size_req() const;
  public:
  void clear_group_size_req();
  const ::strategy_trader::GroupSizeReq& group_size_req() const;
  PROTOBUF_NODISCARD ::strategy_trader::GroupSizeReq* release_group_size_req();
  ::strategy_trader::GroupSizeReq* mutable_group_size_req();
  void set_allocated_group_size_req(::strategy_trader::GroupSizeReq* group_size_req);
  private:
  const ::strategy_trader::GroupSizeReq& _internal_group_size_req() const;
  ::strategy_trader::GroupSizeReq* _internal_mutable_group_size_req();
  public:
  void unsafe_arena_set_allocated_group_size_req(
      ::strategy_trader::GroupSizeReq* group_size_req);
  ::strategy_trader::GroupSizeReq* unsafe_arena_release_group_size_req();

  // .strategy_trader.GroupSizeRsp group_size_rsp = 19;
  bool has_group_size_rsp() const;
  private:
  bool _internal_has_group_size_rsp() const;
  public:
  void clear_group_size_rsp();
  const ::strategy_trader::GroupSizeRsp& group_size_rsp() const;
  PROTOBUF_NODISCARD ::strategy_trader::GroupSizeRsp* release_group_size_rsp();
  ::strategy_trader::GroupSizeRsp* mutable_group_size_rsp();
  void set_allocated_group_size_rsp(::strategy_trader::GroupSizeRsp* group_size_rsp);
  private:
  const ::strategy_trader::GroupSizeRsp& _internal_group_size_rsp() const;
  ::strategy_trader::GroupSizeRsp* _internal_mutable_group_size_rsp();
  public:
  void unsafe_arena_set_allocated_group_size_rsp(
      ::strategy_trader::GroupSizeRsp* group_size_rsp);
  ::strategy_trader::GroupSizeRsp* unsafe_arena_release_group_size_rsp();

  void clear_MessageType();
  MessageTypeCase MessageType_case() const;
  // @@protoc_insertion_point(class_scope:strategy_trader.message)
 private:
  class _Internal;
  void set_has_order_insert_req();
  void set_has_order_insert_rsp();
  void set_has_account_status_rsp();
  void set_has_order_cancel_req();
  void set_has_order_cancel_rsp();
  void set_has_transaction_cost_req();
  void set_has_commission_rate_rsp();
  void set_has_margin_rate_rsp();
  void set_has_account_set_rsp();
  void set_has_active_req();
  void set_has_active_rsp();
  void set_has_strategy_alive_req();
  void set_has_strategy_alive_rsp();
  void set_has_trader_alive_req();
  void set_has_trader_alive_rsp();
  void set_has_position_req();
  void set_has_position_rsp();
  void set_has_group_size_req();
  void set_has_group_size_rsp();

  inline bool has_MessageType() const;
  inline void clear_has_MessageType();

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    union MessageTypeUnion {
      constexpr MessageTypeUnion() : _constinit_{} {}
        ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized _constinit_;
      ::strategy_trader::OrderInsertReq* order_insert_req_;
      ::strategy_trader::OrderInsertRsp* order_insert_rsp_;
      ::strategy_trader::AccountStatusRsp* account_status_rsp_;
      ::strategy_trader::OrderCancelReq* order_cancel_req_;
      ::strategy_trader::OrderCancelRsp* order_cancel_rsp_;
      ::strategy_trader::TransactionCostReq* transaction_cost_req_;
      ::strategy_trader::CommissionRateRsp* commission_rate_rsp_;
      ::strategy_trader::MarginRateRsp* margin_rate_rsp_;
      ::strategy_trader::AccountSetRsp* account_set_rsp_;
      ::strategy_trader::ActiveSafetyReq* active_req_;
      ::strategy_trader::ActiveSafetyRsp* active_rsp_;
      ::strategy_trader::CheckStrategyAliveReq* strategy_alive_req_;
      ::strategy_trader::CheckStrategyAliveRsp* strategy_alive_rsp_;
      ::strategy_trader::CheckTraderAliveReq* trader_alive_req_;
      ::strategy_trader::CheckTraderAliveRsp* trader_alive_rsp_;
      ::strategy_trader::OrderPositionReq* position_req_;
      ::strategy_trader::OrderPositionRsp* position_rsp_;
      ::strategy_trader::GroupSizeReq* group_size_req_;
      ::strategy_trader::GroupSizeRsp* group_size_rsp_;
    } MessageType_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    uint32_t _oneof_case_[1];

  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_strategy_2dtrader_2eproto;
};
// -------------------------------------------------------------------

class OrderCancelReq final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:strategy_trader.OrderCancelReq) */ {
 public:
  inline OrderCancelReq() : OrderCancelReq(nullptr) {}
  ~OrderCancelReq() override;
  explicit PROTOBUF_CONSTEXPR OrderCancelReq(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  OrderCancelReq(const OrderCancelReq& from);
  OrderCancelReq(OrderCancelReq&& from) noexcept
    : OrderCancelReq() {
    *this = ::std::move(from);
  }

  inline OrderCancelReq& operator=(const OrderCancelReq& from) {
    CopyFrom(from);
    return *this;
  }
  inline OrderCancelReq& operator=(OrderCancelReq&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const OrderCancelReq& default_instance() {
    return *internal_default_instance();
  }
  static inline const OrderCancelReq* internal_default_instance() {
    return reinterpret_cast<const OrderCancelReq*>(
               &_OrderCancelReq_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  friend void swap(OrderCancelReq& a, OrderCancelReq& b) {
    a.Swap(&b);
  }
  inline void Swap(OrderCancelReq* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(OrderCancelReq* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  OrderCancelReq* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<OrderCancelReq>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const OrderCancelReq& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const OrderCancelReq& from) {
    OrderCancelReq::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(OrderCancelReq* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "strategy_trader.OrderCancelReq";
  }
  protected:
  explicit OrderCancelReq(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kInstrumentFieldNumber = 1,
    kIndexFieldNumber = 2,
  };
  // string instrument = 1;
  void clear_instrument();
  const std::string& instrument() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_instrument(ArgT0&& arg0, ArgT... args);
  std::string* mutable_instrument();
  PROTOBUF_NODISCARD std::string* release_instrument();
  void set_allocated_instrument(std::string* instrument);
  private:
  const std::string& _internal_instrument() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_instrument(const std::string& value);
  std::string* _internal_mutable_instrument();
  public:

  // string index = 2;
  void clear_index();
  const std::string& index() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_index(ArgT0&& arg0, ArgT... args);
  std::string* mutable_index();
  PROTOBUF_NODISCARD std::string* release_index();
  void set_allocated_index(std::string* index);
  private:
  const std::string& _internal_index() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_index(const std::string& value);
  std::string* _internal_mutable_index();
  public:

  // @@protoc_insertion_point(class_scope:strategy_trader.OrderCancelReq)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr instrument_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr index_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_strategy_2dtrader_2eproto;
};
// -------------------------------------------------------------------

class OrderCancelRsp final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:strategy_trader.OrderCancelRsp) */ {
 public:
  inline OrderCancelRsp() : OrderCancelRsp(nullptr) {}
  ~OrderCancelRsp() override;
  explicit PROTOBUF_CONSTEXPR OrderCancelRsp(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  OrderCancelRsp(const OrderCancelRsp& from);
  OrderCancelRsp(OrderCancelRsp&& from) noexcept
    : OrderCancelRsp() {
    *this = ::std::move(from);
  }

  inline OrderCancelRsp& operator=(const OrderCancelRsp& from) {
    CopyFrom(from);
    return *this;
  }
  inline OrderCancelRsp& operator=(OrderCancelRsp&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const OrderCancelRsp& default_instance() {
    return *internal_default_instance();
  }
  static inline const OrderCancelRsp* internal_default_instance() {
    return reinterpret_cast<const OrderCancelRsp*>(
               &_OrderCancelRsp_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  friend void swap(OrderCancelRsp& a, OrderCancelRsp& b) {
    a.Swap(&b);
  }
  inline void Swap(OrderCancelRsp* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(OrderCancelRsp* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  OrderCancelRsp* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<OrderCancelRsp>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const OrderCancelRsp& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const OrderCancelRsp& from) {
    OrderCancelRsp::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(OrderCancelRsp* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "strategy_trader.OrderCancelRsp";
  }
  protected:
  explicit OrderCancelRsp(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kInstrumentFieldNumber = 1,
    kIndexFieldNumber = 2,
    kFailedReasonFieldNumber = 5,
    kInfoFieldNumber = 4,
    kResultFieldNumber = 3,
  };
  // string instrument = 1;
  void clear_instrument();
  const std::string& instrument() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_instrument(ArgT0&& arg0, ArgT... args);
  std::string* mutable_instrument();
  PROTOBUF_NODISCARD std::string* release_instrument();
  void set_allocated_instrument(std::string* instrument);
  private:
  const std::string& _internal_instrument() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_instrument(const std::string& value);
  std::string* _internal_mutable_instrument();
  public:

  // string index = 2;
  void clear_index();
  const std::string& index() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_index(ArgT0&& arg0, ArgT... args);
  std::string* mutable_index();
  PROTOBUF_NODISCARD std::string* release_index();
  void set_allocated_index(std::string* index);
  private:
  const std::string& _internal_index() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_index(const std::string& value);
  std::string* _internal_mutable_index();
  public:

  // string failedReason = 5;
  void clear_failedreason();
  const std::string& failedreason() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_failedreason(ArgT0&& arg0, ArgT... args);
  std::string* mutable_failedreason();
  PROTOBUF_NODISCARD std::string* release_failedreason();
  void set_allocated_failedreason(std::string* failedreason);
  private:
  const std::string& _internal_failedreason() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_failedreason(const std::string& value);
  std::string* _internal_mutable_failedreason();
  public:

  // .strategy_trader.RspInfo info = 4;
  bool has_info() const;
  private:
  bool _internal_has_info() const;
  public:
  void clear_info();
  const ::strategy_trader::RspInfo& info() const;
  PROTOBUF_NODISCARD ::strategy_trader::RspInfo* release_info();
  ::strategy_trader::RspInfo* mutable_info();
  void set_allocated_info(::strategy_trader::RspInfo* info);
  private:
  const ::strategy_trader::RspInfo& _internal_info() const;
  ::strategy_trader::RspInfo* _internal_mutable_info();
  public:
  void unsafe_arena_set_allocated_info(
      ::strategy_trader::RspInfo* info);
  ::strategy_trader::RspInfo* unsafe_arena_release_info();

  // .strategy_trader.Result result = 3;
  void clear_result();
  ::strategy_trader::Result result() const;
  void set_result(::strategy_trader::Result value);
  private:
  ::strategy_trader::Result _internal_result() const;
  void _internal_set_result(::strategy_trader::Result value);
  public:

  // @@protoc_insertion_point(class_scope:strategy_trader.OrderCancelRsp)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr instrument_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr index_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr failedreason_;
    ::strategy_trader::RspInfo* info_;
    int result_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_strategy_2dtrader_2eproto;
};
// -------------------------------------------------------------------

class AccountStatusRsp final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:strategy_trader.AccountStatusRsp) */ {
 public:
  inline AccountStatusRsp() : AccountStatusRsp(nullptr) {}
  ~AccountStatusRsp() override;
  explicit PROTOBUF_CONSTEXPR AccountStatusRsp(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  AccountStatusRsp(const AccountStatusRsp& from);
  AccountStatusRsp(AccountStatusRsp&& from) noexcept
    : AccountStatusRsp() {
    *this = ::std::move(from);
  }

  inline AccountStatusRsp& operator=(const AccountStatusRsp& from) {
    CopyFrom(from);
    return *this;
  }
  inline AccountStatusRsp& operator=(AccountStatusRsp&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const AccountStatusRsp& default_instance() {
    return *internal_default_instance();
  }
  static inline const AccountStatusRsp* internal_default_instance() {
    return reinterpret_cast<const AccountStatusRsp*>(
               &_AccountStatusRsp_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  friend void swap(AccountStatusRsp& a, AccountStatusRsp& b) {
    a.Swap(&b);
  }
  inline void Swap(AccountStatusRsp* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(AccountStatusRsp* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  AccountStatusRsp* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<AccountStatusRsp>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const AccountStatusRsp& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const AccountStatusRsp& from) {
    AccountStatusRsp::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(AccountStatusRsp* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "strategy_trader.AccountStatusRsp";
  }
  protected:
  explicit AccountStatusRsp(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kUserIdFieldNumber = 1,
    kFailedReasonFieldNumber = 6,
    kBalanceFieldNumber = 2,
    kAvailableFieldNumber = 3,
    kSessionIdFieldNumber = 4,
    kResultFieldNumber = 5,
  };
  // string user_id = 1;
  void clear_user_id();
  const std::string& user_id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_user_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_user_id();
  PROTOBUF_NODISCARD std::string* release_user_id();
  void set_allocated_user_id(std::string* user_id);
  private:
  const std::string& _internal_user_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_user_id(const std::string& value);
  std::string* _internal_mutable_user_id();
  public:

  // string failedReason = 6;
  void clear_failedreason();
  const std::string& failedreason() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_failedreason(ArgT0&& arg0, ArgT... args);
  std::string* mutable_failedreason();
  PROTOBUF_NODISCARD std::string* release_failedreason();
  void set_allocated_failedreason(std::string* failedreason);
  private:
  const std::string& _internal_failedreason() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_failedreason(const std::string& value);
  std::string* _internal_mutable_failedreason();
  public:

  // double Balance = 2;
  void clear_balance();
  double balance() const;
  void set_balance(double value);
  private:
  double _internal_balance() const;
  void _internal_set_balance(double value);
  public:

  // double Available = 3;
  void clear_available();
  double available() const;
  void set_available(double value);
  private:
  double _internal_available() const;
  void _internal_set_available(double value);
  public:

  // uint64 session_id = 4;
  void clear_session_id();
  uint64_t session_id() const;
  void set_session_id(uint64_t value);
  private:
  uint64_t _internal_session_id() const;
  void _internal_set_session_id(uint64_t value);
  public:

  // .strategy_trader.Result result = 5;
  void clear_result();
  ::strategy_trader::Result result() const;
  void set_result(::strategy_trader::Result value);
  private:
  ::strategy_trader::Result _internal_result() const;
  void _internal_set_result(::strategy_trader::Result value);
  public:

  // @@protoc_insertion_point(class_scope:strategy_trader.AccountStatusRsp)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr user_id_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr failedreason_;
    double balance_;
    double available_;
    uint64_t session_id_;
    int result_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_strategy_2dtrader_2eproto;
};
// -------------------------------------------------------------------

class OrderInsertRsp final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:strategy_trader.OrderInsertRsp) */ {
 public:
  inline OrderInsertRsp() : OrderInsertRsp(nullptr) {}
  ~OrderInsertRsp() override;
  explicit PROTOBUF_CONSTEXPR OrderInsertRsp(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  OrderInsertRsp(const OrderInsertRsp& from);
  OrderInsertRsp(OrderInsertRsp&& from) noexcept
    : OrderInsertRsp() {
    *this = ::std::move(from);
  }

  inline OrderInsertRsp& operator=(const OrderInsertRsp& from) {
    CopyFrom(from);
    return *this;
  }
  inline OrderInsertRsp& operator=(OrderInsertRsp&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const OrderInsertRsp& default_instance() {
    return *internal_default_instance();
  }
  static inline const OrderInsertRsp* internal_default_instance() {
    return reinterpret_cast<const OrderInsertRsp*>(
               &_OrderInsertRsp_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    4;

  friend void swap(OrderInsertRsp& a, OrderInsertRsp& b) {
    a.Swap(&b);
  }
  inline void Swap(OrderInsertRsp* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(OrderInsertRsp* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  OrderInsertRsp* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<OrderInsertRsp>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const OrderInsertRsp& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const OrderInsertRsp& from) {
    OrderInsertRsp::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(OrderInsertRsp* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "strategy_trader.OrderInsertRsp";
  }
  protected:
  explicit OrderInsertRsp(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kInstrumentFieldNumber = 1,
    kIndexFieldNumber = 2,
    kInfoFieldNumber = 4,
    kResultFieldNumber = 3,
    kReasonFieldNumber = 5,
  };
  // string instrument = 1;
  void clear_instrument();
  const std::string& instrument() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_instrument(ArgT0&& arg0, ArgT... args);
  std::string* mutable_instrument();
  PROTOBUF_NODISCARD std::string* release_instrument();
  void set_allocated_instrument(std::string* instrument);
  private:
  const std::string& _internal_instrument() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_instrument(const std::string& value);
  std::string* _internal_mutable_instrument();
  public:

  // string index = 2;
  void clear_index();
  const std::string& index() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_index(ArgT0&& arg0, ArgT... args);
  std::string* mutable_index();
  PROTOBUF_NODISCARD std::string* release_index();
  void set_allocated_index(std::string* index);
  private:
  const std::string& _internal_index() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_index(const std::string& value);
  std::string* _internal_mutable_index();
  public:

  // .strategy_trader.RspInfo info = 4;
  bool has_info() const;
  private:
  bool _internal_has_info() const;
  public:
  void clear_info();
  const ::strategy_trader::RspInfo& info() const;
  PROTOBUF_NODISCARD ::strategy_trader::RspInfo* release_info();
  ::strategy_trader::RspInfo* mutable_info();
  void set_allocated_info(::strategy_trader::RspInfo* info);
  private:
  const ::strategy_trader::RspInfo& _internal_info() const;
  ::strategy_trader::RspInfo* _internal_mutable_info();
  public:
  void unsafe_arena_set_allocated_info(
      ::strategy_trader::RspInfo* info);
  ::strategy_trader::RspInfo* unsafe_arena_release_info();

  // .strategy_trader.Result result = 3;
  void clear_result();
  ::strategy_trader::Result result() const;
  void set_result(::strategy_trader::Result value);
  private:
  ::strategy_trader::Result _internal_result() const;
  void _internal_set_result(::strategy_trader::Result value);
  public:

  // .strategy_trader.FailedReason reason = 5;
  void clear_reason();
  ::strategy_trader::FailedReason reason() const;
  void set_reason(::strategy_trader::FailedReason value);
  private:
  ::strategy_trader::FailedReason _internal_reason() const;
  void _internal_set_reason(::strategy_trader::FailedReason value);
  public:

  // @@protoc_insertion_point(class_scope:strategy_trader.OrderInsertRsp)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr instrument_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr index_;
    ::strategy_trader::RspInfo* info_;
    int result_;
    int reason_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_strategy_2dtrader_2eproto;
};
// -------------------------------------------------------------------

class OrderInsertReq final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:strategy_trader.OrderInsertReq) */ {
 public:
  inline OrderInsertReq() : OrderInsertReq(nullptr) {}
  ~OrderInsertReq() override;
  explicit PROTOBUF_CONSTEXPR OrderInsertReq(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  OrderInsertReq(const OrderInsertReq& from);
  OrderInsertReq(OrderInsertReq&& from) noexcept
    : OrderInsertReq() {
    *this = ::std::move(from);
  }

  inline OrderInsertReq& operator=(const OrderInsertReq& from) {
    CopyFrom(from);
    return *this;
  }
  inline OrderInsertReq& operator=(OrderInsertReq&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const OrderInsertReq& default_instance() {
    return *internal_default_instance();
  }
  static inline const OrderInsertReq* internal_default_instance() {
    return reinterpret_cast<const OrderInsertReq*>(
               &_OrderInsertReq_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    5;

  friend void swap(OrderInsertReq& a, OrderInsertReq& b) {
    a.Swap(&b);
  }
  inline void Swap(OrderInsertReq* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(OrderInsertReq* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  OrderInsertReq* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<OrderInsertReq>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const OrderInsertReq& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const OrderInsertReq& from) {
    OrderInsertReq::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(OrderInsertReq* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "strategy_trader.OrderInsertReq";
  }
  protected:
  explicit OrderInsertReq(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kInstrumentFieldNumber = 1,
    kIndexFieldNumber = 2,
    kOrderFieldNumber = 3,
  };
  // string instrument = 1;
  void clear_instrument();
  const std::string& instrument() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_instrument(ArgT0&& arg0, ArgT... args);
  std::string* mutable_instrument();
  PROTOBUF_NODISCARD std::string* release_instrument();
  void set_allocated_instrument(std::string* instrument);
  private:
  const std::string& _internal_instrument() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_instrument(const std::string& value);
  std::string* _internal_mutable_instrument();
  public:

  // string index = 2;
  void clear_index();
  const std::string& index() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_index(ArgT0&& arg0, ArgT... args);
  std::string* mutable_index();
  PROTOBUF_NODISCARD std::string* release_index();
  void set_allocated_index(std::string* index);
  private:
  const std::string& _internal_index() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_index(const std::string& value);
  std::string* _internal_mutable_index();
  public:

  // .strategy_trader.Order order = 3;
  bool has_order() const;
  private:
  bool _internal_has_order() const;
  public:
  void clear_order();
  const ::strategy_trader::Order& order() const;
  PROTOBUF_NODISCARD ::strategy_trader::Order* release_order();
  ::strategy_trader::Order* mutable_order();
  void set_allocated_order(::strategy_trader::Order* order);
  private:
  const ::strategy_trader::Order& _internal_order() const;
  ::strategy_trader::Order* _internal_mutable_order();
  public:
  void unsafe_arena_set_allocated_order(
      ::strategy_trader::Order* order);
  ::strategy_trader::Order* unsafe_arena_release_order();

  // @@protoc_insertion_point(class_scope:strategy_trader.OrderInsertReq)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr instrument_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr index_;
    ::strategy_trader::Order* order_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_strategy_2dtrader_2eproto;
};
// -------------------------------------------------------------------

class RspInfo final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:strategy_trader.RspInfo) */ {
 public:
  inline RspInfo() : RspInfo(nullptr) {}
  ~RspInfo() override;
  explicit PROTOBUF_CONSTEXPR RspInfo(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  RspInfo(const RspInfo& from);
  RspInfo(RspInfo&& from) noexcept
    : RspInfo() {
    *this = ::std::move(from);
  }

  inline RspInfo& operator=(const RspInfo& from) {
    CopyFrom(from);
    return *this;
  }
  inline RspInfo& operator=(RspInfo&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const RspInfo& default_instance() {
    return *internal_default_instance();
  }
  static inline const RspInfo* internal_default_instance() {
    return reinterpret_cast<const RspInfo*>(
               &_RspInfo_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    6;

  friend void swap(RspInfo& a, RspInfo& b) {
    a.Swap(&b);
  }
  inline void Swap(RspInfo* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(RspInfo* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  RspInfo* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<RspInfo>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const RspInfo& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const RspInfo& from) {
    RspInfo::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(RspInfo* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "strategy_trader.RspInfo";
  }
  protected:
  explicit RspInfo(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kOrderPriceFieldNumber = 1,
    kOrderVolumeFieldNumber = 2,
  };
  // double orderPrice = 1;
  void clear_orderprice();
  double orderprice() const;
  void set_orderprice(double value);
  private:
  double _internal_orderprice() const;
  void _internal_set_orderprice(double value);
  public:

  // uint32 orderVolume = 2;
  void clear_ordervolume();
  uint32_t ordervolume() const;
  void set_ordervolume(uint32_t value);
  private:
  uint32_t _internal_ordervolume() const;
  void _internal_set_ordervolume(uint32_t value);
  public:

  // @@protoc_insertion_point(class_scope:strategy_trader.RspInfo)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    double orderprice_;
    uint32_t ordervolume_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_strategy_2dtrader_2eproto;
};
// -------------------------------------------------------------------

class Order final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:strategy_trader.Order) */ {
 public:
  inline Order() : Order(nullptr) {}
  ~Order() override;
  explicit PROTOBUF_CONSTEXPR Order(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Order(const Order& from);
  Order(Order&& from) noexcept
    : Order() {
    *this = ::std::move(from);
  }

  inline Order& operator=(const Order& from) {
    CopyFrom(from);
    return *this;
  }
  inline Order& operator=(Order&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Order& default_instance() {
    return *internal_default_instance();
  }
  static inline const Order* internal_default_instance() {
    return reinterpret_cast<const Order*>(
               &_Order_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    7;

  friend void swap(Order& a, Order& b) {
    a.Swap(&b);
  }
  inline void Swap(Order* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Order* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Order* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Order>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Order& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const Order& from) {
    Order::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Order* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "strategy_trader.Order";
  }
  protected:
  explicit Order(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kInstrumentFieldNumber = 1,
    kExchangeIdFieldNumber = 2,
    kLimitPriceFieldNumber = 4,
    kDirectionFieldNumber = 3,
    kOnceVolumeFieldNumber = 5,
    kCombOffsetFlagFieldNumber = 6,
    kHoldVolumeFieldNumber = 7,
    kOrderTypeFieldNumber = 8,
  };
  // string instrument = 1;
  void clear_instrument();
  const std::string& instrument() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_instrument(ArgT0&& arg0, ArgT... args);
  std::string* mutable_instrument();
  PROTOBUF_NODISCARD std::string* release_instrument();
  void set_allocated_instrument(std::string* instrument);
  private:
  const std::string& _internal_instrument() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_instrument(const std::string& value);
  std::string* _internal_mutable_instrument();
  public:

  // string exchangeId = 2;
  void clear_exchangeid();
  const std::string& exchangeid() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_exchangeid(ArgT0&& arg0, ArgT... args);
  std::string* mutable_exchangeid();
  PROTOBUF_NODISCARD std::string* release_exchangeid();
  void set_allocated_exchangeid(std::string* exchangeid);
  private:
  const std::string& _internal_exchangeid() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_exchangeid(const std::string& value);
  std::string* _internal_mutable_exchangeid();
  public:

  // double limit_price = 4;
  void clear_limit_price();
  double limit_price() const;
  void set_limit_price(double value);
  private:
  double _internal_limit_price() const;
  void _internal_set_limit_price(double value);
  public:

  // .strategy_trader.Direction direction = 3;
  void clear_direction();
  ::strategy_trader::Direction direction() const;
  void set_direction(::strategy_trader::Direction value);
  private:
  ::strategy_trader::Direction _internal_direction() const;
  void _internal_set_direction(::strategy_trader::Direction value);
  public:

  // uint32 once_volume = 5;
  void clear_once_volume();
  uint32_t once_volume() const;
  void set_once_volume(uint32_t value);
  private:
  uint32_t _internal_once_volume() const;
  void _internal_set_once_volume(uint32_t value);
  public:

  // .strategy_trader.CombOffsetType comb_offset_flag = 6;
  void clear_comb_offset_flag();
  ::strategy_trader::CombOffsetType comb_offset_flag() const;
  void set_comb_offset_flag(::strategy_trader::CombOffsetType value);
  private:
  ::strategy_trader::CombOffsetType _internal_comb_offset_flag() const;
  void _internal_set_comb_offset_flag(::strategy_trader::CombOffsetType value);
  public:

  // uint32 hold_volume = 7;
  void clear_hold_volume();
  uint32_t hold_volume() const;
  void set_hold_volume(uint32_t value);
  private:
  uint32_t _internal_hold_volume() const;
  void _internal_set_hold_volume(uint32_t value);
  public:

  // .strategy_trader.OrderType order_type = 8;
  void clear_order_type();
  ::strategy_trader::OrderType order_type() const;
  void set_order_type(::strategy_trader::OrderType value);
  private:
  ::strategy_trader::OrderType _internal_order_type() const;
  void _internal_set_order_type(::strategy_trader::OrderType value);
  public:

  // @@protoc_insertion_point(class_scope:strategy_trader.Order)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr instrument_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr exchangeid_;
    double limit_price_;
    int direction_;
    uint32_t once_volume_;
    int comb_offset_flag_;
    uint32_t hold_volume_;
    int order_type_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_strategy_2dtrader_2eproto;
};
// -------------------------------------------------------------------

class TransactionCostReq final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:strategy_trader.TransactionCostReq) */ {
 public:
  inline TransactionCostReq() : TransactionCostReq(nullptr) {}
  ~TransactionCostReq() override;
  explicit PROTOBUF_CONSTEXPR TransactionCostReq(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  TransactionCostReq(const TransactionCostReq& from);
  TransactionCostReq(TransactionCostReq&& from) noexcept
    : TransactionCostReq() {
    *this = ::std::move(from);
  }

  inline TransactionCostReq& operator=(const TransactionCostReq& from) {
    CopyFrom(from);
    return *this;
  }
  inline TransactionCostReq& operator=(TransactionCostReq&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const TransactionCostReq& default_instance() {
    return *internal_default_instance();
  }
  static inline const TransactionCostReq* internal_default_instance() {
    return reinterpret_cast<const TransactionCostReq*>(
               &_TransactionCostReq_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    8;

  friend void swap(TransactionCostReq& a, TransactionCostReq& b) {
    a.Swap(&b);
  }
  inline void Swap(TransactionCostReq* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(TransactionCostReq* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  TransactionCostReq* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<TransactionCostReq>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const TransactionCostReq& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const TransactionCostReq& from) {
    TransactionCostReq::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(TransactionCostReq* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "strategy_trader.TransactionCostReq";
  }
  protected:
  explicit TransactionCostReq(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kInstrumentInfoFieldNumber = 1,
  };
  // .strategy_trader.InstrumentInfo instrument_info = 1;
  bool has_instrument_info() const;
  private:
  bool _internal_has_instrument_info() const;
  public:
  void clear_instrument_info();
  const ::strategy_trader::InstrumentInfo& instrument_info() const;
  PROTOBUF_NODISCARD ::strategy_trader::InstrumentInfo* release_instrument_info();
  ::strategy_trader::InstrumentInfo* mutable_instrument_info();
  void set_allocated_instrument_info(::strategy_trader::InstrumentInfo* instrument_info);
  private:
  const ::strategy_trader::InstrumentInfo& _internal_instrument_info() const;
  ::strategy_trader::InstrumentInfo* _internal_mutable_instrument_info();
  public:
  void unsafe_arena_set_allocated_instrument_info(
      ::strategy_trader::InstrumentInfo* instrument_info);
  ::strategy_trader::InstrumentInfo* unsafe_arena_release_instrument_info();

  // @@protoc_insertion_point(class_scope:strategy_trader.TransactionCostReq)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::strategy_trader::InstrumentInfo* instrument_info_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_strategy_2dtrader_2eproto;
};
// -------------------------------------------------------------------

class MarginRateRsp final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:strategy_trader.MarginRateRsp) */ {
 public:
  inline MarginRateRsp() : MarginRateRsp(nullptr) {}
  ~MarginRateRsp() override;
  explicit PROTOBUF_CONSTEXPR MarginRateRsp(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  MarginRateRsp(const MarginRateRsp& from);
  MarginRateRsp(MarginRateRsp&& from) noexcept
    : MarginRateRsp() {
    *this = ::std::move(from);
  }

  inline MarginRateRsp& operator=(const MarginRateRsp& from) {
    CopyFrom(from);
    return *this;
  }
  inline MarginRateRsp& operator=(MarginRateRsp&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const MarginRateRsp& default_instance() {
    return *internal_default_instance();
  }
  static inline const MarginRateRsp* internal_default_instance() {
    return reinterpret_cast<const MarginRateRsp*>(
               &_MarginRateRsp_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    9;

  friend void swap(MarginRateRsp& a, MarginRateRsp& b) {
    a.Swap(&b);
  }
  inline void Swap(MarginRateRsp* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(MarginRateRsp* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  MarginRateRsp* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<MarginRateRsp>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const MarginRateRsp& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const MarginRateRsp& from) {
    MarginRateRsp::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(MarginRateRsp* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "strategy_trader.MarginRateRsp";
  }
  protected:
  explicit MarginRateRsp(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kUserIdFieldNumber = 1,
    kInstrumentIdFieldNumber = 2,
    kExchangeIdFieldNumber = 3,
    kFailedReasonFieldNumber = 9,
    kLongMarginRatioByMoneyFieldNumber = 4,
    kLongMarginRatioByVolumeFieldNumber = 5,
    kShortMarginRatioByMoneyFieldNumber = 6,
    kShortMarginRatioByVolumeFieldNumber = 7,
    kResultFieldNumber = 8,
  };
  // string user_id = 1;
  void clear_user_id();
  const std::string& user_id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_user_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_user_id();
  PROTOBUF_NODISCARD std::string* release_user_id();
  void set_allocated_user_id(std::string* user_id);
  private:
  const std::string& _internal_user_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_user_id(const std::string& value);
  std::string* _internal_mutable_user_id();
  public:

  // string instrument_id = 2;
  void clear_instrument_id();
  const std::string& instrument_id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_instrument_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_instrument_id();
  PROTOBUF_NODISCARD std::string* release_instrument_id();
  void set_allocated_instrument_id(std::string* instrument_id);
  private:
  const std::string& _internal_instrument_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_instrument_id(const std::string& value);
  std::string* _internal_mutable_instrument_id();
  public:

  // string exchange_id = 3;
  void clear_exchange_id();
  const std::string& exchange_id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_exchange_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_exchange_id();
  PROTOBUF_NODISCARD std::string* release_exchange_id();
  void set_allocated_exchange_id(std::string* exchange_id);
  private:
  const std::string& _internal_exchange_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_exchange_id(const std::string& value);
  std::string* _internal_mutable_exchange_id();
  public:

  // string failedReason = 9;
  void clear_failedreason();
  const std::string& failedreason() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_failedreason(ArgT0&& arg0, ArgT... args);
  std::string* mutable_failedreason();
  PROTOBUF_NODISCARD std::string* release_failedreason();
  void set_allocated_failedreason(std::string* failedreason);
  private:
  const std::string& _internal_failedreason() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_failedreason(const std::string& value);
  std::string* _internal_mutable_failedreason();
  public:

  // double LongMarginRatioByMoney = 4;
  void clear_longmarginratiobymoney();
  double longmarginratiobymoney() const;
  void set_longmarginratiobymoney(double value);
  private:
  double _internal_longmarginratiobymoney() const;
  void _internal_set_longmarginratiobymoney(double value);
  public:

  // double LongMarginRatioByVolume = 5;
  void clear_longmarginratiobyvolume();
  double longmarginratiobyvolume() const;
  void set_longmarginratiobyvolume(double value);
  private:
  double _internal_longmarginratiobyvolume() const;
  void _internal_set_longmarginratiobyvolume(double value);
  public:

  // double ShortMarginRatioByMoney = 6;
  void clear_shortmarginratiobymoney();
  double shortmarginratiobymoney() const;
  void set_shortmarginratiobymoney(double value);
  private:
  double _internal_shortmarginratiobymoney() const;
  void _internal_set_shortmarginratiobymoney(double value);
  public:

  // double ShortMarginRatioByVolume = 7;
  void clear_shortmarginratiobyvolume();
  double shortmarginratiobyvolume() const;
  void set_shortmarginratiobyvolume(double value);
  private:
  double _internal_shortmarginratiobyvolume() const;
  void _internal_set_shortmarginratiobyvolume(double value);
  public:

  // .strategy_trader.Result result = 8;
  void clear_result();
  ::strategy_trader::Result result() const;
  void set_result(::strategy_trader::Result value);
  private:
  ::strategy_trader::Result _internal_result() const;
  void _internal_set_result(::strategy_trader::Result value);
  public:

  // @@protoc_insertion_point(class_scope:strategy_trader.MarginRateRsp)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr user_id_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr instrument_id_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr exchange_id_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr failedreason_;
    double longmarginratiobymoney_;
    double longmarginratiobyvolume_;
    double shortmarginratiobymoney_;
    double shortmarginratiobyvolume_;
    int result_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_strategy_2dtrader_2eproto;
};
// -------------------------------------------------------------------

class CommissionRateRsp final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:strategy_trader.CommissionRateRsp) */ {
 public:
  inline CommissionRateRsp() : CommissionRateRsp(nullptr) {}
  ~CommissionRateRsp() override;
  explicit PROTOBUF_CONSTEXPR CommissionRateRsp(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  CommissionRateRsp(const CommissionRateRsp& from);
  CommissionRateRsp(CommissionRateRsp&& from) noexcept
    : CommissionRateRsp() {
    *this = ::std::move(from);
  }

  inline CommissionRateRsp& operator=(const CommissionRateRsp& from) {
    CopyFrom(from);
    return *this;
  }
  inline CommissionRateRsp& operator=(CommissionRateRsp&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CommissionRateRsp& default_instance() {
    return *internal_default_instance();
  }
  static inline const CommissionRateRsp* internal_default_instance() {
    return reinterpret_cast<const CommissionRateRsp*>(
               &_CommissionRateRsp_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    10;

  friend void swap(CommissionRateRsp& a, CommissionRateRsp& b) {
    a.Swap(&b);
  }
  inline void Swap(CommissionRateRsp* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CommissionRateRsp* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  CommissionRateRsp* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<CommissionRateRsp>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const CommissionRateRsp& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const CommissionRateRsp& from) {
    CommissionRateRsp::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CommissionRateRsp* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "strategy_trader.CommissionRateRsp";
  }
  protected:
  explicit CommissionRateRsp(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kUserIdFieldNumber = 1,
    kInstrumentIdFieldNumber = 2,
    kExchangeIdFieldNumber = 3,
    kFailedReasonFieldNumber = 11,
    kOpenRatioByMoneyFieldNumber = 4,
    kOpenRatioByVolumeFieldNumber = 5,
    kCloseRatioByMoneyFieldNumber = 6,
    kCloseRatioByVolumeFieldNumber = 7,
    kCloseTodayRatioByMoneyFieldNumber = 8,
    kCloseTodayRatioByVolumeFieldNumber = 9,
    kResultFieldNumber = 10,
  };
  // string user_id = 1;
  void clear_user_id();
  const std::string& user_id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_user_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_user_id();
  PROTOBUF_NODISCARD std::string* release_user_id();
  void set_allocated_user_id(std::string* user_id);
  private:
  const std::string& _internal_user_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_user_id(const std::string& value);
  std::string* _internal_mutable_user_id();
  public:

  // string instrument_id = 2;
  void clear_instrument_id();
  const std::string& instrument_id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_instrument_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_instrument_id();
  PROTOBUF_NODISCARD std::string* release_instrument_id();
  void set_allocated_instrument_id(std::string* instrument_id);
  private:
  const std::string& _internal_instrument_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_instrument_id(const std::string& value);
  std::string* _internal_mutable_instrument_id();
  public:

  // string exchange_id = 3;
  void clear_exchange_id();
  const std::string& exchange_id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_exchange_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_exchange_id();
  PROTOBUF_NODISCARD std::string* release_exchange_id();
  void set_allocated_exchange_id(std::string* exchange_id);
  private:
  const std::string& _internal_exchange_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_exchange_id(const std::string& value);
  std::string* _internal_mutable_exchange_id();
  public:

  // string failedReason = 11;
  void clear_failedreason();
  const std::string& failedreason() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_failedreason(ArgT0&& arg0, ArgT... args);
  std::string* mutable_failedreason();
  PROTOBUF_NODISCARD std::string* release_failedreason();
  void set_allocated_failedreason(std::string* failedreason);
  private:
  const std::string& _internal_failedreason() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_failedreason(const std::string& value);
  std::string* _internal_mutable_failedreason();
  public:

  // double OpenRatioByMoney = 4;
  void clear_openratiobymoney();
  double openratiobymoney() const;
  void set_openratiobymoney(double value);
  private:
  double _internal_openratiobymoney() const;
  void _internal_set_openratiobymoney(double value);
  public:

  // double OpenRatioByVolume = 5;
  void clear_openratiobyvolume();
  double openratiobyvolume() const;
  void set_openratiobyvolume(double value);
  private:
  double _internal_openratiobyvolume() const;
  void _internal_set_openratiobyvolume(double value);
  public:

  // double CloseRatioByMoney = 6;
  void clear_closeratiobymoney();
  double closeratiobymoney() const;
  void set_closeratiobymoney(double value);
  private:
  double _internal_closeratiobymoney() const;
  void _internal_set_closeratiobymoney(double value);
  public:

  // double CloseRatioByVolume = 7;
  void clear_closeratiobyvolume();
  double closeratiobyvolume() const;
  void set_closeratiobyvolume(double value);
  private:
  double _internal_closeratiobyvolume() const;
  void _internal_set_closeratiobyvolume(double value);
  public:

  // double CloseTodayRatioByMoney = 8;
  void clear_closetodayratiobymoney();
  double closetodayratiobymoney() const;
  void set_closetodayratiobymoney(double value);
  private:
  double _internal_closetodayratiobymoney() const;
  void _internal_set_closetodayratiobymoney(double value);
  public:

  // double CloseTodayRatioByVolume = 9;
  void clear_closetodayratiobyvolume();
  double closetodayratiobyvolume() const;
  void set_closetodayratiobyvolume(double value);
  private:
  double _internal_closetodayratiobyvolume() const;
  void _internal_set_closetodayratiobyvolume(double value);
  public:

  // .strategy_trader.Result result = 10;
  void clear_result();
  ::strategy_trader::Result result() const;
  void set_result(::strategy_trader::Result value);
  private:
  ::strategy_trader::Result _internal_result() const;
  void _internal_set_result(::strategy_trader::Result value);
  public:

  // @@protoc_insertion_point(class_scope:strategy_trader.CommissionRateRsp)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr user_id_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr instrument_id_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr exchange_id_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr failedreason_;
    double openratiobymoney_;
    double openratiobyvolume_;
    double closeratiobymoney_;
    double closeratiobyvolume_;
    double closetodayratiobymoney_;
    double closetodayratiobyvolume_;
    int result_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_strategy_2dtrader_2eproto;
};
// -------------------------------------------------------------------

class InstrumentInfo final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:strategy_trader.InstrumentInfo) */ {
 public:
  inline InstrumentInfo() : InstrumentInfo(nullptr) {}
  ~InstrumentInfo() override;
  explicit PROTOBUF_CONSTEXPR InstrumentInfo(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  InstrumentInfo(const InstrumentInfo& from);
  InstrumentInfo(InstrumentInfo&& from) noexcept
    : InstrumentInfo() {
    *this = ::std::move(from);
  }

  inline InstrumentInfo& operator=(const InstrumentInfo& from) {
    CopyFrom(from);
    return *this;
  }
  inline InstrumentInfo& operator=(InstrumentInfo&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const InstrumentInfo& default_instance() {
    return *internal_default_instance();
  }
  static inline const InstrumentInfo* internal_default_instance() {
    return reinterpret_cast<const InstrumentInfo*>(
               &_InstrumentInfo_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    11;

  friend void swap(InstrumentInfo& a, InstrumentInfo& b) {
    a.Swap(&b);
  }
  inline void Swap(InstrumentInfo* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(InstrumentInfo* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  InstrumentInfo* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<InstrumentInfo>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const InstrumentInfo& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const InstrumentInfo& from) {
    InstrumentInfo::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(InstrumentInfo* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "strategy_trader.InstrumentInfo";
  }
  protected:
  explicit InstrumentInfo(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kInstrumentIdFieldNumber = 1,
    kExchangeIdFieldNumber = 2,
  };
  // string instrument_id = 1;
  void clear_instrument_id();
  const std::string& instrument_id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_instrument_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_instrument_id();
  PROTOBUF_NODISCARD std::string* release_instrument_id();
  void set_allocated_instrument_id(std::string* instrument_id);
  private:
  const std::string& _internal_instrument_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_instrument_id(const std::string& value);
  std::string* _internal_mutable_instrument_id();
  public:

  // string exchange_id = 2;
  void clear_exchange_id();
  const std::string& exchange_id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_exchange_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_exchange_id();
  PROTOBUF_NODISCARD std::string* release_exchange_id();
  void set_allocated_exchange_id(std::string* exchange_id);
  private:
  const std::string& _internal_exchange_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_exchange_id(const std::string& value);
  std::string* _internal_mutable_exchange_id();
  public:

  // @@protoc_insertion_point(class_scope:strategy_trader.InstrumentInfo)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr instrument_id_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr exchange_id_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_strategy_2dtrader_2eproto;
};
// -------------------------------------------------------------------

class AccountSetRsp final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:strategy_trader.AccountSetRsp) */ {
 public:
  inline AccountSetRsp() : AccountSetRsp(nullptr) {}
  ~AccountSetRsp() override;
  explicit PROTOBUF_CONSTEXPR AccountSetRsp(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  AccountSetRsp(const AccountSetRsp& from);
  AccountSetRsp(AccountSetRsp&& from) noexcept
    : AccountSetRsp() {
    *this = ::std::move(from);
  }

  inline AccountSetRsp& operator=(const AccountSetRsp& from) {
    CopyFrom(from);
    return *this;
  }
  inline AccountSetRsp& operator=(AccountSetRsp&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const AccountSetRsp& default_instance() {
    return *internal_default_instance();
  }
  static inline const AccountSetRsp* internal_default_instance() {
    return reinterpret_cast<const AccountSetRsp*>(
               &_AccountSetRsp_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    12;

  friend void swap(AccountSetRsp& a, AccountSetRsp& b) {
    a.Swap(&b);
  }
  inline void Swap(AccountSetRsp* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(AccountSetRsp* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  AccountSetRsp* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<AccountSetRsp>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const AccountSetRsp& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const AccountSetRsp& from) {
    AccountSetRsp::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(AccountSetRsp* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "strategy_trader.AccountSetRsp";
  }
  protected:
  explicit AccountSetRsp(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kAccountFieldNumber = 1,
  };
  // repeated string account = 1;
  int account_size() const;
  private:
  int _internal_account_size() const;
  public:
  void clear_account();
  const std::string& account(int index) const;
  std::string* mutable_account(int index);
  void set_account(int index, const std::string& value);
  void set_account(int index, std::string&& value);
  void set_account(int index, const char* value);
  void set_account(int index, const char* value, size_t size);
  std::string* add_account();
  void add_account(const std::string& value);
  void add_account(std::string&& value);
  void add_account(const char* value);
  void add_account(const char* value, size_t size);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& account() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* mutable_account();
  private:
  const std::string& _internal_account(int index) const;
  std::string* _internal_add_account();
  public:

  // @@protoc_insertion_point(class_scope:strategy_trader.AccountSetRsp)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string> account_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_strategy_2dtrader_2eproto;
};
// -------------------------------------------------------------------

class ActiveSafetyReq final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:strategy_trader.ActiveSafetyReq) */ {
 public:
  inline ActiveSafetyReq() : ActiveSafetyReq(nullptr) {}
  ~ActiveSafetyReq() override;
  explicit PROTOBUF_CONSTEXPR ActiveSafetyReq(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ActiveSafetyReq(const ActiveSafetyReq& from);
  ActiveSafetyReq(ActiveSafetyReq&& from) noexcept
    : ActiveSafetyReq() {
    *this = ::std::move(from);
  }

  inline ActiveSafetyReq& operator=(const ActiveSafetyReq& from) {
    CopyFrom(from);
    return *this;
  }
  inline ActiveSafetyReq& operator=(ActiveSafetyReq&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ActiveSafetyReq& default_instance() {
    return *internal_default_instance();
  }
  static inline const ActiveSafetyReq* internal_default_instance() {
    return reinterpret_cast<const ActiveSafetyReq*>(
               &_ActiveSafetyReq_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    13;

  friend void swap(ActiveSafetyReq& a, ActiveSafetyReq& b) {
    a.Swap(&b);
  }
  inline void Swap(ActiveSafetyReq* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ActiveSafetyReq* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ActiveSafetyReq* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ActiveSafetyReq>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ActiveSafetyReq& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const ActiveSafetyReq& from) {
    ActiveSafetyReq::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ActiveSafetyReq* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "strategy_trader.ActiveSafetyReq";
  }
  protected:
  explicit ActiveSafetyReq(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef ActiveSafetyReq_MessageType MessageType;
  static constexpr MessageType reserve =
    ActiveSafetyReq_MessageType_reserve;
  static constexpr MessageType isrun =
    ActiveSafetyReq_MessageType_isrun;
  static inline bool MessageType_IsValid(int value) {
    return ActiveSafetyReq_MessageType_IsValid(value);
  }
  static constexpr MessageType MessageType_MIN =
    ActiveSafetyReq_MessageType_MessageType_MIN;
  static constexpr MessageType MessageType_MAX =
    ActiveSafetyReq_MessageType_MessageType_MAX;
  static constexpr int MessageType_ARRAYSIZE =
    ActiveSafetyReq_MessageType_MessageType_ARRAYSIZE;
  static inline const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
  MessageType_descriptor() {
    return ActiveSafetyReq_MessageType_descriptor();
  }
  template<typename T>
  static inline const std::string& MessageType_Name(T enum_t_value) {
    static_assert(::std::is_same<T, MessageType>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function MessageType_Name.");
    return ActiveSafetyReq_MessageType_Name(enum_t_value);
  }
  static inline bool MessageType_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name,
      MessageType* value) {
    return ActiveSafetyReq_MessageType_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  enum : int {
    kSafeIdFieldNumber = 1,
  };
  // .strategy_trader.ActiveSafetyReq.MessageType safe_id = 1;
  void clear_safe_id();
  ::strategy_trader::ActiveSafetyReq_MessageType safe_id() const;
  void set_safe_id(::strategy_trader::ActiveSafetyReq_MessageType value);
  private:
  ::strategy_trader::ActiveSafetyReq_MessageType _internal_safe_id() const;
  void _internal_set_safe_id(::strategy_trader::ActiveSafetyReq_MessageType value);
  public:

  // @@protoc_insertion_point(class_scope:strategy_trader.ActiveSafetyReq)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    int safe_id_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_strategy_2dtrader_2eproto;
};
// -------------------------------------------------------------------

class ActiveSafetyRsp final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:strategy_trader.ActiveSafetyRsp) */ {
 public:
  inline ActiveSafetyRsp() : ActiveSafetyRsp(nullptr) {}
  ~ActiveSafetyRsp() override;
  explicit PROTOBUF_CONSTEXPR ActiveSafetyRsp(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ActiveSafetyRsp(const ActiveSafetyRsp& from);
  ActiveSafetyRsp(ActiveSafetyRsp&& from) noexcept
    : ActiveSafetyRsp() {
    *this = ::std::move(from);
  }

  inline ActiveSafetyRsp& operator=(const ActiveSafetyRsp& from) {
    CopyFrom(from);
    return *this;
  }
  inline ActiveSafetyRsp& operator=(ActiveSafetyRsp&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ActiveSafetyRsp& default_instance() {
    return *internal_default_instance();
  }
  static inline const ActiveSafetyRsp* internal_default_instance() {
    return reinterpret_cast<const ActiveSafetyRsp*>(
               &_ActiveSafetyRsp_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    14;

  friend void swap(ActiveSafetyRsp& a, ActiveSafetyRsp& b) {
    a.Swap(&b);
  }
  inline void Swap(ActiveSafetyRsp* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ActiveSafetyRsp* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ActiveSafetyRsp* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ActiveSafetyRsp>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ActiveSafetyRsp& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const ActiveSafetyRsp& from) {
    ActiveSafetyRsp::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ActiveSafetyRsp* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "strategy_trader.ActiveSafetyRsp";
  }
  protected:
  explicit ActiveSafetyRsp(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kStatusFieldNumber = 1,
  };
  // bool status = 1;
  void clear_status();
  bool status() const;
  void set_status(bool value);
  private:
  bool _internal_status() const;
  void _internal_set_status(bool value);
  public:

  // @@protoc_insertion_point(class_scope:strategy_trader.ActiveSafetyRsp)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    bool status_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_strategy_2dtrader_2eproto;
};
// -------------------------------------------------------------------

class CheckStrategyAliveReq final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:strategy_trader.CheckStrategyAliveReq) */ {
 public:
  inline CheckStrategyAliveReq() : CheckStrategyAliveReq(nullptr) {}
  ~CheckStrategyAliveReq() override;
  explicit PROTOBUF_CONSTEXPR CheckStrategyAliveReq(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  CheckStrategyAliveReq(const CheckStrategyAliveReq& from);
  CheckStrategyAliveReq(CheckStrategyAliveReq&& from) noexcept
    : CheckStrategyAliveReq() {
    *this = ::std::move(from);
  }

  inline CheckStrategyAliveReq& operator=(const CheckStrategyAliveReq& from) {
    CopyFrom(from);
    return *this;
  }
  inline CheckStrategyAliveReq& operator=(CheckStrategyAliveReq&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CheckStrategyAliveReq& default_instance() {
    return *internal_default_instance();
  }
  static inline const CheckStrategyAliveReq* internal_default_instance() {
    return reinterpret_cast<const CheckStrategyAliveReq*>(
               &_CheckStrategyAliveReq_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    15;

  friend void swap(CheckStrategyAliveReq& a, CheckStrategyAliveReq& b) {
    a.Swap(&b);
  }
  inline void Swap(CheckStrategyAliveReq* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CheckStrategyAliveReq* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  CheckStrategyAliveReq* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<CheckStrategyAliveReq>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const CheckStrategyAliveReq& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const CheckStrategyAliveReq& from) {
    CheckStrategyAliveReq::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CheckStrategyAliveReq* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "strategy_trader.CheckStrategyAliveReq";
  }
  protected:
  explicit CheckStrategyAliveReq(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kAliveReqFieldNumber = 1,
  };
  // bool alive_req = 1;
  void clear_alive_req();
  bool alive_req() const;
  void set_alive_req(bool value);
  private:
  bool _internal_alive_req() const;
  void _internal_set_alive_req(bool value);
  public:

  // @@protoc_insertion_point(class_scope:strategy_trader.CheckStrategyAliveReq)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    bool alive_req_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_strategy_2dtrader_2eproto;
};
// -------------------------------------------------------------------

class CheckStrategyAliveRsp final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:strategy_trader.CheckStrategyAliveRsp) */ {
 public:
  inline CheckStrategyAliveRsp() : CheckStrategyAliveRsp(nullptr) {}
  ~CheckStrategyAliveRsp() override;
  explicit PROTOBUF_CONSTEXPR CheckStrategyAliveRsp(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  CheckStrategyAliveRsp(const CheckStrategyAliveRsp& from);
  CheckStrategyAliveRsp(CheckStrategyAliveRsp&& from) noexcept
    : CheckStrategyAliveRsp() {
    *this = ::std::move(from);
  }

  inline CheckStrategyAliveRsp& operator=(const CheckStrategyAliveRsp& from) {
    CopyFrom(from);
    return *this;
  }
  inline CheckStrategyAliveRsp& operator=(CheckStrategyAliveRsp&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CheckStrategyAliveRsp& default_instance() {
    return *internal_default_instance();
  }
  static inline const CheckStrategyAliveRsp* internal_default_instance() {
    return reinterpret_cast<const CheckStrategyAliveRsp*>(
               &_CheckStrategyAliveRsp_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    16;

  friend void swap(CheckStrategyAliveRsp& a, CheckStrategyAliveRsp& b) {
    a.Swap(&b);
  }
  inline void Swap(CheckStrategyAliveRsp* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CheckStrategyAliveRsp* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  CheckStrategyAliveRsp* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<CheckStrategyAliveRsp>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const CheckStrategyAliveRsp& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const CheckStrategyAliveRsp& from) {
    CheckStrategyAliveRsp::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CheckStrategyAliveRsp* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "strategy_trader.CheckStrategyAliveRsp";
  }
  protected:
  explicit CheckStrategyAliveRsp(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kAliveRspFieldNumber = 1,
  };
  // bool alive_rsp = 1;
  void clear_alive_rsp();
  bool alive_rsp() const;
  void set_alive_rsp(bool value);
  private:
  bool _internal_alive_rsp() const;
  void _internal_set_alive_rsp(bool value);
  public:

  // @@protoc_insertion_point(class_scope:strategy_trader.CheckStrategyAliveRsp)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    bool alive_rsp_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_strategy_2dtrader_2eproto;
};
// -------------------------------------------------------------------

class CheckTraderAliveReq final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:strategy_trader.CheckTraderAliveReq) */ {
 public:
  inline CheckTraderAliveReq() : CheckTraderAliveReq(nullptr) {}
  ~CheckTraderAliveReq() override;
  explicit PROTOBUF_CONSTEXPR CheckTraderAliveReq(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  CheckTraderAliveReq(const CheckTraderAliveReq& from);
  CheckTraderAliveReq(CheckTraderAliveReq&& from) noexcept
    : CheckTraderAliveReq() {
    *this = ::std::move(from);
  }

  inline CheckTraderAliveReq& operator=(const CheckTraderAliveReq& from) {
    CopyFrom(from);
    return *this;
  }
  inline CheckTraderAliveReq& operator=(CheckTraderAliveReq&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CheckTraderAliveReq& default_instance() {
    return *internal_default_instance();
  }
  static inline const CheckTraderAliveReq* internal_default_instance() {
    return reinterpret_cast<const CheckTraderAliveReq*>(
               &_CheckTraderAliveReq_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    17;

  friend void swap(CheckTraderAliveReq& a, CheckTraderAliveReq& b) {
    a.Swap(&b);
  }
  inline void Swap(CheckTraderAliveReq* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CheckTraderAliveReq* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  CheckTraderAliveReq* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<CheckTraderAliveReq>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const CheckTraderAliveReq& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const CheckTraderAliveReq& from) {
    CheckTraderAliveReq::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CheckTraderAliveReq* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "strategy_trader.CheckTraderAliveReq";
  }
  protected:
  explicit CheckTraderAliveReq(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kAliveReqFieldNumber = 1,
  };
  // bool alive_req = 1;
  void clear_alive_req();
  bool alive_req() const;
  void set_alive_req(bool value);
  private:
  bool _internal_alive_req() const;
  void _internal_set_alive_req(bool value);
  public:

  // @@protoc_insertion_point(class_scope:strategy_trader.CheckTraderAliveReq)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    bool alive_req_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_strategy_2dtrader_2eproto;
};
// -------------------------------------------------------------------

class CheckTraderAliveRsp final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:strategy_trader.CheckTraderAliveRsp) */ {
 public:
  inline CheckTraderAliveRsp() : CheckTraderAliveRsp(nullptr) {}
  ~CheckTraderAliveRsp() override;
  explicit PROTOBUF_CONSTEXPR CheckTraderAliveRsp(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  CheckTraderAliveRsp(const CheckTraderAliveRsp& from);
  CheckTraderAliveRsp(CheckTraderAliveRsp&& from) noexcept
    : CheckTraderAliveRsp() {
    *this = ::std::move(from);
  }

  inline CheckTraderAliveRsp& operator=(const CheckTraderAliveRsp& from) {
    CopyFrom(from);
    return *this;
  }
  inline CheckTraderAliveRsp& operator=(CheckTraderAliveRsp&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CheckTraderAliveRsp& default_instance() {
    return *internal_default_instance();
  }
  static inline const CheckTraderAliveRsp* internal_default_instance() {
    return reinterpret_cast<const CheckTraderAliveRsp*>(
               &_CheckTraderAliveRsp_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    18;

  friend void swap(CheckTraderAliveRsp& a, CheckTraderAliveRsp& b) {
    a.Swap(&b);
  }
  inline void Swap(CheckTraderAliveRsp* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CheckTraderAliveRsp* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  CheckTraderAliveRsp* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<CheckTraderAliveRsp>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const CheckTraderAliveRsp& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const CheckTraderAliveRsp& from) {
    CheckTraderAliveRsp::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CheckTraderAliveRsp* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "strategy_trader.CheckTraderAliveRsp";
  }
  protected:
  explicit CheckTraderAliveRsp(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kAliveRspFieldNumber = 1,
  };
  // bool alive_rsp = 1;
  void clear_alive_rsp();
  bool alive_rsp() const;
  void set_alive_rsp(bool value);
  private:
  bool _internal_alive_rsp() const;
  void _internal_set_alive_rsp(bool value);
  public:

  // @@protoc_insertion_point(class_scope:strategy_trader.CheckTraderAliveRsp)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    bool alive_rsp_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_strategy_2dtrader_2eproto;
};
// -------------------------------------------------------------------

class OrderPositionReq final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:strategy_trader.OrderPositionReq) */ {
 public:
  inline OrderPositionReq() : OrderPositionReq(nullptr) {}
  ~OrderPositionReq() override;
  explicit PROTOBUF_CONSTEXPR OrderPositionReq(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  OrderPositionReq(const OrderPositionReq& from);
  OrderPositionReq(OrderPositionReq&& from) noexcept
    : OrderPositionReq() {
    *this = ::std::move(from);
  }

  inline OrderPositionReq& operator=(const OrderPositionReq& from) {
    CopyFrom(from);
    return *this;
  }
  inline OrderPositionReq& operator=(OrderPositionReq&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const OrderPositionReq& default_instance() {
    return *internal_default_instance();
  }
  static inline const OrderPositionReq* internal_default_instance() {
    return reinterpret_cast<const OrderPositionReq*>(
               &_OrderPositionReq_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    19;

  friend void swap(OrderPositionReq& a, OrderPositionReq& b) {
    a.Swap(&b);
  }
  inline void Swap(OrderPositionReq* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(OrderPositionReq* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  OrderPositionReq* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<OrderPositionReq>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const OrderPositionReq& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const OrderPositionReq& from) {
    OrderPositionReq::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(OrderPositionReq* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "strategy_trader.OrderPositionReq";
  }
  protected:
  explicit OrderPositionReq(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kInstrumentFieldNumber = 1,
    kIndexFieldNumber = 2,
  };
  // string instrument = 1;
  void clear_instrument();
  const std::string& instrument() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_instrument(ArgT0&& arg0, ArgT... args);
  std::string* mutable_instrument();
  PROTOBUF_NODISCARD std::string* release_instrument();
  void set_allocated_instrument(std::string* instrument);
  private:
  const std::string& _internal_instrument() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_instrument(const std::string& value);
  std::string* _internal_mutable_instrument();
  public:

  // string index = 2;
  void clear_index();
  const std::string& index() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_index(ArgT0&& arg0, ArgT... args);
  std::string* mutable_index();
  PROTOBUF_NODISCARD std::string* release_index();
  void set_allocated_index(std::string* index);
  private:
  const std::string& _internal_index() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_index(const std::string& value);
  std::string* _internal_mutable_index();
  public:

  // @@protoc_insertion_point(class_scope:strategy_trader.OrderPositionReq)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr instrument_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr index_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_strategy_2dtrader_2eproto;
};
// -------------------------------------------------------------------

class OrderPositionRsp final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:strategy_trader.OrderPositionRsp) */ {
 public:
  inline OrderPositionRsp() : OrderPositionRsp(nullptr) {}
  ~OrderPositionRsp() override;
  explicit PROTOBUF_CONSTEXPR OrderPositionRsp(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  OrderPositionRsp(const OrderPositionRsp& from);
  OrderPositionRsp(OrderPositionRsp&& from) noexcept
    : OrderPositionRsp() {
    *this = ::std::move(from);
  }

  inline OrderPositionRsp& operator=(const OrderPositionRsp& from) {
    CopyFrom(from);
    return *this;
  }
  inline OrderPositionRsp& operator=(OrderPositionRsp&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const OrderPositionRsp& default_instance() {
    return *internal_default_instance();
  }
  static inline const OrderPositionRsp* internal_default_instance() {
    return reinterpret_cast<const OrderPositionRsp*>(
               &_OrderPositionRsp_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    20;

  friend void swap(OrderPositionRsp& a, OrderPositionRsp& b) {
    a.Swap(&b);
  }
  inline void Swap(OrderPositionRsp* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(OrderPositionRsp* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  OrderPositionRsp* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<OrderPositionRsp>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const OrderPositionRsp& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const OrderPositionRsp& from) {
    OrderPositionRsp::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(OrderPositionRsp* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "strategy_trader.OrderPositionRsp";
  }
  protected:
  explicit OrderPositionRsp(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kInstrumentFieldNumber = 1,
    kIndexFieldNumber = 2,
    kVolumeFieldNumber = 3,
  };
  // string instrument = 1;
  void clear_instrument();
  const std::string& instrument() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_instrument(ArgT0&& arg0, ArgT... args);
  std::string* mutable_instrument();
  PROTOBUF_NODISCARD std::string* release_instrument();
  void set_allocated_instrument(std::string* instrument);
  private:
  const std::string& _internal_instrument() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_instrument(const std::string& value);
  std::string* _internal_mutable_instrument();
  public:

  // string index = 2;
  void clear_index();
  const std::string& index() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_index(ArgT0&& arg0, ArgT... args);
  std::string* mutable_index();
  PROTOBUF_NODISCARD std::string* release_index();
  void set_allocated_index(std::string* index);
  private:
  const std::string& _internal_index() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_index(const std::string& value);
  std::string* _internal_mutable_index();
  public:

  // uint32 volume = 3;
  void clear_volume();
  uint32_t volume() const;
  void set_volume(uint32_t value);
  private:
  uint32_t _internal_volume() const;
  void _internal_set_volume(uint32_t value);
  public:

  // @@protoc_insertion_point(class_scope:strategy_trader.OrderPositionRsp)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr instrument_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr index_;
    uint32_t volume_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_strategy_2dtrader_2eproto;
};
// -------------------------------------------------------------------

class GroupSizeReq final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:strategy_trader.GroupSizeReq) */ {
 public:
  inline GroupSizeReq() : GroupSizeReq(nullptr) {}
  ~GroupSizeReq() override;
  explicit PROTOBUF_CONSTEXPR GroupSizeReq(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  GroupSizeReq(const GroupSizeReq& from);
  GroupSizeReq(GroupSizeReq&& from) noexcept
    : GroupSizeReq() {
    *this = ::std::move(from);
  }

  inline GroupSizeReq& operator=(const GroupSizeReq& from) {
    CopyFrom(from);
    return *this;
  }
  inline GroupSizeReq& operator=(GroupSizeReq&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const GroupSizeReq& default_instance() {
    return *internal_default_instance();
  }
  static inline const GroupSizeReq* internal_default_instance() {
    return reinterpret_cast<const GroupSizeReq*>(
               &_GroupSizeReq_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    21;

  friend void swap(GroupSizeReq& a, GroupSizeReq& b) {
    a.Swap(&b);
  }
  inline void Swap(GroupSizeReq* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GroupSizeReq* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  GroupSizeReq* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<GroupSizeReq>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const GroupSizeReq& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const GroupSizeReq& from) {
    GroupSizeReq::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(GroupSizeReq* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "strategy_trader.GroupSizeReq";
  }
  protected:
  explicit GroupSizeReq(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kSizeReqFieldNumber = 1,
  };
  // uint32 size_req = 1;
  void clear_size_req();
  uint32_t size_req() const;
  void set_size_req(uint32_t value);
  private:
  uint32_t _internal_size_req() const;
  void _internal_set_size_req(uint32_t value);
  public:

  // @@protoc_insertion_point(class_scope:strategy_trader.GroupSizeReq)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    uint32_t size_req_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_strategy_2dtrader_2eproto;
};
// -------------------------------------------------------------------

class GroupSizeRsp final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:strategy_trader.GroupSizeRsp) */ {
 public:
  inline GroupSizeRsp() : GroupSizeRsp(nullptr) {}
  ~GroupSizeRsp() override;
  explicit PROTOBUF_CONSTEXPR GroupSizeRsp(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  GroupSizeRsp(const GroupSizeRsp& from);
  GroupSizeRsp(GroupSizeRsp&& from) noexcept
    : GroupSizeRsp() {
    *this = ::std::move(from);
  }

  inline GroupSizeRsp& operator=(const GroupSizeRsp& from) {
    CopyFrom(from);
    return *this;
  }
  inline GroupSizeRsp& operator=(GroupSizeRsp&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const GroupSizeRsp& default_instance() {
    return *internal_default_instance();
  }
  static inline const GroupSizeRsp* internal_default_instance() {
    return reinterpret_cast<const GroupSizeRsp*>(
               &_GroupSizeRsp_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    22;

  friend void swap(GroupSizeRsp& a, GroupSizeRsp& b) {
    a.Swap(&b);
  }
  inline void Swap(GroupSizeRsp* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GroupSizeRsp* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  GroupSizeRsp* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<GroupSizeRsp>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const GroupSizeRsp& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const GroupSizeRsp& from) {
    GroupSizeRsp::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(GroupSizeRsp* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "strategy_trader.GroupSizeRsp";
  }
  protected:
  explicit GroupSizeRsp(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kSizeRspFieldNumber = 1,
  };
  // uint32 size_rsp = 1;
  void clear_size_rsp();
  uint32_t size_rsp() const;
  void set_size_rsp(uint32_t value);
  private:
  uint32_t _internal_size_rsp() const;
  void _internal_set_size_rsp(uint32_t value);
  public:

  // @@protoc_insertion_point(class_scope:strategy_trader.GroupSizeRsp)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    uint32_t size_rsp_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_strategy_2dtrader_2eproto;
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// message

// .strategy_trader.OrderInsertReq order_insert_req = 1;
inline bool message::_internal_has_order_insert_req() const {
  return MessageType_case() == kOrderInsertReq;
}
inline bool message::has_order_insert_req() const {
  return _internal_has_order_insert_req();
}
inline void message::set_has_order_insert_req() {
  _impl_._oneof_case_[0] = kOrderInsertReq;
}
inline void message::clear_order_insert_req() {
  if (_internal_has_order_insert_req()) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.MessageType_.order_insert_req_;
    }
    clear_has_MessageType();
  }
}
inline ::strategy_trader::OrderInsertReq* message::release_order_insert_req() {
  // @@protoc_insertion_point(field_release:strategy_trader.message.order_insert_req)
  if (_internal_has_order_insert_req()) {
    clear_has_MessageType();
    ::strategy_trader::OrderInsertReq* temp = _impl_.MessageType_.order_insert_req_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.MessageType_.order_insert_req_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::strategy_trader::OrderInsertReq& message::_internal_order_insert_req() const {
  return _internal_has_order_insert_req()
      ? *_impl_.MessageType_.order_insert_req_
      : reinterpret_cast< ::strategy_trader::OrderInsertReq&>(::strategy_trader::_OrderInsertReq_default_instance_);
}
inline const ::strategy_trader::OrderInsertReq& message::order_insert_req() const {
  // @@protoc_insertion_point(field_get:strategy_trader.message.order_insert_req)
  return _internal_order_insert_req();
}
inline ::strategy_trader::OrderInsertReq* message::unsafe_arena_release_order_insert_req() {
  // @@protoc_insertion_point(field_unsafe_arena_release:strategy_trader.message.order_insert_req)
  if (_internal_has_order_insert_req()) {
    clear_has_MessageType();
    ::strategy_trader::OrderInsertReq* temp = _impl_.MessageType_.order_insert_req_;
    _impl_.MessageType_.order_insert_req_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void message::unsafe_arena_set_allocated_order_insert_req(::strategy_trader::OrderInsertReq* order_insert_req) {
  clear_MessageType();
  if (order_insert_req) {
    set_has_order_insert_req();
    _impl_.MessageType_.order_insert_req_ = order_insert_req;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:strategy_trader.message.order_insert_req)
}
inline ::strategy_trader::OrderInsertReq* message::_internal_mutable_order_insert_req() {
  if (!_internal_has_order_insert_req()) {
    clear_MessageType();
    set_has_order_insert_req();
    _impl_.MessageType_.order_insert_req_ = CreateMaybeMessage< ::strategy_trader::OrderInsertReq >(GetArenaForAllocation());
  }
  return _impl_.MessageType_.order_insert_req_;
}
inline ::strategy_trader::OrderInsertReq* message::mutable_order_insert_req() {
  ::strategy_trader::OrderInsertReq* _msg = _internal_mutable_order_insert_req();
  // @@protoc_insertion_point(field_mutable:strategy_trader.message.order_insert_req)
  return _msg;
}

// .strategy_trader.OrderInsertRsp order_insert_rsp = 2;
inline bool message::_internal_has_order_insert_rsp() const {
  return MessageType_case() == kOrderInsertRsp;
}
inline bool message::has_order_insert_rsp() const {
  return _internal_has_order_insert_rsp();
}
inline void message::set_has_order_insert_rsp() {
  _impl_._oneof_case_[0] = kOrderInsertRsp;
}
inline void message::clear_order_insert_rsp() {
  if (_internal_has_order_insert_rsp()) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.MessageType_.order_insert_rsp_;
    }
    clear_has_MessageType();
  }
}
inline ::strategy_trader::OrderInsertRsp* message::release_order_insert_rsp() {
  // @@protoc_insertion_point(field_release:strategy_trader.message.order_insert_rsp)
  if (_internal_has_order_insert_rsp()) {
    clear_has_MessageType();
    ::strategy_trader::OrderInsertRsp* temp = _impl_.MessageType_.order_insert_rsp_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.MessageType_.order_insert_rsp_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::strategy_trader::OrderInsertRsp& message::_internal_order_insert_rsp() const {
  return _internal_has_order_insert_rsp()
      ? *_impl_.MessageType_.order_insert_rsp_
      : reinterpret_cast< ::strategy_trader::OrderInsertRsp&>(::strategy_trader::_OrderInsertRsp_default_instance_);
}
inline const ::strategy_trader::OrderInsertRsp& message::order_insert_rsp() const {
  // @@protoc_insertion_point(field_get:strategy_trader.message.order_insert_rsp)
  return _internal_order_insert_rsp();
}
inline ::strategy_trader::OrderInsertRsp* message::unsafe_arena_release_order_insert_rsp() {
  // @@protoc_insertion_point(field_unsafe_arena_release:strategy_trader.message.order_insert_rsp)
  if (_internal_has_order_insert_rsp()) {
    clear_has_MessageType();
    ::strategy_trader::OrderInsertRsp* temp = _impl_.MessageType_.order_insert_rsp_;
    _impl_.MessageType_.order_insert_rsp_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void message::unsafe_arena_set_allocated_order_insert_rsp(::strategy_trader::OrderInsertRsp* order_insert_rsp) {
  clear_MessageType();
  if (order_insert_rsp) {
    set_has_order_insert_rsp();
    _impl_.MessageType_.order_insert_rsp_ = order_insert_rsp;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:strategy_trader.message.order_insert_rsp)
}
inline ::strategy_trader::OrderInsertRsp* message::_internal_mutable_order_insert_rsp() {
  if (!_internal_has_order_insert_rsp()) {
    clear_MessageType();
    set_has_order_insert_rsp();
    _impl_.MessageType_.order_insert_rsp_ = CreateMaybeMessage< ::strategy_trader::OrderInsertRsp >(GetArenaForAllocation());
  }
  return _impl_.MessageType_.order_insert_rsp_;
}
inline ::strategy_trader::OrderInsertRsp* message::mutable_order_insert_rsp() {
  ::strategy_trader::OrderInsertRsp* _msg = _internal_mutable_order_insert_rsp();
  // @@protoc_insertion_point(field_mutable:strategy_trader.message.order_insert_rsp)
  return _msg;
}

// .strategy_trader.AccountStatusRsp account_status_rsp = 3;
inline bool message::_internal_has_account_status_rsp() const {
  return MessageType_case() == kAccountStatusRsp;
}
inline bool message::has_account_status_rsp() const {
  return _internal_has_account_status_rsp();
}
inline void message::set_has_account_status_rsp() {
  _impl_._oneof_case_[0] = kAccountStatusRsp;
}
inline void message::clear_account_status_rsp() {
  if (_internal_has_account_status_rsp()) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.MessageType_.account_status_rsp_;
    }
    clear_has_MessageType();
  }
}
inline ::strategy_trader::AccountStatusRsp* message::release_account_status_rsp() {
  // @@protoc_insertion_point(field_release:strategy_trader.message.account_status_rsp)
  if (_internal_has_account_status_rsp()) {
    clear_has_MessageType();
    ::strategy_trader::AccountStatusRsp* temp = _impl_.MessageType_.account_status_rsp_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.MessageType_.account_status_rsp_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::strategy_trader::AccountStatusRsp& message::_internal_account_status_rsp() const {
  return _internal_has_account_status_rsp()
      ? *_impl_.MessageType_.account_status_rsp_
      : reinterpret_cast< ::strategy_trader::AccountStatusRsp&>(::strategy_trader::_AccountStatusRsp_default_instance_);
}
inline const ::strategy_trader::AccountStatusRsp& message::account_status_rsp() const {
  // @@protoc_insertion_point(field_get:strategy_trader.message.account_status_rsp)
  return _internal_account_status_rsp();
}
inline ::strategy_trader::AccountStatusRsp* message::unsafe_arena_release_account_status_rsp() {
  // @@protoc_insertion_point(field_unsafe_arena_release:strategy_trader.message.account_status_rsp)
  if (_internal_has_account_status_rsp()) {
    clear_has_MessageType();
    ::strategy_trader::AccountStatusRsp* temp = _impl_.MessageType_.account_status_rsp_;
    _impl_.MessageType_.account_status_rsp_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void message::unsafe_arena_set_allocated_account_status_rsp(::strategy_trader::AccountStatusRsp* account_status_rsp) {
  clear_MessageType();
  if (account_status_rsp) {
    set_has_account_status_rsp();
    _impl_.MessageType_.account_status_rsp_ = account_status_rsp;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:strategy_trader.message.account_status_rsp)
}
inline ::strategy_trader::AccountStatusRsp* message::_internal_mutable_account_status_rsp() {
  if (!_internal_has_account_status_rsp()) {
    clear_MessageType();
    set_has_account_status_rsp();
    _impl_.MessageType_.account_status_rsp_ = CreateMaybeMessage< ::strategy_trader::AccountStatusRsp >(GetArenaForAllocation());
  }
  return _impl_.MessageType_.account_status_rsp_;
}
inline ::strategy_trader::AccountStatusRsp* message::mutable_account_status_rsp() {
  ::strategy_trader::AccountStatusRsp* _msg = _internal_mutable_account_status_rsp();
  // @@protoc_insertion_point(field_mutable:strategy_trader.message.account_status_rsp)
  return _msg;
}

// .strategy_trader.OrderCancelReq order_cancel_req = 4;
inline bool message::_internal_has_order_cancel_req() const {
  return MessageType_case() == kOrderCancelReq;
}
inline bool message::has_order_cancel_req() const {
  return _internal_has_order_cancel_req();
}
inline void message::set_has_order_cancel_req() {
  _impl_._oneof_case_[0] = kOrderCancelReq;
}
inline void message::clear_order_cancel_req() {
  if (_internal_has_order_cancel_req()) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.MessageType_.order_cancel_req_;
    }
    clear_has_MessageType();
  }
}
inline ::strategy_trader::OrderCancelReq* message::release_order_cancel_req() {
  // @@protoc_insertion_point(field_release:strategy_trader.message.order_cancel_req)
  if (_internal_has_order_cancel_req()) {
    clear_has_MessageType();
    ::strategy_trader::OrderCancelReq* temp = _impl_.MessageType_.order_cancel_req_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.MessageType_.order_cancel_req_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::strategy_trader::OrderCancelReq& message::_internal_order_cancel_req() const {
  return _internal_has_order_cancel_req()
      ? *_impl_.MessageType_.order_cancel_req_
      : reinterpret_cast< ::strategy_trader::OrderCancelReq&>(::strategy_trader::_OrderCancelReq_default_instance_);
}
inline const ::strategy_trader::OrderCancelReq& message::order_cancel_req() const {
  // @@protoc_insertion_point(field_get:strategy_trader.message.order_cancel_req)
  return _internal_order_cancel_req();
}
inline ::strategy_trader::OrderCancelReq* message::unsafe_arena_release_order_cancel_req() {
  // @@protoc_insertion_point(field_unsafe_arena_release:strategy_trader.message.order_cancel_req)
  if (_internal_has_order_cancel_req()) {
    clear_has_MessageType();
    ::strategy_trader::OrderCancelReq* temp = _impl_.MessageType_.order_cancel_req_;
    _impl_.MessageType_.order_cancel_req_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void message::unsafe_arena_set_allocated_order_cancel_req(::strategy_trader::OrderCancelReq* order_cancel_req) {
  clear_MessageType();
  if (order_cancel_req) {
    set_has_order_cancel_req();
    _impl_.MessageType_.order_cancel_req_ = order_cancel_req;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:strategy_trader.message.order_cancel_req)
}
inline ::strategy_trader::OrderCancelReq* message::_internal_mutable_order_cancel_req() {
  if (!_internal_has_order_cancel_req()) {
    clear_MessageType();
    set_has_order_cancel_req();
    _impl_.MessageType_.order_cancel_req_ = CreateMaybeMessage< ::strategy_trader::OrderCancelReq >(GetArenaForAllocation());
  }
  return _impl_.MessageType_.order_cancel_req_;
}
inline ::strategy_trader::OrderCancelReq* message::mutable_order_cancel_req() {
  ::strategy_trader::OrderCancelReq* _msg = _internal_mutable_order_cancel_req();
  // @@protoc_insertion_point(field_mutable:strategy_trader.message.order_cancel_req)
  return _msg;
}

// .strategy_trader.OrderCancelRsp order_cancel_rsp = 5;
inline bool message::_internal_has_order_cancel_rsp() const {
  return MessageType_case() == kOrderCancelRsp;
}
inline bool message::has_order_cancel_rsp() const {
  return _internal_has_order_cancel_rsp();
}
inline void message::set_has_order_cancel_rsp() {
  _impl_._oneof_case_[0] = kOrderCancelRsp;
}
inline void message::clear_order_cancel_rsp() {
  if (_internal_has_order_cancel_rsp()) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.MessageType_.order_cancel_rsp_;
    }
    clear_has_MessageType();
  }
}
inline ::strategy_trader::OrderCancelRsp* message::release_order_cancel_rsp() {
  // @@protoc_insertion_point(field_release:strategy_trader.message.order_cancel_rsp)
  if (_internal_has_order_cancel_rsp()) {
    clear_has_MessageType();
    ::strategy_trader::OrderCancelRsp* temp = _impl_.MessageType_.order_cancel_rsp_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.MessageType_.order_cancel_rsp_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::strategy_trader::OrderCancelRsp& message::_internal_order_cancel_rsp() const {
  return _internal_has_order_cancel_rsp()
      ? *_impl_.MessageType_.order_cancel_rsp_
      : reinterpret_cast< ::strategy_trader::OrderCancelRsp&>(::strategy_trader::_OrderCancelRsp_default_instance_);
}
inline const ::strategy_trader::OrderCancelRsp& message::order_cancel_rsp() const {
  // @@protoc_insertion_point(field_get:strategy_trader.message.order_cancel_rsp)
  return _internal_order_cancel_rsp();
}
inline ::strategy_trader::OrderCancelRsp* message::unsafe_arena_release_order_cancel_rsp() {
  // @@protoc_insertion_point(field_unsafe_arena_release:strategy_trader.message.order_cancel_rsp)
  if (_internal_has_order_cancel_rsp()) {
    clear_has_MessageType();
    ::strategy_trader::OrderCancelRsp* temp = _impl_.MessageType_.order_cancel_rsp_;
    _impl_.MessageType_.order_cancel_rsp_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void message::unsafe_arena_set_allocated_order_cancel_rsp(::strategy_trader::OrderCancelRsp* order_cancel_rsp) {
  clear_MessageType();
  if (order_cancel_rsp) {
    set_has_order_cancel_rsp();
    _impl_.MessageType_.order_cancel_rsp_ = order_cancel_rsp;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:strategy_trader.message.order_cancel_rsp)
}
inline ::strategy_trader::OrderCancelRsp* message::_internal_mutable_order_cancel_rsp() {
  if (!_internal_has_order_cancel_rsp()) {
    clear_MessageType();
    set_has_order_cancel_rsp();
    _impl_.MessageType_.order_cancel_rsp_ = CreateMaybeMessage< ::strategy_trader::OrderCancelRsp >(GetArenaForAllocation());
  }
  return _impl_.MessageType_.order_cancel_rsp_;
}
inline ::strategy_trader::OrderCancelRsp* message::mutable_order_cancel_rsp() {
  ::strategy_trader::OrderCancelRsp* _msg = _internal_mutable_order_cancel_rsp();
  // @@protoc_insertion_point(field_mutable:strategy_trader.message.order_cancel_rsp)
  return _msg;
}

// .strategy_trader.TransactionCostReq transaction_cost_req = 6;
inline bool message::_internal_has_transaction_cost_req() const {
  return MessageType_case() == kTransactionCostReq;
}
inline bool message::has_transaction_cost_req() const {
  return _internal_has_transaction_cost_req();
}
inline void message::set_has_transaction_cost_req() {
  _impl_._oneof_case_[0] = kTransactionCostReq;
}
inline void message::clear_transaction_cost_req() {
  if (_internal_has_transaction_cost_req()) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.MessageType_.transaction_cost_req_;
    }
    clear_has_MessageType();
  }
}
inline ::strategy_trader::TransactionCostReq* message::release_transaction_cost_req() {
  // @@protoc_insertion_point(field_release:strategy_trader.message.transaction_cost_req)
  if (_internal_has_transaction_cost_req()) {
    clear_has_MessageType();
    ::strategy_trader::TransactionCostReq* temp = _impl_.MessageType_.transaction_cost_req_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.MessageType_.transaction_cost_req_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::strategy_trader::TransactionCostReq& message::_internal_transaction_cost_req() const {
  return _internal_has_transaction_cost_req()
      ? *_impl_.MessageType_.transaction_cost_req_
      : reinterpret_cast< ::strategy_trader::TransactionCostReq&>(::strategy_trader::_TransactionCostReq_default_instance_);
}
inline const ::strategy_trader::TransactionCostReq& message::transaction_cost_req() const {
  // @@protoc_insertion_point(field_get:strategy_trader.message.transaction_cost_req)
  return _internal_transaction_cost_req();
}
inline ::strategy_trader::TransactionCostReq* message::unsafe_arena_release_transaction_cost_req() {
  // @@protoc_insertion_point(field_unsafe_arena_release:strategy_trader.message.transaction_cost_req)
  if (_internal_has_transaction_cost_req()) {
    clear_has_MessageType();
    ::strategy_trader::TransactionCostReq* temp = _impl_.MessageType_.transaction_cost_req_;
    _impl_.MessageType_.transaction_cost_req_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void message::unsafe_arena_set_allocated_transaction_cost_req(::strategy_trader::TransactionCostReq* transaction_cost_req) {
  clear_MessageType();
  if (transaction_cost_req) {
    set_has_transaction_cost_req();
    _impl_.MessageType_.transaction_cost_req_ = transaction_cost_req;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:strategy_trader.message.transaction_cost_req)
}
inline ::strategy_trader::TransactionCostReq* message::_internal_mutable_transaction_cost_req() {
  if (!_internal_has_transaction_cost_req()) {
    clear_MessageType();
    set_has_transaction_cost_req();
    _impl_.MessageType_.transaction_cost_req_ = CreateMaybeMessage< ::strategy_trader::TransactionCostReq >(GetArenaForAllocation());
  }
  return _impl_.MessageType_.transaction_cost_req_;
}
inline ::strategy_trader::TransactionCostReq* message::mutable_transaction_cost_req() {
  ::strategy_trader::TransactionCostReq* _msg = _internal_mutable_transaction_cost_req();
  // @@protoc_insertion_point(field_mutable:strategy_trader.message.transaction_cost_req)
  return _msg;
}

// .strategy_trader.CommissionRateRsp commission_rate_rsp = 7;
inline bool message::_internal_has_commission_rate_rsp() const {
  return MessageType_case() == kCommissionRateRsp;
}
inline bool message::has_commission_rate_rsp() const {
  return _internal_has_commission_rate_rsp();
}
inline void message::set_has_commission_rate_rsp() {
  _impl_._oneof_case_[0] = kCommissionRateRsp;
}
inline void message::clear_commission_rate_rsp() {
  if (_internal_has_commission_rate_rsp()) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.MessageType_.commission_rate_rsp_;
    }
    clear_has_MessageType();
  }
}
inline ::strategy_trader::CommissionRateRsp* message::release_commission_rate_rsp() {
  // @@protoc_insertion_point(field_release:strategy_trader.message.commission_rate_rsp)
  if (_internal_has_commission_rate_rsp()) {
    clear_has_MessageType();
    ::strategy_trader::CommissionRateRsp* temp = _impl_.MessageType_.commission_rate_rsp_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.MessageType_.commission_rate_rsp_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::strategy_trader::CommissionRateRsp& message::_internal_commission_rate_rsp() const {
  return _internal_has_commission_rate_rsp()
      ? *_impl_.MessageType_.commission_rate_rsp_
      : reinterpret_cast< ::strategy_trader::CommissionRateRsp&>(::strategy_trader::_CommissionRateRsp_default_instance_);
}
inline const ::strategy_trader::CommissionRateRsp& message::commission_rate_rsp() const {
  // @@protoc_insertion_point(field_get:strategy_trader.message.commission_rate_rsp)
  return _internal_commission_rate_rsp();
}
inline ::strategy_trader::CommissionRateRsp* message::unsafe_arena_release_commission_rate_rsp() {
  // @@protoc_insertion_point(field_unsafe_arena_release:strategy_trader.message.commission_rate_rsp)
  if (_internal_has_commission_rate_rsp()) {
    clear_has_MessageType();
    ::strategy_trader::CommissionRateRsp* temp = _impl_.MessageType_.commission_rate_rsp_;
    _impl_.MessageType_.commission_rate_rsp_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void message::unsafe_arena_set_allocated_commission_rate_rsp(::strategy_trader::CommissionRateRsp* commission_rate_rsp) {
  clear_MessageType();
  if (commission_rate_rsp) {
    set_has_commission_rate_rsp();
    _impl_.MessageType_.commission_rate_rsp_ = commission_rate_rsp;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:strategy_trader.message.commission_rate_rsp)
}
inline ::strategy_trader::CommissionRateRsp* message::_internal_mutable_commission_rate_rsp() {
  if (!_internal_has_commission_rate_rsp()) {
    clear_MessageType();
    set_has_commission_rate_rsp();
    _impl_.MessageType_.commission_rate_rsp_ = CreateMaybeMessage< ::strategy_trader::CommissionRateRsp >(GetArenaForAllocation());
  }
  return _impl_.MessageType_.commission_rate_rsp_;
}
inline ::strategy_trader::CommissionRateRsp* message::mutable_commission_rate_rsp() {
  ::strategy_trader::CommissionRateRsp* _msg = _internal_mutable_commission_rate_rsp();
  // @@protoc_insertion_point(field_mutable:strategy_trader.message.commission_rate_rsp)
  return _msg;
}

// .strategy_trader.MarginRateRsp margin_rate_rsp = 8;
inline bool message::_internal_has_margin_rate_rsp() const {
  return MessageType_case() == kMarginRateRsp;
}
inline bool message::has_margin_rate_rsp() const {
  return _internal_has_margin_rate_rsp();
}
inline void message::set_has_margin_rate_rsp() {
  _impl_._oneof_case_[0] = kMarginRateRsp;
}
inline void message::clear_margin_rate_rsp() {
  if (_internal_has_margin_rate_rsp()) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.MessageType_.margin_rate_rsp_;
    }
    clear_has_MessageType();
  }
}
inline ::strategy_trader::MarginRateRsp* message::release_margin_rate_rsp() {
  // @@protoc_insertion_point(field_release:strategy_trader.message.margin_rate_rsp)
  if (_internal_has_margin_rate_rsp()) {
    clear_has_MessageType();
    ::strategy_trader::MarginRateRsp* temp = _impl_.MessageType_.margin_rate_rsp_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.MessageType_.margin_rate_rsp_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::strategy_trader::MarginRateRsp& message::_internal_margin_rate_rsp() const {
  return _internal_has_margin_rate_rsp()
      ? *_impl_.MessageType_.margin_rate_rsp_
      : reinterpret_cast< ::strategy_trader::MarginRateRsp&>(::strategy_trader::_MarginRateRsp_default_instance_);
}
inline const ::strategy_trader::MarginRateRsp& message::margin_rate_rsp() const {
  // @@protoc_insertion_point(field_get:strategy_trader.message.margin_rate_rsp)
  return _internal_margin_rate_rsp();
}
inline ::strategy_trader::MarginRateRsp* message::unsafe_arena_release_margin_rate_rsp() {
  // @@protoc_insertion_point(field_unsafe_arena_release:strategy_trader.message.margin_rate_rsp)
  if (_internal_has_margin_rate_rsp()) {
    clear_has_MessageType();
    ::strategy_trader::MarginRateRsp* temp = _impl_.MessageType_.margin_rate_rsp_;
    _impl_.MessageType_.margin_rate_rsp_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void message::unsafe_arena_set_allocated_margin_rate_rsp(::strategy_trader::MarginRateRsp* margin_rate_rsp) {
  clear_MessageType();
  if (margin_rate_rsp) {
    set_has_margin_rate_rsp();
    _impl_.MessageType_.margin_rate_rsp_ = margin_rate_rsp;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:strategy_trader.message.margin_rate_rsp)
}
inline ::strategy_trader::MarginRateRsp* message::_internal_mutable_margin_rate_rsp() {
  if (!_internal_has_margin_rate_rsp()) {
    clear_MessageType();
    set_has_margin_rate_rsp();
    _impl_.MessageType_.margin_rate_rsp_ = CreateMaybeMessage< ::strategy_trader::MarginRateRsp >(GetArenaForAllocation());
  }
  return _impl_.MessageType_.margin_rate_rsp_;
}
inline ::strategy_trader::MarginRateRsp* message::mutable_margin_rate_rsp() {
  ::strategy_trader::MarginRateRsp* _msg = _internal_mutable_margin_rate_rsp();
  // @@protoc_insertion_point(field_mutable:strategy_trader.message.margin_rate_rsp)
  return _msg;
}

// .strategy_trader.AccountSetRsp account_set_rsp = 9;
inline bool message::_internal_has_account_set_rsp() const {
  return MessageType_case() == kAccountSetRsp;
}
inline bool message::has_account_set_rsp() const {
  return _internal_has_account_set_rsp();
}
inline void message::set_has_account_set_rsp() {
  _impl_._oneof_case_[0] = kAccountSetRsp;
}
inline void message::clear_account_set_rsp() {
  if (_internal_has_account_set_rsp()) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.MessageType_.account_set_rsp_;
    }
    clear_has_MessageType();
  }
}
inline ::strategy_trader::AccountSetRsp* message::release_account_set_rsp() {
  // @@protoc_insertion_point(field_release:strategy_trader.message.account_set_rsp)
  if (_internal_has_account_set_rsp()) {
    clear_has_MessageType();
    ::strategy_trader::AccountSetRsp* temp = _impl_.MessageType_.account_set_rsp_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.MessageType_.account_set_rsp_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::strategy_trader::AccountSetRsp& message::_internal_account_set_rsp() const {
  return _internal_has_account_set_rsp()
      ? *_impl_.MessageType_.account_set_rsp_
      : reinterpret_cast< ::strategy_trader::AccountSetRsp&>(::strategy_trader::_AccountSetRsp_default_instance_);
}
inline const ::strategy_trader::AccountSetRsp& message::account_set_rsp() const {
  // @@protoc_insertion_point(field_get:strategy_trader.message.account_set_rsp)
  return _internal_account_set_rsp();
}
inline ::strategy_trader::AccountSetRsp* message::unsafe_arena_release_account_set_rsp() {
  // @@protoc_insertion_point(field_unsafe_arena_release:strategy_trader.message.account_set_rsp)
  if (_internal_has_account_set_rsp()) {
    clear_has_MessageType();
    ::strategy_trader::AccountSetRsp* temp = _impl_.MessageType_.account_set_rsp_;
    _impl_.MessageType_.account_set_rsp_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void message::unsafe_arena_set_allocated_account_set_rsp(::strategy_trader::AccountSetRsp* account_set_rsp) {
  clear_MessageType();
  if (account_set_rsp) {
    set_has_account_set_rsp();
    _impl_.MessageType_.account_set_rsp_ = account_set_rsp;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:strategy_trader.message.account_set_rsp)
}
inline ::strategy_trader::AccountSetRsp* message::_internal_mutable_account_set_rsp() {
  if (!_internal_has_account_set_rsp()) {
    clear_MessageType();
    set_has_account_set_rsp();
    _impl_.MessageType_.account_set_rsp_ = CreateMaybeMessage< ::strategy_trader::AccountSetRsp >(GetArenaForAllocation());
  }
  return _impl_.MessageType_.account_set_rsp_;
}
inline ::strategy_trader::AccountSetRsp* message::mutable_account_set_rsp() {
  ::strategy_trader::AccountSetRsp* _msg = _internal_mutable_account_set_rsp();
  // @@protoc_insertion_point(field_mutable:strategy_trader.message.account_set_rsp)
  return _msg;
}

// .strategy_trader.ActiveSafetyReq active_req = 10;
inline bool message::_internal_has_active_req() const {
  return MessageType_case() == kActiveReq;
}
inline bool message::has_active_req() const {
  return _internal_has_active_req();
}
inline void message::set_has_active_req() {
  _impl_._oneof_case_[0] = kActiveReq;
}
inline void message::clear_active_req() {
  if (_internal_has_active_req()) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.MessageType_.active_req_;
    }
    clear_has_MessageType();
  }
}
inline ::strategy_trader::ActiveSafetyReq* message::release_active_req() {
  // @@protoc_insertion_point(field_release:strategy_trader.message.active_req)
  if (_internal_has_active_req()) {
    clear_has_MessageType();
    ::strategy_trader::ActiveSafetyReq* temp = _impl_.MessageType_.active_req_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.MessageType_.active_req_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::strategy_trader::ActiveSafetyReq& message::_internal_active_req() const {
  return _internal_has_active_req()
      ? *_impl_.MessageType_.active_req_
      : reinterpret_cast< ::strategy_trader::ActiveSafetyReq&>(::strategy_trader::_ActiveSafetyReq_default_instance_);
}
inline const ::strategy_trader::ActiveSafetyReq& message::active_req() const {
  // @@protoc_insertion_point(field_get:strategy_trader.message.active_req)
  return _internal_active_req();
}
inline ::strategy_trader::ActiveSafetyReq* message::unsafe_arena_release_active_req() {
  // @@protoc_insertion_point(field_unsafe_arena_release:strategy_trader.message.active_req)
  if (_internal_has_active_req()) {
    clear_has_MessageType();
    ::strategy_trader::ActiveSafetyReq* temp = _impl_.MessageType_.active_req_;
    _impl_.MessageType_.active_req_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void message::unsafe_arena_set_allocated_active_req(::strategy_trader::ActiveSafetyReq* active_req) {
  clear_MessageType();
  if (active_req) {
    set_has_active_req();
    _impl_.MessageType_.active_req_ = active_req;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:strategy_trader.message.active_req)
}
inline ::strategy_trader::ActiveSafetyReq* message::_internal_mutable_active_req() {
  if (!_internal_has_active_req()) {
    clear_MessageType();
    set_has_active_req();
    _impl_.MessageType_.active_req_ = CreateMaybeMessage< ::strategy_trader::ActiveSafetyReq >(GetArenaForAllocation());
  }
  return _impl_.MessageType_.active_req_;
}
inline ::strategy_trader::ActiveSafetyReq* message::mutable_active_req() {
  ::strategy_trader::ActiveSafetyReq* _msg = _internal_mutable_active_req();
  // @@protoc_insertion_point(field_mutable:strategy_trader.message.active_req)
  return _msg;
}

// .strategy_trader.ActiveSafetyRsp active_rsp = 11;
inline bool message::_internal_has_active_rsp() const {
  return MessageType_case() == kActiveRsp;
}
inline bool message::has_active_rsp() const {
  return _internal_has_active_rsp();
}
inline void message::set_has_active_rsp() {
  _impl_._oneof_case_[0] = kActiveRsp;
}
inline void message::clear_active_rsp() {
  if (_internal_has_active_rsp()) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.MessageType_.active_rsp_;
    }
    clear_has_MessageType();
  }
}
inline ::strategy_trader::ActiveSafetyRsp* message::release_active_rsp() {
  // @@protoc_insertion_point(field_release:strategy_trader.message.active_rsp)
  if (_internal_has_active_rsp()) {
    clear_has_MessageType();
    ::strategy_trader::ActiveSafetyRsp* temp = _impl_.MessageType_.active_rsp_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.MessageType_.active_rsp_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::strategy_trader::ActiveSafetyRsp& message::_internal_active_rsp() const {
  return _internal_has_active_rsp()
      ? *_impl_.MessageType_.active_rsp_
      : reinterpret_cast< ::strategy_trader::ActiveSafetyRsp&>(::strategy_trader::_ActiveSafetyRsp_default_instance_);
}
inline const ::strategy_trader::ActiveSafetyRsp& message::active_rsp() const {
  // @@protoc_insertion_point(field_get:strategy_trader.message.active_rsp)
  return _internal_active_rsp();
}
inline ::strategy_trader::ActiveSafetyRsp* message::unsafe_arena_release_active_rsp() {
  // @@protoc_insertion_point(field_unsafe_arena_release:strategy_trader.message.active_rsp)
  if (_internal_has_active_rsp()) {
    clear_has_MessageType();
    ::strategy_trader::ActiveSafetyRsp* temp = _impl_.MessageType_.active_rsp_;
    _impl_.MessageType_.active_rsp_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void message::unsafe_arena_set_allocated_active_rsp(::strategy_trader::ActiveSafetyRsp* active_rsp) {
  clear_MessageType();
  if (active_rsp) {
    set_has_active_rsp();
    _impl_.MessageType_.active_rsp_ = active_rsp;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:strategy_trader.message.active_rsp)
}
inline ::strategy_trader::ActiveSafetyRsp* message::_internal_mutable_active_rsp() {
  if (!_internal_has_active_rsp()) {
    clear_MessageType();
    set_has_active_rsp();
    _impl_.MessageType_.active_rsp_ = CreateMaybeMessage< ::strategy_trader::ActiveSafetyRsp >(GetArenaForAllocation());
  }
  return _impl_.MessageType_.active_rsp_;
}
inline ::strategy_trader::ActiveSafetyRsp* message::mutable_active_rsp() {
  ::strategy_trader::ActiveSafetyRsp* _msg = _internal_mutable_active_rsp();
  // @@protoc_insertion_point(field_mutable:strategy_trader.message.active_rsp)
  return _msg;
}

// .strategy_trader.CheckStrategyAliveReq strategy_alive_req = 12;
inline bool message::_internal_has_strategy_alive_req() const {
  return MessageType_case() == kStrategyAliveReq;
}
inline bool message::has_strategy_alive_req() const {
  return _internal_has_strategy_alive_req();
}
inline void message::set_has_strategy_alive_req() {
  _impl_._oneof_case_[0] = kStrategyAliveReq;
}
inline void message::clear_strategy_alive_req() {
  if (_internal_has_strategy_alive_req()) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.MessageType_.strategy_alive_req_;
    }
    clear_has_MessageType();
  }
}
inline ::strategy_trader::CheckStrategyAliveReq* message::release_strategy_alive_req() {
  // @@protoc_insertion_point(field_release:strategy_trader.message.strategy_alive_req)
  if (_internal_has_strategy_alive_req()) {
    clear_has_MessageType();
    ::strategy_trader::CheckStrategyAliveReq* temp = _impl_.MessageType_.strategy_alive_req_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.MessageType_.strategy_alive_req_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::strategy_trader::CheckStrategyAliveReq& message::_internal_strategy_alive_req() const {
  return _internal_has_strategy_alive_req()
      ? *_impl_.MessageType_.strategy_alive_req_
      : reinterpret_cast< ::strategy_trader::CheckStrategyAliveReq&>(::strategy_trader::_CheckStrategyAliveReq_default_instance_);
}
inline const ::strategy_trader::CheckStrategyAliveReq& message::strategy_alive_req() const {
  // @@protoc_insertion_point(field_get:strategy_trader.message.strategy_alive_req)
  return _internal_strategy_alive_req();
}
inline ::strategy_trader::CheckStrategyAliveReq* message::unsafe_arena_release_strategy_alive_req() {
  // @@protoc_insertion_point(field_unsafe_arena_release:strategy_trader.message.strategy_alive_req)
  if (_internal_has_strategy_alive_req()) {
    clear_has_MessageType();
    ::strategy_trader::CheckStrategyAliveReq* temp = _impl_.MessageType_.strategy_alive_req_;
    _impl_.MessageType_.strategy_alive_req_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void message::unsafe_arena_set_allocated_strategy_alive_req(::strategy_trader::CheckStrategyAliveReq* strategy_alive_req) {
  clear_MessageType();
  if (strategy_alive_req) {
    set_has_strategy_alive_req();
    _impl_.MessageType_.strategy_alive_req_ = strategy_alive_req;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:strategy_trader.message.strategy_alive_req)
}
inline ::strategy_trader::CheckStrategyAliveReq* message::_internal_mutable_strategy_alive_req() {
  if (!_internal_has_strategy_alive_req()) {
    clear_MessageType();
    set_has_strategy_alive_req();
    _impl_.MessageType_.strategy_alive_req_ = CreateMaybeMessage< ::strategy_trader::CheckStrategyAliveReq >(GetArenaForAllocation());
  }
  return _impl_.MessageType_.strategy_alive_req_;
}
inline ::strategy_trader::CheckStrategyAliveReq* message::mutable_strategy_alive_req() {
  ::strategy_trader::CheckStrategyAliveReq* _msg = _internal_mutable_strategy_alive_req();
  // @@protoc_insertion_point(field_mutable:strategy_trader.message.strategy_alive_req)
  return _msg;
}

// .strategy_trader.CheckStrategyAliveRsp strategy_alive_rsp = 13;
inline bool message::_internal_has_strategy_alive_rsp() const {
  return MessageType_case() == kStrategyAliveRsp;
}
inline bool message::has_strategy_alive_rsp() const {
  return _internal_has_strategy_alive_rsp();
}
inline void message::set_has_strategy_alive_rsp() {
  _impl_._oneof_case_[0] = kStrategyAliveRsp;
}
inline void message::clear_strategy_alive_rsp() {
  if (_internal_has_strategy_alive_rsp()) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.MessageType_.strategy_alive_rsp_;
    }
    clear_has_MessageType();
  }
}
inline ::strategy_trader::CheckStrategyAliveRsp* message::release_strategy_alive_rsp() {
  // @@protoc_insertion_point(field_release:strategy_trader.message.strategy_alive_rsp)
  if (_internal_has_strategy_alive_rsp()) {
    clear_has_MessageType();
    ::strategy_trader::CheckStrategyAliveRsp* temp = _impl_.MessageType_.strategy_alive_rsp_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.MessageType_.strategy_alive_rsp_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::strategy_trader::CheckStrategyAliveRsp& message::_internal_strategy_alive_rsp() const {
  return _internal_has_strategy_alive_rsp()
      ? *_impl_.MessageType_.strategy_alive_rsp_
      : reinterpret_cast< ::strategy_trader::CheckStrategyAliveRsp&>(::strategy_trader::_CheckStrategyAliveRsp_default_instance_);
}
inline const ::strategy_trader::CheckStrategyAliveRsp& message::strategy_alive_rsp() const {
  // @@protoc_insertion_point(field_get:strategy_trader.message.strategy_alive_rsp)
  return _internal_strategy_alive_rsp();
}
inline ::strategy_trader::CheckStrategyAliveRsp* message::unsafe_arena_release_strategy_alive_rsp() {
  // @@protoc_insertion_point(field_unsafe_arena_release:strategy_trader.message.strategy_alive_rsp)
  if (_internal_has_strategy_alive_rsp()) {
    clear_has_MessageType();
    ::strategy_trader::CheckStrategyAliveRsp* temp = _impl_.MessageType_.strategy_alive_rsp_;
    _impl_.MessageType_.strategy_alive_rsp_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void message::unsafe_arena_set_allocated_strategy_alive_rsp(::strategy_trader::CheckStrategyAliveRsp* strategy_alive_rsp) {
  clear_MessageType();
  if (strategy_alive_rsp) {
    set_has_strategy_alive_rsp();
    _impl_.MessageType_.strategy_alive_rsp_ = strategy_alive_rsp;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:strategy_trader.message.strategy_alive_rsp)
}
inline ::strategy_trader::CheckStrategyAliveRsp* message::_internal_mutable_strategy_alive_rsp() {
  if (!_internal_has_strategy_alive_rsp()) {
    clear_MessageType();
    set_has_strategy_alive_rsp();
    _impl_.MessageType_.strategy_alive_rsp_ = CreateMaybeMessage< ::strategy_trader::CheckStrategyAliveRsp >(GetArenaForAllocation());
  }
  return _impl_.MessageType_.strategy_alive_rsp_;
}
inline ::strategy_trader::CheckStrategyAliveRsp* message::mutable_strategy_alive_rsp() {
  ::strategy_trader::CheckStrategyAliveRsp* _msg = _internal_mutable_strategy_alive_rsp();
  // @@protoc_insertion_point(field_mutable:strategy_trader.message.strategy_alive_rsp)
  return _msg;
}

// .strategy_trader.CheckTraderAliveReq trader_alive_req = 14;
inline bool message::_internal_has_trader_alive_req() const {
  return MessageType_case() == kTraderAliveReq;
}
inline bool message::has_trader_alive_req() const {
  return _internal_has_trader_alive_req();
}
inline void message::set_has_trader_alive_req() {
  _impl_._oneof_case_[0] = kTraderAliveReq;
}
inline void message::clear_trader_alive_req() {
  if (_internal_has_trader_alive_req()) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.MessageType_.trader_alive_req_;
    }
    clear_has_MessageType();
  }
}
inline ::strategy_trader::CheckTraderAliveReq* message::release_trader_alive_req() {
  // @@protoc_insertion_point(field_release:strategy_trader.message.trader_alive_req)
  if (_internal_has_trader_alive_req()) {
    clear_has_MessageType();
    ::strategy_trader::CheckTraderAliveReq* temp = _impl_.MessageType_.trader_alive_req_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.MessageType_.trader_alive_req_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::strategy_trader::CheckTraderAliveReq& message::_internal_trader_alive_req() const {
  return _internal_has_trader_alive_req()
      ? *_impl_.MessageType_.trader_alive_req_
      : reinterpret_cast< ::strategy_trader::CheckTraderAliveReq&>(::strategy_trader::_CheckTraderAliveReq_default_instance_);
}
inline const ::strategy_trader::CheckTraderAliveReq& message::trader_alive_req() const {
  // @@protoc_insertion_point(field_get:strategy_trader.message.trader_alive_req)
  return _internal_trader_alive_req();
}
inline ::strategy_trader::CheckTraderAliveReq* message::unsafe_arena_release_trader_alive_req() {
  // @@protoc_insertion_point(field_unsafe_arena_release:strategy_trader.message.trader_alive_req)
  if (_internal_has_trader_alive_req()) {
    clear_has_MessageType();
    ::strategy_trader::CheckTraderAliveReq* temp = _impl_.MessageType_.trader_alive_req_;
    _impl_.MessageType_.trader_alive_req_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void message::unsafe_arena_set_allocated_trader_alive_req(::strategy_trader::CheckTraderAliveReq* trader_alive_req) {
  clear_MessageType();
  if (trader_alive_req) {
    set_has_trader_alive_req();
    _impl_.MessageType_.trader_alive_req_ = trader_alive_req;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:strategy_trader.message.trader_alive_req)
}
inline ::strategy_trader::CheckTraderAliveReq* message::_internal_mutable_trader_alive_req() {
  if (!_internal_has_trader_alive_req()) {
    clear_MessageType();
    set_has_trader_alive_req();
    _impl_.MessageType_.trader_alive_req_ = CreateMaybeMessage< ::strategy_trader::CheckTraderAliveReq >(GetArenaForAllocation());
  }
  return _impl_.MessageType_.trader_alive_req_;
}
inline ::strategy_trader::CheckTraderAliveReq* message::mutable_trader_alive_req() {
  ::strategy_trader::CheckTraderAliveReq* _msg = _internal_mutable_trader_alive_req();
  // @@protoc_insertion_point(field_mutable:strategy_trader.message.trader_alive_req)
  return _msg;
}

// .strategy_trader.CheckTraderAliveRsp trader_alive_rsp = 15;
inline bool message::_internal_has_trader_alive_rsp() const {
  return MessageType_case() == kTraderAliveRsp;
}
inline bool message::has_trader_alive_rsp() const {
  return _internal_has_trader_alive_rsp();
}
inline void message::set_has_trader_alive_rsp() {
  _impl_._oneof_case_[0] = kTraderAliveRsp;
}
inline void message::clear_trader_alive_rsp() {
  if (_internal_has_trader_alive_rsp()) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.MessageType_.trader_alive_rsp_;
    }
    clear_has_MessageType();
  }
}
inline ::strategy_trader::CheckTraderAliveRsp* message::release_trader_alive_rsp() {
  // @@protoc_insertion_point(field_release:strategy_trader.message.trader_alive_rsp)
  if (_internal_has_trader_alive_rsp()) {
    clear_has_MessageType();
    ::strategy_trader::CheckTraderAliveRsp* temp = _impl_.MessageType_.trader_alive_rsp_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.MessageType_.trader_alive_rsp_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::strategy_trader::CheckTraderAliveRsp& message::_internal_trader_alive_rsp() const {
  return _internal_has_trader_alive_rsp()
      ? *_impl_.MessageType_.trader_alive_rsp_
      : reinterpret_cast< ::strategy_trader::CheckTraderAliveRsp&>(::strategy_trader::_CheckTraderAliveRsp_default_instance_);
}
inline const ::strategy_trader::CheckTraderAliveRsp& message::trader_alive_rsp() const {
  // @@protoc_insertion_point(field_get:strategy_trader.message.trader_alive_rsp)
  return _internal_trader_alive_rsp();
}
inline ::strategy_trader::CheckTraderAliveRsp* message::unsafe_arena_release_trader_alive_rsp() {
  // @@protoc_insertion_point(field_unsafe_arena_release:strategy_trader.message.trader_alive_rsp)
  if (_internal_has_trader_alive_rsp()) {
    clear_has_MessageType();
    ::strategy_trader::CheckTraderAliveRsp* temp = _impl_.MessageType_.trader_alive_rsp_;
    _impl_.MessageType_.trader_alive_rsp_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void message::unsafe_arena_set_allocated_trader_alive_rsp(::strategy_trader::CheckTraderAliveRsp* trader_alive_rsp) {
  clear_MessageType();
  if (trader_alive_rsp) {
    set_has_trader_alive_rsp();
    _impl_.MessageType_.trader_alive_rsp_ = trader_alive_rsp;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:strategy_trader.message.trader_alive_rsp)
}
inline ::strategy_trader::CheckTraderAliveRsp* message::_internal_mutable_trader_alive_rsp() {
  if (!_internal_has_trader_alive_rsp()) {
    clear_MessageType();
    set_has_trader_alive_rsp();
    _impl_.MessageType_.trader_alive_rsp_ = CreateMaybeMessage< ::strategy_trader::CheckTraderAliveRsp >(GetArenaForAllocation());
  }
  return _impl_.MessageType_.trader_alive_rsp_;
}
inline ::strategy_trader::CheckTraderAliveRsp* message::mutable_trader_alive_rsp() {
  ::strategy_trader::CheckTraderAliveRsp* _msg = _internal_mutable_trader_alive_rsp();
  // @@protoc_insertion_point(field_mutable:strategy_trader.message.trader_alive_rsp)
  return _msg;
}

// .strategy_trader.OrderPositionReq position_req = 16;
inline bool message::_internal_has_position_req() const {
  return MessageType_case() == kPositionReq;
}
inline bool message::has_position_req() const {
  return _internal_has_position_req();
}
inline void message::set_has_position_req() {
  _impl_._oneof_case_[0] = kPositionReq;
}
inline void message::clear_position_req() {
  if (_internal_has_position_req()) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.MessageType_.position_req_;
    }
    clear_has_MessageType();
  }
}
inline ::strategy_trader::OrderPositionReq* message::release_position_req() {
  // @@protoc_insertion_point(field_release:strategy_trader.message.position_req)
  if (_internal_has_position_req()) {
    clear_has_MessageType();
    ::strategy_trader::OrderPositionReq* temp = _impl_.MessageType_.position_req_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.MessageType_.position_req_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::strategy_trader::OrderPositionReq& message::_internal_position_req() const {
  return _internal_has_position_req()
      ? *_impl_.MessageType_.position_req_
      : reinterpret_cast< ::strategy_trader::OrderPositionReq&>(::strategy_trader::_OrderPositionReq_default_instance_);
}
inline const ::strategy_trader::OrderPositionReq& message::position_req() const {
  // @@protoc_insertion_point(field_get:strategy_trader.message.position_req)
  return _internal_position_req();
}
inline ::strategy_trader::OrderPositionReq* message::unsafe_arena_release_position_req() {
  // @@protoc_insertion_point(field_unsafe_arena_release:strategy_trader.message.position_req)
  if (_internal_has_position_req()) {
    clear_has_MessageType();
    ::strategy_trader::OrderPositionReq* temp = _impl_.MessageType_.position_req_;
    _impl_.MessageType_.position_req_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void message::unsafe_arena_set_allocated_position_req(::strategy_trader::OrderPositionReq* position_req) {
  clear_MessageType();
  if (position_req) {
    set_has_position_req();
    _impl_.MessageType_.position_req_ = position_req;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:strategy_trader.message.position_req)
}
inline ::strategy_trader::OrderPositionReq* message::_internal_mutable_position_req() {
  if (!_internal_has_position_req()) {
    clear_MessageType();
    set_has_position_req();
    _impl_.MessageType_.position_req_ = CreateMaybeMessage< ::strategy_trader::OrderPositionReq >(GetArenaForAllocation());
  }
  return _impl_.MessageType_.position_req_;
}
inline ::strategy_trader::OrderPositionReq* message::mutable_position_req() {
  ::strategy_trader::OrderPositionReq* _msg = _internal_mutable_position_req();
  // @@protoc_insertion_point(field_mutable:strategy_trader.message.position_req)
  return _msg;
}

// .strategy_trader.OrderPositionRsp position_rsp = 17;
inline bool message::_internal_has_position_rsp() const {
  return MessageType_case() == kPositionRsp;
}
inline bool message::has_position_rsp() const {
  return _internal_has_position_rsp();
}
inline void message::set_has_position_rsp() {
  _impl_._oneof_case_[0] = kPositionRsp;
}
inline void message::clear_position_rsp() {
  if (_internal_has_position_rsp()) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.MessageType_.position_rsp_;
    }
    clear_has_MessageType();
  }
}
inline ::strategy_trader::OrderPositionRsp* message::release_position_rsp() {
  // @@protoc_insertion_point(field_release:strategy_trader.message.position_rsp)
  if (_internal_has_position_rsp()) {
    clear_has_MessageType();
    ::strategy_trader::OrderPositionRsp* temp = _impl_.MessageType_.position_rsp_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.MessageType_.position_rsp_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::strategy_trader::OrderPositionRsp& message::_internal_position_rsp() const {
  return _internal_has_position_rsp()
      ? *_impl_.MessageType_.position_rsp_
      : reinterpret_cast< ::strategy_trader::OrderPositionRsp&>(::strategy_trader::_OrderPositionRsp_default_instance_);
}
inline const ::strategy_trader::OrderPositionRsp& message::position_rsp() const {
  // @@protoc_insertion_point(field_get:strategy_trader.message.position_rsp)
  return _internal_position_rsp();
}
inline ::strategy_trader::OrderPositionRsp* message::unsafe_arena_release_position_rsp() {
  // @@protoc_insertion_point(field_unsafe_arena_release:strategy_trader.message.position_rsp)
  if (_internal_has_position_rsp()) {
    clear_has_MessageType();
    ::strategy_trader::OrderPositionRsp* temp = _impl_.MessageType_.position_rsp_;
    _impl_.MessageType_.position_rsp_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void message::unsafe_arena_set_allocated_position_rsp(::strategy_trader::OrderPositionRsp* position_rsp) {
  clear_MessageType();
  if (position_rsp) {
    set_has_position_rsp();
    _impl_.MessageType_.position_rsp_ = position_rsp;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:strategy_trader.message.position_rsp)
}
inline ::strategy_trader::OrderPositionRsp* message::_internal_mutable_position_rsp() {
  if (!_internal_has_position_rsp()) {
    clear_MessageType();
    set_has_position_rsp();
    _impl_.MessageType_.position_rsp_ = CreateMaybeMessage< ::strategy_trader::OrderPositionRsp >(GetArenaForAllocation());
  }
  return _impl_.MessageType_.position_rsp_;
}
inline ::strategy_trader::OrderPositionRsp* message::mutable_position_rsp() {
  ::strategy_trader::OrderPositionRsp* _msg = _internal_mutable_position_rsp();
  // @@protoc_insertion_point(field_mutable:strategy_trader.message.position_rsp)
  return _msg;
}

// .strategy_trader.GroupSizeReq group_size_req = 18;
inline bool message::_internal_has_group_size_req() const {
  return MessageType_case() == kGroupSizeReq;
}
inline bool message::has_group_size_req() const {
  return _internal_has_group_size_req();
}
inline void message::set_has_group_size_req() {
  _impl_._oneof_case_[0] = kGroupSizeReq;
}
inline void message::clear_group_size_req() {
  if (_internal_has_group_size_req()) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.MessageType_.group_size_req_;
    }
    clear_has_MessageType();
  }
}
inline ::strategy_trader::GroupSizeReq* message::release_group_size_req() {
  // @@protoc_insertion_point(field_release:strategy_trader.message.group_size_req)
  if (_internal_has_group_size_req()) {
    clear_has_MessageType();
    ::strategy_trader::GroupSizeReq* temp = _impl_.MessageType_.group_size_req_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.MessageType_.group_size_req_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::strategy_trader::GroupSizeReq& message::_internal_group_size_req() const {
  return _internal_has_group_size_req()
      ? *_impl_.MessageType_.group_size_req_
      : reinterpret_cast< ::strategy_trader::GroupSizeReq&>(::strategy_trader::_GroupSizeReq_default_instance_);
}
inline const ::strategy_trader::GroupSizeReq& message::group_size_req() const {
  // @@protoc_insertion_point(field_get:strategy_trader.message.group_size_req)
  return _internal_group_size_req();
}
inline ::strategy_trader::GroupSizeReq* message::unsafe_arena_release_group_size_req() {
  // @@protoc_insertion_point(field_unsafe_arena_release:strategy_trader.message.group_size_req)
  if (_internal_has_group_size_req()) {
    clear_has_MessageType();
    ::strategy_trader::GroupSizeReq* temp = _impl_.MessageType_.group_size_req_;
    _impl_.MessageType_.group_size_req_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void message::unsafe_arena_set_allocated_group_size_req(::strategy_trader::GroupSizeReq* group_size_req) {
  clear_MessageType();
  if (group_size_req) {
    set_has_group_size_req();
    _impl_.MessageType_.group_size_req_ = group_size_req;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:strategy_trader.message.group_size_req)
}
inline ::strategy_trader::GroupSizeReq* message::_internal_mutable_group_size_req() {
  if (!_internal_has_group_size_req()) {
    clear_MessageType();
    set_has_group_size_req();
    _impl_.MessageType_.group_size_req_ = CreateMaybeMessage< ::strategy_trader::GroupSizeReq >(GetArenaForAllocation());
  }
  return _impl_.MessageType_.group_size_req_;
}
inline ::strategy_trader::GroupSizeReq* message::mutable_group_size_req() {
  ::strategy_trader::GroupSizeReq* _msg = _internal_mutable_group_size_req();
  // @@protoc_insertion_point(field_mutable:strategy_trader.message.group_size_req)
  return _msg;
}

// .strategy_trader.GroupSizeRsp group_size_rsp = 19;
inline bool message::_internal_has_group_size_rsp() const {
  return MessageType_case() == kGroupSizeRsp;
}
inline bool message::has_group_size_rsp() const {
  return _internal_has_group_size_rsp();
}
inline void message::set_has_group_size_rsp() {
  _impl_._oneof_case_[0] = kGroupSizeRsp;
}
inline void message::clear_group_size_rsp() {
  if (_internal_has_group_size_rsp()) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.MessageType_.group_size_rsp_;
    }
    clear_has_MessageType();
  }
}
inline ::strategy_trader::GroupSizeRsp* message::release_group_size_rsp() {
  // @@protoc_insertion_point(field_release:strategy_trader.message.group_size_rsp)
  if (_internal_has_group_size_rsp()) {
    clear_has_MessageType();
    ::strategy_trader::GroupSizeRsp* temp = _impl_.MessageType_.group_size_rsp_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.MessageType_.group_size_rsp_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::strategy_trader::GroupSizeRsp& message::_internal_group_size_rsp() const {
  return _internal_has_group_size_rsp()
      ? *_impl_.MessageType_.group_size_rsp_
      : reinterpret_cast< ::strategy_trader::GroupSizeRsp&>(::strategy_trader::_GroupSizeRsp_default_instance_);
}
inline const ::strategy_trader::GroupSizeRsp& message::group_size_rsp() const {
  // @@protoc_insertion_point(field_get:strategy_trader.message.group_size_rsp)
  return _internal_group_size_rsp();
}
inline ::strategy_trader::GroupSizeRsp* message::unsafe_arena_release_group_size_rsp() {
  // @@protoc_insertion_point(field_unsafe_arena_release:strategy_trader.message.group_size_rsp)
  if (_internal_has_group_size_rsp()) {
    clear_has_MessageType();
    ::strategy_trader::GroupSizeRsp* temp = _impl_.MessageType_.group_size_rsp_;
    _impl_.MessageType_.group_size_rsp_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void message::unsafe_arena_set_allocated_group_size_rsp(::strategy_trader::GroupSizeRsp* group_size_rsp) {
  clear_MessageType();
  if (group_size_rsp) {
    set_has_group_size_rsp();
    _impl_.MessageType_.group_size_rsp_ = group_size_rsp;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:strategy_trader.message.group_size_rsp)
}
inline ::strategy_trader::GroupSizeRsp* message::_internal_mutable_group_size_rsp() {
  if (!_internal_has_group_size_rsp()) {
    clear_MessageType();
    set_has_group_size_rsp();
    _impl_.MessageType_.group_size_rsp_ = CreateMaybeMessage< ::strategy_trader::GroupSizeRsp >(GetArenaForAllocation());
  }
  return _impl_.MessageType_.group_size_rsp_;
}
inline ::strategy_trader::GroupSizeRsp* message::mutable_group_size_rsp() {
  ::strategy_trader::GroupSizeRsp* _msg = _internal_mutable_group_size_rsp();
  // @@protoc_insertion_point(field_mutable:strategy_trader.message.group_size_rsp)
  return _msg;
}

inline bool message::has_MessageType() const {
  return MessageType_case() != MESSAGETYPE_NOT_SET;
}
inline void message::clear_has_MessageType() {
  _impl_._oneof_case_[0] = MESSAGETYPE_NOT_SET;
}
inline message::MessageTypeCase message::MessageType_case() const {
  return message::MessageTypeCase(_impl_._oneof_case_[0]);
}
// -------------------------------------------------------------------

// OrderCancelReq

// string instrument = 1;
inline void OrderCancelReq::clear_instrument() {
  _impl_.instrument_.ClearToEmpty();
}
inline const std::string& OrderCancelReq::instrument() const {
  // @@protoc_insertion_point(field_get:strategy_trader.OrderCancelReq.instrument)
  return _internal_instrument();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void OrderCancelReq::set_instrument(ArgT0&& arg0, ArgT... args) {
 
 _impl_.instrument_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:strategy_trader.OrderCancelReq.instrument)
}
inline std::string* OrderCancelReq::mutable_instrument() {
  std::string* _s = _internal_mutable_instrument();
  // @@protoc_insertion_point(field_mutable:strategy_trader.OrderCancelReq.instrument)
  return _s;
}
inline const std::string& OrderCancelReq::_internal_instrument() const {
  return _impl_.instrument_.Get();
}
inline void OrderCancelReq::_internal_set_instrument(const std::string& value) {
  
  _impl_.instrument_.Set(value, GetArenaForAllocation());
}
inline std::string* OrderCancelReq::_internal_mutable_instrument() {
  
  return _impl_.instrument_.Mutable(GetArenaForAllocation());
}
inline std::string* OrderCancelReq::release_instrument() {
  // @@protoc_insertion_point(field_release:strategy_trader.OrderCancelReq.instrument)
  return _impl_.instrument_.Release();
}
inline void OrderCancelReq::set_allocated_instrument(std::string* instrument) {
  if (instrument != nullptr) {
    
  } else {
    
  }
  _impl_.instrument_.SetAllocated(instrument, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.instrument_.IsDefault()) {
    _impl_.instrument_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:strategy_trader.OrderCancelReq.instrument)
}

// string index = 2;
inline void OrderCancelReq::clear_index() {
  _impl_.index_.ClearToEmpty();
}
inline const std::string& OrderCancelReq::index() const {
  // @@protoc_insertion_point(field_get:strategy_trader.OrderCancelReq.index)
  return _internal_index();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void OrderCancelReq::set_index(ArgT0&& arg0, ArgT... args) {
 
 _impl_.index_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:strategy_trader.OrderCancelReq.index)
}
inline std::string* OrderCancelReq::mutable_index() {
  std::string* _s = _internal_mutable_index();
  // @@protoc_insertion_point(field_mutable:strategy_trader.OrderCancelReq.index)
  return _s;
}
inline const std::string& OrderCancelReq::_internal_index() const {
  return _impl_.index_.Get();
}
inline void OrderCancelReq::_internal_set_index(const std::string& value) {
  
  _impl_.index_.Set(value, GetArenaForAllocation());
}
inline std::string* OrderCancelReq::_internal_mutable_index() {
  
  return _impl_.index_.Mutable(GetArenaForAllocation());
}
inline std::string* OrderCancelReq::release_index() {
  // @@protoc_insertion_point(field_release:strategy_trader.OrderCancelReq.index)
  return _impl_.index_.Release();
}
inline void OrderCancelReq::set_allocated_index(std::string* index) {
  if (index != nullptr) {
    
  } else {
    
  }
  _impl_.index_.SetAllocated(index, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.index_.IsDefault()) {
    _impl_.index_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:strategy_trader.OrderCancelReq.index)
}

// -------------------------------------------------------------------

// OrderCancelRsp

// string instrument = 1;
inline void OrderCancelRsp::clear_instrument() {
  _impl_.instrument_.ClearToEmpty();
}
inline const std::string& OrderCancelRsp::instrument() const {
  // @@protoc_insertion_point(field_get:strategy_trader.OrderCancelRsp.instrument)
  return _internal_instrument();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void OrderCancelRsp::set_instrument(ArgT0&& arg0, ArgT... args) {
 
 _impl_.instrument_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:strategy_trader.OrderCancelRsp.instrument)
}
inline std::string* OrderCancelRsp::mutable_instrument() {
  std::string* _s = _internal_mutable_instrument();
  // @@protoc_insertion_point(field_mutable:strategy_trader.OrderCancelRsp.instrument)
  return _s;
}
inline const std::string& OrderCancelRsp::_internal_instrument() const {
  return _impl_.instrument_.Get();
}
inline void OrderCancelRsp::_internal_set_instrument(const std::string& value) {
  
  _impl_.instrument_.Set(value, GetArenaForAllocation());
}
inline std::string* OrderCancelRsp::_internal_mutable_instrument() {
  
  return _impl_.instrument_.Mutable(GetArenaForAllocation());
}
inline std::string* OrderCancelRsp::release_instrument() {
  // @@protoc_insertion_point(field_release:strategy_trader.OrderCancelRsp.instrument)
  return _impl_.instrument_.Release();
}
inline void OrderCancelRsp::set_allocated_instrument(std::string* instrument) {
  if (instrument != nullptr) {
    
  } else {
    
  }
  _impl_.instrument_.SetAllocated(instrument, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.instrument_.IsDefault()) {
    _impl_.instrument_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:strategy_trader.OrderCancelRsp.instrument)
}

// string index = 2;
inline void OrderCancelRsp::clear_index() {
  _impl_.index_.ClearToEmpty();
}
inline const std::string& OrderCancelRsp::index() const {
  // @@protoc_insertion_point(field_get:strategy_trader.OrderCancelRsp.index)
  return _internal_index();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void OrderCancelRsp::set_index(ArgT0&& arg0, ArgT... args) {
 
 _impl_.index_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:strategy_trader.OrderCancelRsp.index)
}
inline std::string* OrderCancelRsp::mutable_index() {
  std::string* _s = _internal_mutable_index();
  // @@protoc_insertion_point(field_mutable:strategy_trader.OrderCancelRsp.index)
  return _s;
}
inline const std::string& OrderCancelRsp::_internal_index() const {
  return _impl_.index_.Get();
}
inline void OrderCancelRsp::_internal_set_index(const std::string& value) {
  
  _impl_.index_.Set(value, GetArenaForAllocation());
}
inline std::string* OrderCancelRsp::_internal_mutable_index() {
  
  return _impl_.index_.Mutable(GetArenaForAllocation());
}
inline std::string* OrderCancelRsp::release_index() {
  // @@protoc_insertion_point(field_release:strategy_trader.OrderCancelRsp.index)
  return _impl_.index_.Release();
}
inline void OrderCancelRsp::set_allocated_index(std::string* index) {
  if (index != nullptr) {
    
  } else {
    
  }
  _impl_.index_.SetAllocated(index, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.index_.IsDefault()) {
    _impl_.index_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:strategy_trader.OrderCancelRsp.index)
}

// .strategy_trader.Result result = 3;
inline void OrderCancelRsp::clear_result() {
  _impl_.result_ = 0;
}
inline ::strategy_trader::Result OrderCancelRsp::_internal_result() const {
  return static_cast< ::strategy_trader::Result >(_impl_.result_);
}
inline ::strategy_trader::Result OrderCancelRsp::result() const {
  // @@protoc_insertion_point(field_get:strategy_trader.OrderCancelRsp.result)
  return _internal_result();
}
inline void OrderCancelRsp::_internal_set_result(::strategy_trader::Result value) {
  
  _impl_.result_ = value;
}
inline void OrderCancelRsp::set_result(::strategy_trader::Result value) {
  _internal_set_result(value);
  // @@protoc_insertion_point(field_set:strategy_trader.OrderCancelRsp.result)
}

// .strategy_trader.RspInfo info = 4;
inline bool OrderCancelRsp::_internal_has_info() const {
  return this != internal_default_instance() && _impl_.info_ != nullptr;
}
inline bool OrderCancelRsp::has_info() const {
  return _internal_has_info();
}
inline void OrderCancelRsp::clear_info() {
  if (GetArenaForAllocation() == nullptr && _impl_.info_ != nullptr) {
    delete _impl_.info_;
  }
  _impl_.info_ = nullptr;
}
inline const ::strategy_trader::RspInfo& OrderCancelRsp::_internal_info() const {
  const ::strategy_trader::RspInfo* p = _impl_.info_;
  return p != nullptr ? *p : reinterpret_cast<const ::strategy_trader::RspInfo&>(
      ::strategy_trader::_RspInfo_default_instance_);
}
inline const ::strategy_trader::RspInfo& OrderCancelRsp::info() const {
  // @@protoc_insertion_point(field_get:strategy_trader.OrderCancelRsp.info)
  return _internal_info();
}
inline void OrderCancelRsp::unsafe_arena_set_allocated_info(
    ::strategy_trader::RspInfo* info) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.info_);
  }
  _impl_.info_ = info;
  if (info) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:strategy_trader.OrderCancelRsp.info)
}
inline ::strategy_trader::RspInfo* OrderCancelRsp::release_info() {
  
  ::strategy_trader::RspInfo* temp = _impl_.info_;
  _impl_.info_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::strategy_trader::RspInfo* OrderCancelRsp::unsafe_arena_release_info() {
  // @@protoc_insertion_point(field_release:strategy_trader.OrderCancelRsp.info)
  
  ::strategy_trader::RspInfo* temp = _impl_.info_;
  _impl_.info_ = nullptr;
  return temp;
}
inline ::strategy_trader::RspInfo* OrderCancelRsp::_internal_mutable_info() {
  
  if (_impl_.info_ == nullptr) {
    auto* p = CreateMaybeMessage<::strategy_trader::RspInfo>(GetArenaForAllocation());
    _impl_.info_ = p;
  }
  return _impl_.info_;
}
inline ::strategy_trader::RspInfo* OrderCancelRsp::mutable_info() {
  ::strategy_trader::RspInfo* _msg = _internal_mutable_info();
  // @@protoc_insertion_point(field_mutable:strategy_trader.OrderCancelRsp.info)
  return _msg;
}
inline void OrderCancelRsp::set_allocated_info(::strategy_trader::RspInfo* info) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.info_;
  }
  if (info) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(info);
    if (message_arena != submessage_arena) {
      info = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, info, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.info_ = info;
  // @@protoc_insertion_point(field_set_allocated:strategy_trader.OrderCancelRsp.info)
}

// string failedReason = 5;
inline void OrderCancelRsp::clear_failedreason() {
  _impl_.failedreason_.ClearToEmpty();
}
inline const std::string& OrderCancelRsp::failedreason() const {
  // @@protoc_insertion_point(field_get:strategy_trader.OrderCancelRsp.failedReason)
  return _internal_failedreason();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void OrderCancelRsp::set_failedreason(ArgT0&& arg0, ArgT... args) {
 
 _impl_.failedreason_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:strategy_trader.OrderCancelRsp.failedReason)
}
inline std::string* OrderCancelRsp::mutable_failedreason() {
  std::string* _s = _internal_mutable_failedreason();
  // @@protoc_insertion_point(field_mutable:strategy_trader.OrderCancelRsp.failedReason)
  return _s;
}
inline const std::string& OrderCancelRsp::_internal_failedreason() const {
  return _impl_.failedreason_.Get();
}
inline void OrderCancelRsp::_internal_set_failedreason(const std::string& value) {
  
  _impl_.failedreason_.Set(value, GetArenaForAllocation());
}
inline std::string* OrderCancelRsp::_internal_mutable_failedreason() {
  
  return _impl_.failedreason_.Mutable(GetArenaForAllocation());
}
inline std::string* OrderCancelRsp::release_failedreason() {
  // @@protoc_insertion_point(field_release:strategy_trader.OrderCancelRsp.failedReason)
  return _impl_.failedreason_.Release();
}
inline void OrderCancelRsp::set_allocated_failedreason(std::string* failedreason) {
  if (failedreason != nullptr) {
    
  } else {
    
  }
  _impl_.failedreason_.SetAllocated(failedreason, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.failedreason_.IsDefault()) {
    _impl_.failedreason_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:strategy_trader.OrderCancelRsp.failedReason)
}

// -------------------------------------------------------------------

// AccountStatusRsp

// string user_id = 1;
inline void AccountStatusRsp::clear_user_id() {
  _impl_.user_id_.ClearToEmpty();
}
inline const std::string& AccountStatusRsp::user_id() const {
  // @@protoc_insertion_point(field_get:strategy_trader.AccountStatusRsp.user_id)
  return _internal_user_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void AccountStatusRsp::set_user_id(ArgT0&& arg0, ArgT... args) {
 
 _impl_.user_id_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:strategy_trader.AccountStatusRsp.user_id)
}
inline std::string* AccountStatusRsp::mutable_user_id() {
  std::string* _s = _internal_mutable_user_id();
  // @@protoc_insertion_point(field_mutable:strategy_trader.AccountStatusRsp.user_id)
  return _s;
}
inline const std::string& AccountStatusRsp::_internal_user_id() const {
  return _impl_.user_id_.Get();
}
inline void AccountStatusRsp::_internal_set_user_id(const std::string& value) {
  
  _impl_.user_id_.Set(value, GetArenaForAllocation());
}
inline std::string* AccountStatusRsp::_internal_mutable_user_id() {
  
  return _impl_.user_id_.Mutable(GetArenaForAllocation());
}
inline std::string* AccountStatusRsp::release_user_id() {
  // @@protoc_insertion_point(field_release:strategy_trader.AccountStatusRsp.user_id)
  return _impl_.user_id_.Release();
}
inline void AccountStatusRsp::set_allocated_user_id(std::string* user_id) {
  if (user_id != nullptr) {
    
  } else {
    
  }
  _impl_.user_id_.SetAllocated(user_id, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.user_id_.IsDefault()) {
    _impl_.user_id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:strategy_trader.AccountStatusRsp.user_id)
}

// double Balance = 2;
inline void AccountStatusRsp::clear_balance() {
  _impl_.balance_ = 0;
}
inline double AccountStatusRsp::_internal_balance() const {
  return _impl_.balance_;
}
inline double AccountStatusRsp::balance() const {
  // @@protoc_insertion_point(field_get:strategy_trader.AccountStatusRsp.Balance)
  return _internal_balance();
}
inline void AccountStatusRsp::_internal_set_balance(double value) {
  
  _impl_.balance_ = value;
}
inline void AccountStatusRsp::set_balance(double value) {
  _internal_set_balance(value);
  // @@protoc_insertion_point(field_set:strategy_trader.AccountStatusRsp.Balance)
}

// double Available = 3;
inline void AccountStatusRsp::clear_available() {
  _impl_.available_ = 0;
}
inline double AccountStatusRsp::_internal_available() const {
  return _impl_.available_;
}
inline double AccountStatusRsp::available() const {
  // @@protoc_insertion_point(field_get:strategy_trader.AccountStatusRsp.Available)
  return _internal_available();
}
inline void AccountStatusRsp::_internal_set_available(double value) {
  
  _impl_.available_ = value;
}
inline void AccountStatusRsp::set_available(double value) {
  _internal_set_available(value);
  // @@protoc_insertion_point(field_set:strategy_trader.AccountStatusRsp.Available)
}

// uint64 session_id = 4;
inline void AccountStatusRsp::clear_session_id() {
  _impl_.session_id_ = uint64_t{0u};
}
inline uint64_t AccountStatusRsp::_internal_session_id() const {
  return _impl_.session_id_;
}
inline uint64_t AccountStatusRsp::session_id() const {
  // @@protoc_insertion_point(field_get:strategy_trader.AccountStatusRsp.session_id)
  return _internal_session_id();
}
inline void AccountStatusRsp::_internal_set_session_id(uint64_t value) {
  
  _impl_.session_id_ = value;
}
inline void AccountStatusRsp::set_session_id(uint64_t value) {
  _internal_set_session_id(value);
  // @@protoc_insertion_point(field_set:strategy_trader.AccountStatusRsp.session_id)
}

// .strategy_trader.Result result = 5;
inline void AccountStatusRsp::clear_result() {
  _impl_.result_ = 0;
}
inline ::strategy_trader::Result AccountStatusRsp::_internal_result() const {
  return static_cast< ::strategy_trader::Result >(_impl_.result_);
}
inline ::strategy_trader::Result AccountStatusRsp::result() const {
  // @@protoc_insertion_point(field_get:strategy_trader.AccountStatusRsp.result)
  return _internal_result();
}
inline void AccountStatusRsp::_internal_set_result(::strategy_trader::Result value) {
  
  _impl_.result_ = value;
}
inline void AccountStatusRsp::set_result(::strategy_trader::Result value) {
  _internal_set_result(value);
  // @@protoc_insertion_point(field_set:strategy_trader.AccountStatusRsp.result)
}

// string failedReason = 6;
inline void AccountStatusRsp::clear_failedreason() {
  _impl_.failedreason_.ClearToEmpty();
}
inline const std::string& AccountStatusRsp::failedreason() const {
  // @@protoc_insertion_point(field_get:strategy_trader.AccountStatusRsp.failedReason)
  return _internal_failedreason();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void AccountStatusRsp::set_failedreason(ArgT0&& arg0, ArgT... args) {
 
 _impl_.failedreason_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:strategy_trader.AccountStatusRsp.failedReason)
}
inline std::string* AccountStatusRsp::mutable_failedreason() {
  std::string* _s = _internal_mutable_failedreason();
  // @@protoc_insertion_point(field_mutable:strategy_trader.AccountStatusRsp.failedReason)
  return _s;
}
inline const std::string& AccountStatusRsp::_internal_failedreason() const {
  return _impl_.failedreason_.Get();
}
inline void AccountStatusRsp::_internal_set_failedreason(const std::string& value) {
  
  _impl_.failedreason_.Set(value, GetArenaForAllocation());
}
inline std::string* AccountStatusRsp::_internal_mutable_failedreason() {
  
  return _impl_.failedreason_.Mutable(GetArenaForAllocation());
}
inline std::string* AccountStatusRsp::release_failedreason() {
  // @@protoc_insertion_point(field_release:strategy_trader.AccountStatusRsp.failedReason)
  return _impl_.failedreason_.Release();
}
inline void AccountStatusRsp::set_allocated_failedreason(std::string* failedreason) {
  if (failedreason != nullptr) {
    
  } else {
    
  }
  _impl_.failedreason_.SetAllocated(failedreason, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.failedreason_.IsDefault()) {
    _impl_.failedreason_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:strategy_trader.AccountStatusRsp.failedReason)
}

// -------------------------------------------------------------------

// OrderInsertRsp

// string instrument = 1;
inline void OrderInsertRsp::clear_instrument() {
  _impl_.instrument_.ClearToEmpty();
}
inline const std::string& OrderInsertRsp::instrument() const {
  // @@protoc_insertion_point(field_get:strategy_trader.OrderInsertRsp.instrument)
  return _internal_instrument();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void OrderInsertRsp::set_instrument(ArgT0&& arg0, ArgT... args) {
 
 _impl_.instrument_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:strategy_trader.OrderInsertRsp.instrument)
}
inline std::string* OrderInsertRsp::mutable_instrument() {
  std::string* _s = _internal_mutable_instrument();
  // @@protoc_insertion_point(field_mutable:strategy_trader.OrderInsertRsp.instrument)
  return _s;
}
inline const std::string& OrderInsertRsp::_internal_instrument() const {
  return _impl_.instrument_.Get();
}
inline void OrderInsertRsp::_internal_set_instrument(const std::string& value) {
  
  _impl_.instrument_.Set(value, GetArenaForAllocation());
}
inline std::string* OrderInsertRsp::_internal_mutable_instrument() {
  
  return _impl_.instrument_.Mutable(GetArenaForAllocation());
}
inline std::string* OrderInsertRsp::release_instrument() {
  // @@protoc_insertion_point(field_release:strategy_trader.OrderInsertRsp.instrument)
  return _impl_.instrument_.Release();
}
inline void OrderInsertRsp::set_allocated_instrument(std::string* instrument) {
  if (instrument != nullptr) {
    
  } else {
    
  }
  _impl_.instrument_.SetAllocated(instrument, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.instrument_.IsDefault()) {
    _impl_.instrument_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:strategy_trader.OrderInsertRsp.instrument)
}

// string index = 2;
inline void OrderInsertRsp::clear_index() {
  _impl_.index_.ClearToEmpty();
}
inline const std::string& OrderInsertRsp::index() const {
  // @@protoc_insertion_point(field_get:strategy_trader.OrderInsertRsp.index)
  return _internal_index();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void OrderInsertRsp::set_index(ArgT0&& arg0, ArgT... args) {
 
 _impl_.index_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:strategy_trader.OrderInsertRsp.index)
}
inline std::string* OrderInsertRsp::mutable_index() {
  std::string* _s = _internal_mutable_index();
  // @@protoc_insertion_point(field_mutable:strategy_trader.OrderInsertRsp.index)
  return _s;
}
inline const std::string& OrderInsertRsp::_internal_index() const {
  return _impl_.index_.Get();
}
inline void OrderInsertRsp::_internal_set_index(const std::string& value) {
  
  _impl_.index_.Set(value, GetArenaForAllocation());
}
inline std::string* OrderInsertRsp::_internal_mutable_index() {
  
  return _impl_.index_.Mutable(GetArenaForAllocation());
}
inline std::string* OrderInsertRsp::release_index() {
  // @@protoc_insertion_point(field_release:strategy_trader.OrderInsertRsp.index)
  return _impl_.index_.Release();
}
inline void OrderInsertRsp::set_allocated_index(std::string* index) {
  if (index != nullptr) {
    
  } else {
    
  }
  _impl_.index_.SetAllocated(index, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.index_.IsDefault()) {
    _impl_.index_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:strategy_trader.OrderInsertRsp.index)
}

// .strategy_trader.Result result = 3;
inline void OrderInsertRsp::clear_result() {
  _impl_.result_ = 0;
}
inline ::strategy_trader::Result OrderInsertRsp::_internal_result() const {
  return static_cast< ::strategy_trader::Result >(_impl_.result_);
}
inline ::strategy_trader::Result OrderInsertRsp::result() const {
  // @@protoc_insertion_point(field_get:strategy_trader.OrderInsertRsp.result)
  return _internal_result();
}
inline void OrderInsertRsp::_internal_set_result(::strategy_trader::Result value) {
  
  _impl_.result_ = value;
}
inline void OrderInsertRsp::set_result(::strategy_trader::Result value) {
  _internal_set_result(value);
  // @@protoc_insertion_point(field_set:strategy_trader.OrderInsertRsp.result)
}

// .strategy_trader.RspInfo info = 4;
inline bool OrderInsertRsp::_internal_has_info() const {
  return this != internal_default_instance() && _impl_.info_ != nullptr;
}
inline bool OrderInsertRsp::has_info() const {
  return _internal_has_info();
}
inline void OrderInsertRsp::clear_info() {
  if (GetArenaForAllocation() == nullptr && _impl_.info_ != nullptr) {
    delete _impl_.info_;
  }
  _impl_.info_ = nullptr;
}
inline const ::strategy_trader::RspInfo& OrderInsertRsp::_internal_info() const {
  const ::strategy_trader::RspInfo* p = _impl_.info_;
  return p != nullptr ? *p : reinterpret_cast<const ::strategy_trader::RspInfo&>(
      ::strategy_trader::_RspInfo_default_instance_);
}
inline const ::strategy_trader::RspInfo& OrderInsertRsp::info() const {
  // @@protoc_insertion_point(field_get:strategy_trader.OrderInsertRsp.info)
  return _internal_info();
}
inline void OrderInsertRsp::unsafe_arena_set_allocated_info(
    ::strategy_trader::RspInfo* info) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.info_);
  }
  _impl_.info_ = info;
  if (info) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:strategy_trader.OrderInsertRsp.info)
}
inline ::strategy_trader::RspInfo* OrderInsertRsp::release_info() {
  
  ::strategy_trader::RspInfo* temp = _impl_.info_;
  _impl_.info_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::strategy_trader::RspInfo* OrderInsertRsp::unsafe_arena_release_info() {
  // @@protoc_insertion_point(field_release:strategy_trader.OrderInsertRsp.info)
  
  ::strategy_trader::RspInfo* temp = _impl_.info_;
  _impl_.info_ = nullptr;
  return temp;
}
inline ::strategy_trader::RspInfo* OrderInsertRsp::_internal_mutable_info() {
  
  if (_impl_.info_ == nullptr) {
    auto* p = CreateMaybeMessage<::strategy_trader::RspInfo>(GetArenaForAllocation());
    _impl_.info_ = p;
  }
  return _impl_.info_;
}
inline ::strategy_trader::RspInfo* OrderInsertRsp::mutable_info() {
  ::strategy_trader::RspInfo* _msg = _internal_mutable_info();
  // @@protoc_insertion_point(field_mutable:strategy_trader.OrderInsertRsp.info)
  return _msg;
}
inline void OrderInsertRsp::set_allocated_info(::strategy_trader::RspInfo* info) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.info_;
  }
  if (info) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(info);
    if (message_arena != submessage_arena) {
      info = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, info, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.info_ = info;
  // @@protoc_insertion_point(field_set_allocated:strategy_trader.OrderInsertRsp.info)
}

// .strategy_trader.FailedReason reason = 5;
inline void OrderInsertRsp::clear_reason() {
  _impl_.reason_ = 0;
}
inline ::strategy_trader::FailedReason OrderInsertRsp::_internal_reason() const {
  return static_cast< ::strategy_trader::FailedReason >(_impl_.reason_);
}
inline ::strategy_trader::FailedReason OrderInsertRsp::reason() const {
  // @@protoc_insertion_point(field_get:strategy_trader.OrderInsertRsp.reason)
  return _internal_reason();
}
inline void OrderInsertRsp::_internal_set_reason(::strategy_trader::FailedReason value) {
  
  _impl_.reason_ = value;
}
inline void OrderInsertRsp::set_reason(::strategy_trader::FailedReason value) {
  _internal_set_reason(value);
  // @@protoc_insertion_point(field_set:strategy_trader.OrderInsertRsp.reason)
}

// -------------------------------------------------------------------

// OrderInsertReq

// string instrument = 1;
inline void OrderInsertReq::clear_instrument() {
  _impl_.instrument_.ClearToEmpty();
}
inline const std::string& OrderInsertReq::instrument() const {
  // @@protoc_insertion_point(field_get:strategy_trader.OrderInsertReq.instrument)
  return _internal_instrument();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void OrderInsertReq::set_instrument(ArgT0&& arg0, ArgT... args) {
 
 _impl_.instrument_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:strategy_trader.OrderInsertReq.instrument)
}
inline std::string* OrderInsertReq::mutable_instrument() {
  std::string* _s = _internal_mutable_instrument();
  // @@protoc_insertion_point(field_mutable:strategy_trader.OrderInsertReq.instrument)
  return _s;
}
inline const std::string& OrderInsertReq::_internal_instrument() const {
  return _impl_.instrument_.Get();
}
inline void OrderInsertReq::_internal_set_instrument(const std::string& value) {
  
  _impl_.instrument_.Set(value, GetArenaForAllocation());
}
inline std::string* OrderInsertReq::_internal_mutable_instrument() {
  
  return _impl_.instrument_.Mutable(GetArenaForAllocation());
}
inline std::string* OrderInsertReq::release_instrument() {
  // @@protoc_insertion_point(field_release:strategy_trader.OrderInsertReq.instrument)
  return _impl_.instrument_.Release();
}
inline void OrderInsertReq::set_allocated_instrument(std::string* instrument) {
  if (instrument != nullptr) {
    
  } else {
    
  }
  _impl_.instrument_.SetAllocated(instrument, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.instrument_.IsDefault()) {
    _impl_.instrument_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:strategy_trader.OrderInsertReq.instrument)
}

// string index = 2;
inline void OrderInsertReq::clear_index() {
  _impl_.index_.ClearToEmpty();
}
inline const std::string& OrderInsertReq::index() const {
  // @@protoc_insertion_point(field_get:strategy_trader.OrderInsertReq.index)
  return _internal_index();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void OrderInsertReq::set_index(ArgT0&& arg0, ArgT... args) {
 
 _impl_.index_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:strategy_trader.OrderInsertReq.index)
}
inline std::string* OrderInsertReq::mutable_index() {
  std::string* _s = _internal_mutable_index();
  // @@protoc_insertion_point(field_mutable:strategy_trader.OrderInsertReq.index)
  return _s;
}
inline const std::string& OrderInsertReq::_internal_index() const {
  return _impl_.index_.Get();
}
inline void OrderInsertReq::_internal_set_index(const std::string& value) {
  
  _impl_.index_.Set(value, GetArenaForAllocation());
}
inline std::string* OrderInsertReq::_internal_mutable_index() {
  
  return _impl_.index_.Mutable(GetArenaForAllocation());
}
inline std::string* OrderInsertReq::release_index() {
  // @@protoc_insertion_point(field_release:strategy_trader.OrderInsertReq.index)
  return _impl_.index_.Release();
}
inline void OrderInsertReq::set_allocated_index(std::string* index) {
  if (index != nullptr) {
    
  } else {
    
  }
  _impl_.index_.SetAllocated(index, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.index_.IsDefault()) {
    _impl_.index_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:strategy_trader.OrderInsertReq.index)
}

// .strategy_trader.Order order = 3;
inline bool OrderInsertReq::_internal_has_order() const {
  return this != internal_default_instance() && _impl_.order_ != nullptr;
}
inline bool OrderInsertReq::has_order() const {
  return _internal_has_order();
}
inline void OrderInsertReq::clear_order() {
  if (GetArenaForAllocation() == nullptr && _impl_.order_ != nullptr) {
    delete _impl_.order_;
  }
  _impl_.order_ = nullptr;
}
inline const ::strategy_trader::Order& OrderInsertReq::_internal_order() const {
  const ::strategy_trader::Order* p = _impl_.order_;
  return p != nullptr ? *p : reinterpret_cast<const ::strategy_trader::Order&>(
      ::strategy_trader::_Order_default_instance_);
}
inline const ::strategy_trader::Order& OrderInsertReq::order() const {
  // @@protoc_insertion_point(field_get:strategy_trader.OrderInsertReq.order)
  return _internal_order();
}
inline void OrderInsertReq::unsafe_arena_set_allocated_order(
    ::strategy_trader::Order* order) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.order_);
  }
  _impl_.order_ = order;
  if (order) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:strategy_trader.OrderInsertReq.order)
}
inline ::strategy_trader::Order* OrderInsertReq::release_order() {
  
  ::strategy_trader::Order* temp = _impl_.order_;
  _impl_.order_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::strategy_trader::Order* OrderInsertReq::unsafe_arena_release_order() {
  // @@protoc_insertion_point(field_release:strategy_trader.OrderInsertReq.order)
  
  ::strategy_trader::Order* temp = _impl_.order_;
  _impl_.order_ = nullptr;
  return temp;
}
inline ::strategy_trader::Order* OrderInsertReq::_internal_mutable_order() {
  
  if (_impl_.order_ == nullptr) {
    auto* p = CreateMaybeMessage<::strategy_trader::Order>(GetArenaForAllocation());
    _impl_.order_ = p;
  }
  return _impl_.order_;
}
inline ::strategy_trader::Order* OrderInsertReq::mutable_order() {
  ::strategy_trader::Order* _msg = _internal_mutable_order();
  // @@protoc_insertion_point(field_mutable:strategy_trader.OrderInsertReq.order)
  return _msg;
}
inline void OrderInsertReq::set_allocated_order(::strategy_trader::Order* order) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.order_;
  }
  if (order) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(order);
    if (message_arena != submessage_arena) {
      order = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, order, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.order_ = order;
  // @@protoc_insertion_point(field_set_allocated:strategy_trader.OrderInsertReq.order)
}

// -------------------------------------------------------------------

// RspInfo

// double orderPrice = 1;
inline void RspInfo::clear_orderprice() {
  _impl_.orderprice_ = 0;
}
inline double RspInfo::_internal_orderprice() const {
  return _impl_.orderprice_;
}
inline double RspInfo::orderprice() const {
  // @@protoc_insertion_point(field_get:strategy_trader.RspInfo.orderPrice)
  return _internal_orderprice();
}
inline void RspInfo::_internal_set_orderprice(double value) {
  
  _impl_.orderprice_ = value;
}
inline void RspInfo::set_orderprice(double value) {
  _internal_set_orderprice(value);
  // @@protoc_insertion_point(field_set:strategy_trader.RspInfo.orderPrice)
}

// uint32 orderVolume = 2;
inline void RspInfo::clear_ordervolume() {
  _impl_.ordervolume_ = 0u;
}
inline uint32_t RspInfo::_internal_ordervolume() const {
  return _impl_.ordervolume_;
}
inline uint32_t RspInfo::ordervolume() const {
  // @@protoc_insertion_point(field_get:strategy_trader.RspInfo.orderVolume)
  return _internal_ordervolume();
}
inline void RspInfo::_internal_set_ordervolume(uint32_t value) {
  
  _impl_.ordervolume_ = value;
}
inline void RspInfo::set_ordervolume(uint32_t value) {
  _internal_set_ordervolume(value);
  // @@protoc_insertion_point(field_set:strategy_trader.RspInfo.orderVolume)
}

// -------------------------------------------------------------------

// Order

// string instrument = 1;
inline void Order::clear_instrument() {
  _impl_.instrument_.ClearToEmpty();
}
inline const std::string& Order::instrument() const {
  // @@protoc_insertion_point(field_get:strategy_trader.Order.instrument)
  return _internal_instrument();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Order::set_instrument(ArgT0&& arg0, ArgT... args) {
 
 _impl_.instrument_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:strategy_trader.Order.instrument)
}
inline std::string* Order::mutable_instrument() {
  std::string* _s = _internal_mutable_instrument();
  // @@protoc_insertion_point(field_mutable:strategy_trader.Order.instrument)
  return _s;
}
inline const std::string& Order::_internal_instrument() const {
  return _impl_.instrument_.Get();
}
inline void Order::_internal_set_instrument(const std::string& value) {
  
  _impl_.instrument_.Set(value, GetArenaForAllocation());
}
inline std::string* Order::_internal_mutable_instrument() {
  
  return _impl_.instrument_.Mutable(GetArenaForAllocation());
}
inline std::string* Order::release_instrument() {
  // @@protoc_insertion_point(field_release:strategy_trader.Order.instrument)
  return _impl_.instrument_.Release();
}
inline void Order::set_allocated_instrument(std::string* instrument) {
  if (instrument != nullptr) {
    
  } else {
    
  }
  _impl_.instrument_.SetAllocated(instrument, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.instrument_.IsDefault()) {
    _impl_.instrument_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:strategy_trader.Order.instrument)
}

// string exchangeId = 2;
inline void Order::clear_exchangeid() {
  _impl_.exchangeid_.ClearToEmpty();
}
inline const std::string& Order::exchangeid() const {
  // @@protoc_insertion_point(field_get:strategy_trader.Order.exchangeId)
  return _internal_exchangeid();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Order::set_exchangeid(ArgT0&& arg0, ArgT... args) {
 
 _impl_.exchangeid_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:strategy_trader.Order.exchangeId)
}
inline std::string* Order::mutable_exchangeid() {
  std::string* _s = _internal_mutable_exchangeid();
  // @@protoc_insertion_point(field_mutable:strategy_trader.Order.exchangeId)
  return _s;
}
inline const std::string& Order::_internal_exchangeid() const {
  return _impl_.exchangeid_.Get();
}
inline void Order::_internal_set_exchangeid(const std::string& value) {
  
  _impl_.exchangeid_.Set(value, GetArenaForAllocation());
}
inline std::string* Order::_internal_mutable_exchangeid() {
  
  return _impl_.exchangeid_.Mutable(GetArenaForAllocation());
}
inline std::string* Order::release_exchangeid() {
  // @@protoc_insertion_point(field_release:strategy_trader.Order.exchangeId)
  return _impl_.exchangeid_.Release();
}
inline void Order::set_allocated_exchangeid(std::string* exchangeid) {
  if (exchangeid != nullptr) {
    
  } else {
    
  }
  _impl_.exchangeid_.SetAllocated(exchangeid, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.exchangeid_.IsDefault()) {
    _impl_.exchangeid_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:strategy_trader.Order.exchangeId)
}

// .strategy_trader.Direction direction = 3;
inline void Order::clear_direction() {
  _impl_.direction_ = 0;
}
inline ::strategy_trader::Direction Order::_internal_direction() const {
  return static_cast< ::strategy_trader::Direction >(_impl_.direction_);
}
inline ::strategy_trader::Direction Order::direction() const {
  // @@protoc_insertion_point(field_get:strategy_trader.Order.direction)
  return _internal_direction();
}
inline void Order::_internal_set_direction(::strategy_trader::Direction value) {
  
  _impl_.direction_ = value;
}
inline void Order::set_direction(::strategy_trader::Direction value) {
  _internal_set_direction(value);
  // @@protoc_insertion_point(field_set:strategy_trader.Order.direction)
}

// double limit_price = 4;
inline void Order::clear_limit_price() {
  _impl_.limit_price_ = 0;
}
inline double Order::_internal_limit_price() const {
  return _impl_.limit_price_;
}
inline double Order::limit_price() const {
  // @@protoc_insertion_point(field_get:strategy_trader.Order.limit_price)
  return _internal_limit_price();
}
inline void Order::_internal_set_limit_price(double value) {
  
  _impl_.limit_price_ = value;
}
inline void Order::set_limit_price(double value) {
  _internal_set_limit_price(value);
  // @@protoc_insertion_point(field_set:strategy_trader.Order.limit_price)
}

// uint32 once_volume = 5;
inline void Order::clear_once_volume() {
  _impl_.once_volume_ = 0u;
}
inline uint32_t Order::_internal_once_volume() const {
  return _impl_.once_volume_;
}
inline uint32_t Order::once_volume() const {
  // @@protoc_insertion_point(field_get:strategy_trader.Order.once_volume)
  return _internal_once_volume();
}
inline void Order::_internal_set_once_volume(uint32_t value) {
  
  _impl_.once_volume_ = value;
}
inline void Order::set_once_volume(uint32_t value) {
  _internal_set_once_volume(value);
  // @@protoc_insertion_point(field_set:strategy_trader.Order.once_volume)
}

// .strategy_trader.CombOffsetType comb_offset_flag = 6;
inline void Order::clear_comb_offset_flag() {
  _impl_.comb_offset_flag_ = 0;
}
inline ::strategy_trader::CombOffsetType Order::_internal_comb_offset_flag() const {
  return static_cast< ::strategy_trader::CombOffsetType >(_impl_.comb_offset_flag_);
}
inline ::strategy_trader::CombOffsetType Order::comb_offset_flag() const {
  // @@protoc_insertion_point(field_get:strategy_trader.Order.comb_offset_flag)
  return _internal_comb_offset_flag();
}
inline void Order::_internal_set_comb_offset_flag(::strategy_trader::CombOffsetType value) {
  
  _impl_.comb_offset_flag_ = value;
}
inline void Order::set_comb_offset_flag(::strategy_trader::CombOffsetType value) {
  _internal_set_comb_offset_flag(value);
  // @@protoc_insertion_point(field_set:strategy_trader.Order.comb_offset_flag)
}

// uint32 hold_volume = 7;
inline void Order::clear_hold_volume() {
  _impl_.hold_volume_ = 0u;
}
inline uint32_t Order::_internal_hold_volume() const {
  return _impl_.hold_volume_;
}
inline uint32_t Order::hold_volume() const {
  // @@protoc_insertion_point(field_get:strategy_trader.Order.hold_volume)
  return _internal_hold_volume();
}
inline void Order::_internal_set_hold_volume(uint32_t value) {
  
  _impl_.hold_volume_ = value;
}
inline void Order::set_hold_volume(uint32_t value) {
  _internal_set_hold_volume(value);
  // @@protoc_insertion_point(field_set:strategy_trader.Order.hold_volume)
}

// .strategy_trader.OrderType order_type = 8;
inline void Order::clear_order_type() {
  _impl_.order_type_ = 0;
}
inline ::strategy_trader::OrderType Order::_internal_order_type() const {
  return static_cast< ::strategy_trader::OrderType >(_impl_.order_type_);
}
inline ::strategy_trader::OrderType Order::order_type() const {
  // @@protoc_insertion_point(field_get:strategy_trader.Order.order_type)
  return _internal_order_type();
}
inline void Order::_internal_set_order_type(::strategy_trader::OrderType value) {
  
  _impl_.order_type_ = value;
}
inline void Order::set_order_type(::strategy_trader::OrderType value) {
  _internal_set_order_type(value);
  // @@protoc_insertion_point(field_set:strategy_trader.Order.order_type)
}

// -------------------------------------------------------------------

// TransactionCostReq

// .strategy_trader.InstrumentInfo instrument_info = 1;
inline bool TransactionCostReq::_internal_has_instrument_info() const {
  return this != internal_default_instance() && _impl_.instrument_info_ != nullptr;
}
inline bool TransactionCostReq::has_instrument_info() const {
  return _internal_has_instrument_info();
}
inline void TransactionCostReq::clear_instrument_info() {
  if (GetArenaForAllocation() == nullptr && _impl_.instrument_info_ != nullptr) {
    delete _impl_.instrument_info_;
  }
  _impl_.instrument_info_ = nullptr;
}
inline const ::strategy_trader::InstrumentInfo& TransactionCostReq::_internal_instrument_info() const {
  const ::strategy_trader::InstrumentInfo* p = _impl_.instrument_info_;
  return p != nullptr ? *p : reinterpret_cast<const ::strategy_trader::InstrumentInfo&>(
      ::strategy_trader::_InstrumentInfo_default_instance_);
}
inline const ::strategy_trader::InstrumentInfo& TransactionCostReq::instrument_info() const {
  // @@protoc_insertion_point(field_get:strategy_trader.TransactionCostReq.instrument_info)
  return _internal_instrument_info();
}
inline void TransactionCostReq::unsafe_arena_set_allocated_instrument_info(
    ::strategy_trader::InstrumentInfo* instrument_info) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.instrument_info_);
  }
  _impl_.instrument_info_ = instrument_info;
  if (instrument_info) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:strategy_trader.TransactionCostReq.instrument_info)
}
inline ::strategy_trader::InstrumentInfo* TransactionCostReq::release_instrument_info() {
  
  ::strategy_trader::InstrumentInfo* temp = _impl_.instrument_info_;
  _impl_.instrument_info_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::strategy_trader::InstrumentInfo* TransactionCostReq::unsafe_arena_release_instrument_info() {
  // @@protoc_insertion_point(field_release:strategy_trader.TransactionCostReq.instrument_info)
  
  ::strategy_trader::InstrumentInfo* temp = _impl_.instrument_info_;
  _impl_.instrument_info_ = nullptr;
  return temp;
}
inline ::strategy_trader::InstrumentInfo* TransactionCostReq::_internal_mutable_instrument_info() {
  
  if (_impl_.instrument_info_ == nullptr) {
    auto* p = CreateMaybeMessage<::strategy_trader::InstrumentInfo>(GetArenaForAllocation());
    _impl_.instrument_info_ = p;
  }
  return _impl_.instrument_info_;
}
inline ::strategy_trader::InstrumentInfo* TransactionCostReq::mutable_instrument_info() {
  ::strategy_trader::InstrumentInfo* _msg = _internal_mutable_instrument_info();
  // @@protoc_insertion_point(field_mutable:strategy_trader.TransactionCostReq.instrument_info)
  return _msg;
}
inline void TransactionCostReq::set_allocated_instrument_info(::strategy_trader::InstrumentInfo* instrument_info) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.instrument_info_;
  }
  if (instrument_info) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(instrument_info);
    if (message_arena != submessage_arena) {
      instrument_info = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, instrument_info, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.instrument_info_ = instrument_info;
  // @@protoc_insertion_point(field_set_allocated:strategy_trader.TransactionCostReq.instrument_info)
}

// -------------------------------------------------------------------

// MarginRateRsp

// string user_id = 1;
inline void MarginRateRsp::clear_user_id() {
  _impl_.user_id_.ClearToEmpty();
}
inline const std::string& MarginRateRsp::user_id() const {
  // @@protoc_insertion_point(field_get:strategy_trader.MarginRateRsp.user_id)
  return _internal_user_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void MarginRateRsp::set_user_id(ArgT0&& arg0, ArgT... args) {
 
 _impl_.user_id_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:strategy_trader.MarginRateRsp.user_id)
}
inline std::string* MarginRateRsp::mutable_user_id() {
  std::string* _s = _internal_mutable_user_id();
  // @@protoc_insertion_point(field_mutable:strategy_trader.MarginRateRsp.user_id)
  return _s;
}
inline const std::string& MarginRateRsp::_internal_user_id() const {
  return _impl_.user_id_.Get();
}
inline void MarginRateRsp::_internal_set_user_id(const std::string& value) {
  
  _impl_.user_id_.Set(value, GetArenaForAllocation());
}
inline std::string* MarginRateRsp::_internal_mutable_user_id() {
  
  return _impl_.user_id_.Mutable(GetArenaForAllocation());
}
inline std::string* MarginRateRsp::release_user_id() {
  // @@protoc_insertion_point(field_release:strategy_trader.MarginRateRsp.user_id)
  return _impl_.user_id_.Release();
}
inline void MarginRateRsp::set_allocated_user_id(std::string* user_id) {
  if (user_id != nullptr) {
    
  } else {
    
  }
  _impl_.user_id_.SetAllocated(user_id, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.user_id_.IsDefault()) {
    _impl_.user_id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:strategy_trader.MarginRateRsp.user_id)
}

// string instrument_id = 2;
inline void MarginRateRsp::clear_instrument_id() {
  _impl_.instrument_id_.ClearToEmpty();
}
inline const std::string& MarginRateRsp::instrument_id() const {
  // @@protoc_insertion_point(field_get:strategy_trader.MarginRateRsp.instrument_id)
  return _internal_instrument_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void MarginRateRsp::set_instrument_id(ArgT0&& arg0, ArgT... args) {
 
 _impl_.instrument_id_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:strategy_trader.MarginRateRsp.instrument_id)
}
inline std::string* MarginRateRsp::mutable_instrument_id() {
  std::string* _s = _internal_mutable_instrument_id();
  // @@protoc_insertion_point(field_mutable:strategy_trader.MarginRateRsp.instrument_id)
  return _s;
}
inline const std::string& MarginRateRsp::_internal_instrument_id() const {
  return _impl_.instrument_id_.Get();
}
inline void MarginRateRsp::_internal_set_instrument_id(const std::string& value) {
  
  _impl_.instrument_id_.Set(value, GetArenaForAllocation());
}
inline std::string* MarginRateRsp::_internal_mutable_instrument_id() {
  
  return _impl_.instrument_id_.Mutable(GetArenaForAllocation());
}
inline std::string* MarginRateRsp::release_instrument_id() {
  // @@protoc_insertion_point(field_release:strategy_trader.MarginRateRsp.instrument_id)
  return _impl_.instrument_id_.Release();
}
inline void MarginRateRsp::set_allocated_instrument_id(std::string* instrument_id) {
  if (instrument_id != nullptr) {
    
  } else {
    
  }
  _impl_.instrument_id_.SetAllocated(instrument_id, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.instrument_id_.IsDefault()) {
    _impl_.instrument_id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:strategy_trader.MarginRateRsp.instrument_id)
}

// string exchange_id = 3;
inline void MarginRateRsp::clear_exchange_id() {
  _impl_.exchange_id_.ClearToEmpty();
}
inline const std::string& MarginRateRsp::exchange_id() const {
  // @@protoc_insertion_point(field_get:strategy_trader.MarginRateRsp.exchange_id)
  return _internal_exchange_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void MarginRateRsp::set_exchange_id(ArgT0&& arg0, ArgT... args) {
 
 _impl_.exchange_id_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:strategy_trader.MarginRateRsp.exchange_id)
}
inline std::string* MarginRateRsp::mutable_exchange_id() {
  std::string* _s = _internal_mutable_exchange_id();
  // @@protoc_insertion_point(field_mutable:strategy_trader.MarginRateRsp.exchange_id)
  return _s;
}
inline const std::string& MarginRateRsp::_internal_exchange_id() const {
  return _impl_.exchange_id_.Get();
}
inline void MarginRateRsp::_internal_set_exchange_id(const std::string& value) {
  
  _impl_.exchange_id_.Set(value, GetArenaForAllocation());
}
inline std::string* MarginRateRsp::_internal_mutable_exchange_id() {
  
  return _impl_.exchange_id_.Mutable(GetArenaForAllocation());
}
inline std::string* MarginRateRsp::release_exchange_id() {
  // @@protoc_insertion_point(field_release:strategy_trader.MarginRateRsp.exchange_id)
  return _impl_.exchange_id_.Release();
}
inline void MarginRateRsp::set_allocated_exchange_id(std::string* exchange_id) {
  if (exchange_id != nullptr) {
    
  } else {
    
  }
  _impl_.exchange_id_.SetAllocated(exchange_id, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.exchange_id_.IsDefault()) {
    _impl_.exchange_id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:strategy_trader.MarginRateRsp.exchange_id)
}

// double LongMarginRatioByMoney = 4;
inline void MarginRateRsp::clear_longmarginratiobymoney() {
  _impl_.longmarginratiobymoney_ = 0;
}
inline double MarginRateRsp::_internal_longmarginratiobymoney() const {
  return _impl_.longmarginratiobymoney_;
}
inline double MarginRateRsp::longmarginratiobymoney() const {
  // @@protoc_insertion_point(field_get:strategy_trader.MarginRateRsp.LongMarginRatioByMoney)
  return _internal_longmarginratiobymoney();
}
inline void MarginRateRsp::_internal_set_longmarginratiobymoney(double value) {
  
  _impl_.longmarginratiobymoney_ = value;
}
inline void MarginRateRsp::set_longmarginratiobymoney(double value) {
  _internal_set_longmarginratiobymoney(value);
  // @@protoc_insertion_point(field_set:strategy_trader.MarginRateRsp.LongMarginRatioByMoney)
}

// double LongMarginRatioByVolume = 5;
inline void MarginRateRsp::clear_longmarginratiobyvolume() {
  _impl_.longmarginratiobyvolume_ = 0;
}
inline double MarginRateRsp::_internal_longmarginratiobyvolume() const {
  return _impl_.longmarginratiobyvolume_;
}
inline double MarginRateRsp::longmarginratiobyvolume() const {
  // @@protoc_insertion_point(field_get:strategy_trader.MarginRateRsp.LongMarginRatioByVolume)
  return _internal_longmarginratiobyvolume();
}
inline void MarginRateRsp::_internal_set_longmarginratiobyvolume(double value) {
  
  _impl_.longmarginratiobyvolume_ = value;
}
inline void MarginRateRsp::set_longmarginratiobyvolume(double value) {
  _internal_set_longmarginratiobyvolume(value);
  // @@protoc_insertion_point(field_set:strategy_trader.MarginRateRsp.LongMarginRatioByVolume)
}

// double ShortMarginRatioByMoney = 6;
inline void MarginRateRsp::clear_shortmarginratiobymoney() {
  _impl_.shortmarginratiobymoney_ = 0;
}
inline double MarginRateRsp::_internal_shortmarginratiobymoney() const {
  return _impl_.shortmarginratiobymoney_;
}
inline double MarginRateRsp::shortmarginratiobymoney() const {
  // @@protoc_insertion_point(field_get:strategy_trader.MarginRateRsp.ShortMarginRatioByMoney)
  return _internal_shortmarginratiobymoney();
}
inline void MarginRateRsp::_internal_set_shortmarginratiobymoney(double value) {
  
  _impl_.shortmarginratiobymoney_ = value;
}
inline void MarginRateRsp::set_shortmarginratiobymoney(double value) {
  _internal_set_shortmarginratiobymoney(value);
  // @@protoc_insertion_point(field_set:strategy_trader.MarginRateRsp.ShortMarginRatioByMoney)
}

// double ShortMarginRatioByVolume = 7;
inline void MarginRateRsp::clear_shortmarginratiobyvolume() {
  _impl_.shortmarginratiobyvolume_ = 0;
}
inline double MarginRateRsp::_internal_shortmarginratiobyvolume() const {
  return _impl_.shortmarginratiobyvolume_;
}
inline double MarginRateRsp::shortmarginratiobyvolume() const {
  // @@protoc_insertion_point(field_get:strategy_trader.MarginRateRsp.ShortMarginRatioByVolume)
  return _internal_shortmarginratiobyvolume();
}
inline void MarginRateRsp::_internal_set_shortmarginratiobyvolume(double value) {
  
  _impl_.shortmarginratiobyvolume_ = value;
}
inline void MarginRateRsp::set_shortmarginratiobyvolume(double value) {
  _internal_set_shortmarginratiobyvolume(value);
  // @@protoc_insertion_point(field_set:strategy_trader.MarginRateRsp.ShortMarginRatioByVolume)
}

// .strategy_trader.Result result = 8;
inline void MarginRateRsp::clear_result() {
  _impl_.result_ = 0;
}
inline ::strategy_trader::Result MarginRateRsp::_internal_result() const {
  return static_cast< ::strategy_trader::Result >(_impl_.result_);
}
inline ::strategy_trader::Result MarginRateRsp::result() const {
  // @@protoc_insertion_point(field_get:strategy_trader.MarginRateRsp.result)
  return _internal_result();
}
inline void MarginRateRsp::_internal_set_result(::strategy_trader::Result value) {
  
  _impl_.result_ = value;
}
inline void MarginRateRsp::set_result(::strategy_trader::Result value) {
  _internal_set_result(value);
  // @@protoc_insertion_point(field_set:strategy_trader.MarginRateRsp.result)
}

// string failedReason = 9;
inline void MarginRateRsp::clear_failedreason() {
  _impl_.failedreason_.ClearToEmpty();
}
inline const std::string& MarginRateRsp::failedreason() const {
  // @@protoc_insertion_point(field_get:strategy_trader.MarginRateRsp.failedReason)
  return _internal_failedreason();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void MarginRateRsp::set_failedreason(ArgT0&& arg0, ArgT... args) {
 
 _impl_.failedreason_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:strategy_trader.MarginRateRsp.failedReason)
}
inline std::string* MarginRateRsp::mutable_failedreason() {
  std::string* _s = _internal_mutable_failedreason();
  // @@protoc_insertion_point(field_mutable:strategy_trader.MarginRateRsp.failedReason)
  return _s;
}
inline const std::string& MarginRateRsp::_internal_failedreason() const {
  return _impl_.failedreason_.Get();
}
inline void MarginRateRsp::_internal_set_failedreason(const std::string& value) {
  
  _impl_.failedreason_.Set(value, GetArenaForAllocation());
}
inline std::string* MarginRateRsp::_internal_mutable_failedreason() {
  
  return _impl_.failedreason_.Mutable(GetArenaForAllocation());
}
inline std::string* MarginRateRsp::release_failedreason() {
  // @@protoc_insertion_point(field_release:strategy_trader.MarginRateRsp.failedReason)
  return _impl_.failedreason_.Release();
}
inline void MarginRateRsp::set_allocated_failedreason(std::string* failedreason) {
  if (failedreason != nullptr) {
    
  } else {
    
  }
  _impl_.failedreason_.SetAllocated(failedreason, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.failedreason_.IsDefault()) {
    _impl_.failedreason_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:strategy_trader.MarginRateRsp.failedReason)
}

// -------------------------------------------------------------------

// CommissionRateRsp

// string user_id = 1;
inline void CommissionRateRsp::clear_user_id() {
  _impl_.user_id_.ClearToEmpty();
}
inline const std::string& CommissionRateRsp::user_id() const {
  // @@protoc_insertion_point(field_get:strategy_trader.CommissionRateRsp.user_id)
  return _internal_user_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void CommissionRateRsp::set_user_id(ArgT0&& arg0, ArgT... args) {
 
 _impl_.user_id_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:strategy_trader.CommissionRateRsp.user_id)
}
inline std::string* CommissionRateRsp::mutable_user_id() {
  std::string* _s = _internal_mutable_user_id();
  // @@protoc_insertion_point(field_mutable:strategy_trader.CommissionRateRsp.user_id)
  return _s;
}
inline const std::string& CommissionRateRsp::_internal_user_id() const {
  return _impl_.user_id_.Get();
}
inline void CommissionRateRsp::_internal_set_user_id(const std::string& value) {
  
  _impl_.user_id_.Set(value, GetArenaForAllocation());
}
inline std::string* CommissionRateRsp::_internal_mutable_user_id() {
  
  return _impl_.user_id_.Mutable(GetArenaForAllocation());
}
inline std::string* CommissionRateRsp::release_user_id() {
  // @@protoc_insertion_point(field_release:strategy_trader.CommissionRateRsp.user_id)
  return _impl_.user_id_.Release();
}
inline void CommissionRateRsp::set_allocated_user_id(std::string* user_id) {
  if (user_id != nullptr) {
    
  } else {
    
  }
  _impl_.user_id_.SetAllocated(user_id, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.user_id_.IsDefault()) {
    _impl_.user_id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:strategy_trader.CommissionRateRsp.user_id)
}

// string instrument_id = 2;
inline void CommissionRateRsp::clear_instrument_id() {
  _impl_.instrument_id_.ClearToEmpty();
}
inline const std::string& CommissionRateRsp::instrument_id() const {
  // @@protoc_insertion_point(field_get:strategy_trader.CommissionRateRsp.instrument_id)
  return _internal_instrument_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void CommissionRateRsp::set_instrument_id(ArgT0&& arg0, ArgT... args) {
 
 _impl_.instrument_id_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:strategy_trader.CommissionRateRsp.instrument_id)
}
inline std::string* CommissionRateRsp::mutable_instrument_id() {
  std::string* _s = _internal_mutable_instrument_id();
  // @@protoc_insertion_point(field_mutable:strategy_trader.CommissionRateRsp.instrument_id)
  return _s;
}
inline const std::string& CommissionRateRsp::_internal_instrument_id() const {
  return _impl_.instrument_id_.Get();
}
inline void CommissionRateRsp::_internal_set_instrument_id(const std::string& value) {
  
  _impl_.instrument_id_.Set(value, GetArenaForAllocation());
}
inline std::string* CommissionRateRsp::_internal_mutable_instrument_id() {
  
  return _impl_.instrument_id_.Mutable(GetArenaForAllocation());
}
inline std::string* CommissionRateRsp::release_instrument_id() {
  // @@protoc_insertion_point(field_release:strategy_trader.CommissionRateRsp.instrument_id)
  return _impl_.instrument_id_.Release();
}
inline void CommissionRateRsp::set_allocated_instrument_id(std::string* instrument_id) {
  if (instrument_id != nullptr) {
    
  } else {
    
  }
  _impl_.instrument_id_.SetAllocated(instrument_id, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.instrument_id_.IsDefault()) {
    _impl_.instrument_id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:strategy_trader.CommissionRateRsp.instrument_id)
}

// string exchange_id = 3;
inline void CommissionRateRsp::clear_exchange_id() {
  _impl_.exchange_id_.ClearToEmpty();
}
inline const std::string& CommissionRateRsp::exchange_id() const {
  // @@protoc_insertion_point(field_get:strategy_trader.CommissionRateRsp.exchange_id)
  return _internal_exchange_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void CommissionRateRsp::set_exchange_id(ArgT0&& arg0, ArgT... args) {
 
 _impl_.exchange_id_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:strategy_trader.CommissionRateRsp.exchange_id)
}
inline std::string* CommissionRateRsp::mutable_exchange_id() {
  std::string* _s = _internal_mutable_exchange_id();
  // @@protoc_insertion_point(field_mutable:strategy_trader.CommissionRateRsp.exchange_id)
  return _s;
}
inline const std::string& CommissionRateRsp::_internal_exchange_id() const {
  return _impl_.exchange_id_.Get();
}
inline void CommissionRateRsp::_internal_set_exchange_id(const std::string& value) {
  
  _impl_.exchange_id_.Set(value, GetArenaForAllocation());
}
inline std::string* CommissionRateRsp::_internal_mutable_exchange_id() {
  
  return _impl_.exchange_id_.Mutable(GetArenaForAllocation());
}
inline std::string* CommissionRateRsp::release_exchange_id() {
  // @@protoc_insertion_point(field_release:strategy_trader.CommissionRateRsp.exchange_id)
  return _impl_.exchange_id_.Release();
}
inline void CommissionRateRsp::set_allocated_exchange_id(std::string* exchange_id) {
  if (exchange_id != nullptr) {
    
  } else {
    
  }
  _impl_.exchange_id_.SetAllocated(exchange_id, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.exchange_id_.IsDefault()) {
    _impl_.exchange_id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:strategy_trader.CommissionRateRsp.exchange_id)
}

// double OpenRatioByMoney = 4;
inline void CommissionRateRsp::clear_openratiobymoney() {
  _impl_.openratiobymoney_ = 0;
}
inline double CommissionRateRsp::_internal_openratiobymoney() const {
  return _impl_.openratiobymoney_;
}
inline double CommissionRateRsp::openratiobymoney() const {
  // @@protoc_insertion_point(field_get:strategy_trader.CommissionRateRsp.OpenRatioByMoney)
  return _internal_openratiobymoney();
}
inline void CommissionRateRsp::_internal_set_openratiobymoney(double value) {
  
  _impl_.openratiobymoney_ = value;
}
inline void CommissionRateRsp::set_openratiobymoney(double value) {
  _internal_set_openratiobymoney(value);
  // @@protoc_insertion_point(field_set:strategy_trader.CommissionRateRsp.OpenRatioByMoney)
}

// double OpenRatioByVolume = 5;
inline void CommissionRateRsp::clear_openratiobyvolume() {
  _impl_.openratiobyvolume_ = 0;
}
inline double CommissionRateRsp::_internal_openratiobyvolume() const {
  return _impl_.openratiobyvolume_;
}
inline double CommissionRateRsp::openratiobyvolume() const {
  // @@protoc_insertion_point(field_get:strategy_trader.CommissionRateRsp.OpenRatioByVolume)
  return _internal_openratiobyvolume();
}
inline void CommissionRateRsp::_internal_set_openratiobyvolume(double value) {
  
  _impl_.openratiobyvolume_ = value;
}
inline void CommissionRateRsp::set_openratiobyvolume(double value) {
  _internal_set_openratiobyvolume(value);
  // @@protoc_insertion_point(field_set:strategy_trader.CommissionRateRsp.OpenRatioByVolume)
}

// double CloseRatioByMoney = 6;
inline void CommissionRateRsp::clear_closeratiobymoney() {
  _impl_.closeratiobymoney_ = 0;
}
inline double CommissionRateRsp::_internal_closeratiobymoney() const {
  return _impl_.closeratiobymoney_;
}
inline double CommissionRateRsp::closeratiobymoney() const {
  // @@protoc_insertion_point(field_get:strategy_trader.CommissionRateRsp.CloseRatioByMoney)
  return _internal_closeratiobymoney();
}
inline void CommissionRateRsp::_internal_set_closeratiobymoney(double value) {
  
  _impl_.closeratiobymoney_ = value;
}
inline void CommissionRateRsp::set_closeratiobymoney(double value) {
  _internal_set_closeratiobymoney(value);
  // @@protoc_insertion_point(field_set:strategy_trader.CommissionRateRsp.CloseRatioByMoney)
}

// double CloseRatioByVolume = 7;
inline void CommissionRateRsp::clear_closeratiobyvolume() {
  _impl_.closeratiobyvolume_ = 0;
}
inline double CommissionRateRsp::_internal_closeratiobyvolume() const {
  return _impl_.closeratiobyvolume_;
}
inline double CommissionRateRsp::closeratiobyvolume() const {
  // @@protoc_insertion_point(field_get:strategy_trader.CommissionRateRsp.CloseRatioByVolume)
  return _internal_closeratiobyvolume();
}
inline void CommissionRateRsp::_internal_set_closeratiobyvolume(double value) {
  
  _impl_.closeratiobyvolume_ = value;
}
inline void CommissionRateRsp::set_closeratiobyvolume(double value) {
  _internal_set_closeratiobyvolume(value);
  // @@protoc_insertion_point(field_set:strategy_trader.CommissionRateRsp.CloseRatioByVolume)
}

// double CloseTodayRatioByMoney = 8;
inline void CommissionRateRsp::clear_closetodayratiobymoney() {
  _impl_.closetodayratiobymoney_ = 0;
}
inline double CommissionRateRsp::_internal_closetodayratiobymoney() const {
  return _impl_.closetodayratiobymoney_;
}
inline double CommissionRateRsp::closetodayratiobymoney() const {
  // @@protoc_insertion_point(field_get:strategy_trader.CommissionRateRsp.CloseTodayRatioByMoney)
  return _internal_closetodayratiobymoney();
}
inline void CommissionRateRsp::_internal_set_closetodayratiobymoney(double value) {
  
  _impl_.closetodayratiobymoney_ = value;
}
inline void CommissionRateRsp::set_closetodayratiobymoney(double value) {
  _internal_set_closetodayratiobymoney(value);
  // @@protoc_insertion_point(field_set:strategy_trader.CommissionRateRsp.CloseTodayRatioByMoney)
}

// double CloseTodayRatioByVolume = 9;
inline void CommissionRateRsp::clear_closetodayratiobyvolume() {
  _impl_.closetodayratiobyvolume_ = 0;
}
inline double CommissionRateRsp::_internal_closetodayratiobyvolume() const {
  return _impl_.closetodayratiobyvolume_;
}
inline double CommissionRateRsp::closetodayratiobyvolume() const {
  // @@protoc_insertion_point(field_get:strategy_trader.CommissionRateRsp.CloseTodayRatioByVolume)
  return _internal_closetodayratiobyvolume();
}
inline void CommissionRateRsp::_internal_set_closetodayratiobyvolume(double value) {
  
  _impl_.closetodayratiobyvolume_ = value;
}
inline void CommissionRateRsp::set_closetodayratiobyvolume(double value) {
  _internal_set_closetodayratiobyvolume(value);
  // @@protoc_insertion_point(field_set:strategy_trader.CommissionRateRsp.CloseTodayRatioByVolume)
}

// .strategy_trader.Result result = 10;
inline void CommissionRateRsp::clear_result() {
  _impl_.result_ = 0;
}
inline ::strategy_trader::Result CommissionRateRsp::_internal_result() const {
  return static_cast< ::strategy_trader::Result >(_impl_.result_);
}
inline ::strategy_trader::Result CommissionRateRsp::result() const {
  // @@protoc_insertion_point(field_get:strategy_trader.CommissionRateRsp.result)
  return _internal_result();
}
inline void CommissionRateRsp::_internal_set_result(::strategy_trader::Result value) {
  
  _impl_.result_ = value;
}
inline void CommissionRateRsp::set_result(::strategy_trader::Result value) {
  _internal_set_result(value);
  // @@protoc_insertion_point(field_set:strategy_trader.CommissionRateRsp.result)
}

// string failedReason = 11;
inline void CommissionRateRsp::clear_failedreason() {
  _impl_.failedreason_.ClearToEmpty();
}
inline const std::string& CommissionRateRsp::failedreason() const {
  // @@protoc_insertion_point(field_get:strategy_trader.CommissionRateRsp.failedReason)
  return _internal_failedreason();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void CommissionRateRsp::set_failedreason(ArgT0&& arg0, ArgT... args) {
 
 _impl_.failedreason_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:strategy_trader.CommissionRateRsp.failedReason)
}
inline std::string* CommissionRateRsp::mutable_failedreason() {
  std::string* _s = _internal_mutable_failedreason();
  // @@protoc_insertion_point(field_mutable:strategy_trader.CommissionRateRsp.failedReason)
  return _s;
}
inline const std::string& CommissionRateRsp::_internal_failedreason() const {
  return _impl_.failedreason_.Get();
}
inline void CommissionRateRsp::_internal_set_failedreason(const std::string& value) {
  
  _impl_.failedreason_.Set(value, GetArenaForAllocation());
}
inline std::string* CommissionRateRsp::_internal_mutable_failedreason() {
  
  return _impl_.failedreason_.Mutable(GetArenaForAllocation());
}
inline std::string* CommissionRateRsp::release_failedreason() {
  // @@protoc_insertion_point(field_release:strategy_trader.CommissionRateRsp.failedReason)
  return _impl_.failedreason_.Release();
}
inline void CommissionRateRsp::set_allocated_failedreason(std::string* failedreason) {
  if (failedreason != nullptr) {
    
  } else {
    
  }
  _impl_.failedreason_.SetAllocated(failedreason, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.failedreason_.IsDefault()) {
    _impl_.failedreason_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:strategy_trader.CommissionRateRsp.failedReason)
}

// -------------------------------------------------------------------

// InstrumentInfo

// string instrument_id = 1;
inline void InstrumentInfo::clear_instrument_id() {
  _impl_.instrument_id_.ClearToEmpty();
}
inline const std::string& InstrumentInfo::instrument_id() const {
  // @@protoc_insertion_point(field_get:strategy_trader.InstrumentInfo.instrument_id)
  return _internal_instrument_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void InstrumentInfo::set_instrument_id(ArgT0&& arg0, ArgT... args) {
 
 _impl_.instrument_id_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:strategy_trader.InstrumentInfo.instrument_id)
}
inline std::string* InstrumentInfo::mutable_instrument_id() {
  std::string* _s = _internal_mutable_instrument_id();
  // @@protoc_insertion_point(field_mutable:strategy_trader.InstrumentInfo.instrument_id)
  return _s;
}
inline const std::string& InstrumentInfo::_internal_instrument_id() const {
  return _impl_.instrument_id_.Get();
}
inline void InstrumentInfo::_internal_set_instrument_id(const std::string& value) {
  
  _impl_.instrument_id_.Set(value, GetArenaForAllocation());
}
inline std::string* InstrumentInfo::_internal_mutable_instrument_id() {
  
  return _impl_.instrument_id_.Mutable(GetArenaForAllocation());
}
inline std::string* InstrumentInfo::release_instrument_id() {
  // @@protoc_insertion_point(field_release:strategy_trader.InstrumentInfo.instrument_id)
  return _impl_.instrument_id_.Release();
}
inline void InstrumentInfo::set_allocated_instrument_id(std::string* instrument_id) {
  if (instrument_id != nullptr) {
    
  } else {
    
  }
  _impl_.instrument_id_.SetAllocated(instrument_id, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.instrument_id_.IsDefault()) {
    _impl_.instrument_id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:strategy_trader.InstrumentInfo.instrument_id)
}

// string exchange_id = 2;
inline void InstrumentInfo::clear_exchange_id() {
  _impl_.exchange_id_.ClearToEmpty();
}
inline const std::string& InstrumentInfo::exchange_id() const {
  // @@protoc_insertion_point(field_get:strategy_trader.InstrumentInfo.exchange_id)
  return _internal_exchange_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void InstrumentInfo::set_exchange_id(ArgT0&& arg0, ArgT... args) {
 
 _impl_.exchange_id_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:strategy_trader.InstrumentInfo.exchange_id)
}
inline std::string* InstrumentInfo::mutable_exchange_id() {
  std::string* _s = _internal_mutable_exchange_id();
  // @@protoc_insertion_point(field_mutable:strategy_trader.InstrumentInfo.exchange_id)
  return _s;
}
inline const std::string& InstrumentInfo::_internal_exchange_id() const {
  return _impl_.exchange_id_.Get();
}
inline void InstrumentInfo::_internal_set_exchange_id(const std::string& value) {
  
  _impl_.exchange_id_.Set(value, GetArenaForAllocation());
}
inline std::string* InstrumentInfo::_internal_mutable_exchange_id() {
  
  return _impl_.exchange_id_.Mutable(GetArenaForAllocation());
}
inline std::string* InstrumentInfo::release_exchange_id() {
  // @@protoc_insertion_point(field_release:strategy_trader.InstrumentInfo.exchange_id)
  return _impl_.exchange_id_.Release();
}
inline void InstrumentInfo::set_allocated_exchange_id(std::string* exchange_id) {
  if (exchange_id != nullptr) {
    
  } else {
    
  }
  _impl_.exchange_id_.SetAllocated(exchange_id, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.exchange_id_.IsDefault()) {
    _impl_.exchange_id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:strategy_trader.InstrumentInfo.exchange_id)
}

// -------------------------------------------------------------------

// AccountSetRsp

// repeated string account = 1;
inline int AccountSetRsp::_internal_account_size() const {
  return _impl_.account_.size();
}
inline int AccountSetRsp::account_size() const {
  return _internal_account_size();
}
inline void AccountSetRsp::clear_account() {
  _impl_.account_.Clear();
}
inline std::string* AccountSetRsp::add_account() {
  std::string* _s = _internal_add_account();
  // @@protoc_insertion_point(field_add_mutable:strategy_trader.AccountSetRsp.account)
  return _s;
}
inline const std::string& AccountSetRsp::_internal_account(int index) const {
  return _impl_.account_.Get(index);
}
inline const std::string& AccountSetRsp::account(int index) const {
  // @@protoc_insertion_point(field_get:strategy_trader.AccountSetRsp.account)
  return _internal_account(index);
}
inline std::string* AccountSetRsp::mutable_account(int index) {
  // @@protoc_insertion_point(field_mutable:strategy_trader.AccountSetRsp.account)
  return _impl_.account_.Mutable(index);
}
inline void AccountSetRsp::set_account(int index, const std::string& value) {
  _impl_.account_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set:strategy_trader.AccountSetRsp.account)
}
inline void AccountSetRsp::set_account(int index, std::string&& value) {
  _impl_.account_.Mutable(index)->assign(std::move(value));
  // @@protoc_insertion_point(field_set:strategy_trader.AccountSetRsp.account)
}
inline void AccountSetRsp::set_account(int index, const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _impl_.account_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:strategy_trader.AccountSetRsp.account)
}
inline void AccountSetRsp::set_account(int index, const char* value, size_t size) {
  _impl_.account_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:strategy_trader.AccountSetRsp.account)
}
inline std::string* AccountSetRsp::_internal_add_account() {
  return _impl_.account_.Add();
}
inline void AccountSetRsp::add_account(const std::string& value) {
  _impl_.account_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:strategy_trader.AccountSetRsp.account)
}
inline void AccountSetRsp::add_account(std::string&& value) {
  _impl_.account_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:strategy_trader.AccountSetRsp.account)
}
inline void AccountSetRsp::add_account(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _impl_.account_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:strategy_trader.AccountSetRsp.account)
}
inline void AccountSetRsp::add_account(const char* value, size_t size) {
  _impl_.account_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:strategy_trader.AccountSetRsp.account)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
AccountSetRsp::account() const {
  // @@protoc_insertion_point(field_list:strategy_trader.AccountSetRsp.account)
  return _impl_.account_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>*
AccountSetRsp::mutable_account() {
  // @@protoc_insertion_point(field_mutable_list:strategy_trader.AccountSetRsp.account)
  return &_impl_.account_;
}

// -------------------------------------------------------------------

// ActiveSafetyReq

// .strategy_trader.ActiveSafetyReq.MessageType safe_id = 1;
inline void ActiveSafetyReq::clear_safe_id() {
  _impl_.safe_id_ = 0;
}
inline ::strategy_trader::ActiveSafetyReq_MessageType ActiveSafetyReq::_internal_safe_id() const {
  return static_cast< ::strategy_trader::ActiveSafetyReq_MessageType >(_impl_.safe_id_);
}
inline ::strategy_trader::ActiveSafetyReq_MessageType ActiveSafetyReq::safe_id() const {
  // @@protoc_insertion_point(field_get:strategy_trader.ActiveSafetyReq.safe_id)
  return _internal_safe_id();
}
inline void ActiveSafetyReq::_internal_set_safe_id(::strategy_trader::ActiveSafetyReq_MessageType value) {
  
  _impl_.safe_id_ = value;
}
inline void ActiveSafetyReq::set_safe_id(::strategy_trader::ActiveSafetyReq_MessageType value) {
  _internal_set_safe_id(value);
  // @@protoc_insertion_point(field_set:strategy_trader.ActiveSafetyReq.safe_id)
}

// -------------------------------------------------------------------

// ActiveSafetyRsp

// bool status = 1;
inline void ActiveSafetyRsp::clear_status() {
  _impl_.status_ = false;
}
inline bool ActiveSafetyRsp::_internal_status() const {
  return _impl_.status_;
}
inline bool ActiveSafetyRsp::status() const {
  // @@protoc_insertion_point(field_get:strategy_trader.ActiveSafetyRsp.status)
  return _internal_status();
}
inline void ActiveSafetyRsp::_internal_set_status(bool value) {
  
  _impl_.status_ = value;
}
inline void ActiveSafetyRsp::set_status(bool value) {
  _internal_set_status(value);
  // @@protoc_insertion_point(field_set:strategy_trader.ActiveSafetyRsp.status)
}

// -------------------------------------------------------------------

// CheckStrategyAliveReq

// bool alive_req = 1;
inline void CheckStrategyAliveReq::clear_alive_req() {
  _impl_.alive_req_ = false;
}
inline bool CheckStrategyAliveReq::_internal_alive_req() const {
  return _impl_.alive_req_;
}
inline bool CheckStrategyAliveReq::alive_req() const {
  // @@protoc_insertion_point(field_get:strategy_trader.CheckStrategyAliveReq.alive_req)
  return _internal_alive_req();
}
inline void CheckStrategyAliveReq::_internal_set_alive_req(bool value) {
  
  _impl_.alive_req_ = value;
}
inline void CheckStrategyAliveReq::set_alive_req(bool value) {
  _internal_set_alive_req(value);
  // @@protoc_insertion_point(field_set:strategy_trader.CheckStrategyAliveReq.alive_req)
}

// -------------------------------------------------------------------

// CheckStrategyAliveRsp

// bool alive_rsp = 1;
inline void CheckStrategyAliveRsp::clear_alive_rsp() {
  _impl_.alive_rsp_ = false;
}
inline bool CheckStrategyAliveRsp::_internal_alive_rsp() const {
  return _impl_.alive_rsp_;
}
inline bool CheckStrategyAliveRsp::alive_rsp() const {
  // @@protoc_insertion_point(field_get:strategy_trader.CheckStrategyAliveRsp.alive_rsp)
  return _internal_alive_rsp();
}
inline void CheckStrategyAliveRsp::_internal_set_alive_rsp(bool value) {
  
  _impl_.alive_rsp_ = value;
}
inline void CheckStrategyAliveRsp::set_alive_rsp(bool value) {
  _internal_set_alive_rsp(value);
  // @@protoc_insertion_point(field_set:strategy_trader.CheckStrategyAliveRsp.alive_rsp)
}

// -------------------------------------------------------------------

// CheckTraderAliveReq

// bool alive_req = 1;
inline void CheckTraderAliveReq::clear_alive_req() {
  _impl_.alive_req_ = false;
}
inline bool CheckTraderAliveReq::_internal_alive_req() const {
  return _impl_.alive_req_;
}
inline bool CheckTraderAliveReq::alive_req() const {
  // @@protoc_insertion_point(field_get:strategy_trader.CheckTraderAliveReq.alive_req)
  return _internal_alive_req();
}
inline void CheckTraderAliveReq::_internal_set_alive_req(bool value) {
  
  _impl_.alive_req_ = value;
}
inline void CheckTraderAliveReq::set_alive_req(bool value) {
  _internal_set_alive_req(value);
  // @@protoc_insertion_point(field_set:strategy_trader.CheckTraderAliveReq.alive_req)
}

// -------------------------------------------------------------------

// CheckTraderAliveRsp

// bool alive_rsp = 1;
inline void CheckTraderAliveRsp::clear_alive_rsp() {
  _impl_.alive_rsp_ = false;
}
inline bool CheckTraderAliveRsp::_internal_alive_rsp() const {
  return _impl_.alive_rsp_;
}
inline bool CheckTraderAliveRsp::alive_rsp() const {
  // @@protoc_insertion_point(field_get:strategy_trader.CheckTraderAliveRsp.alive_rsp)
  return _internal_alive_rsp();
}
inline void CheckTraderAliveRsp::_internal_set_alive_rsp(bool value) {
  
  _impl_.alive_rsp_ = value;
}
inline void CheckTraderAliveRsp::set_alive_rsp(bool value) {
  _internal_set_alive_rsp(value);
  // @@protoc_insertion_point(field_set:strategy_trader.CheckTraderAliveRsp.alive_rsp)
}

// -------------------------------------------------------------------

// OrderPositionReq

// string instrument = 1;
inline void OrderPositionReq::clear_instrument() {
  _impl_.instrument_.ClearToEmpty();
}
inline const std::string& OrderPositionReq::instrument() const {
  // @@protoc_insertion_point(field_get:strategy_trader.OrderPositionReq.instrument)
  return _internal_instrument();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void OrderPositionReq::set_instrument(ArgT0&& arg0, ArgT... args) {
 
 _impl_.instrument_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:strategy_trader.OrderPositionReq.instrument)
}
inline std::string* OrderPositionReq::mutable_instrument() {
  std::string* _s = _internal_mutable_instrument();
  // @@protoc_insertion_point(field_mutable:strategy_trader.OrderPositionReq.instrument)
  return _s;
}
inline const std::string& OrderPositionReq::_internal_instrument() const {
  return _impl_.instrument_.Get();
}
inline void OrderPositionReq::_internal_set_instrument(const std::string& value) {
  
  _impl_.instrument_.Set(value, GetArenaForAllocation());
}
inline std::string* OrderPositionReq::_internal_mutable_instrument() {
  
  return _impl_.instrument_.Mutable(GetArenaForAllocation());
}
inline std::string* OrderPositionReq::release_instrument() {
  // @@protoc_insertion_point(field_release:strategy_trader.OrderPositionReq.instrument)
  return _impl_.instrument_.Release();
}
inline void OrderPositionReq::set_allocated_instrument(std::string* instrument) {
  if (instrument != nullptr) {
    
  } else {
    
  }
  _impl_.instrument_.SetAllocated(instrument, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.instrument_.IsDefault()) {
    _impl_.instrument_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:strategy_trader.OrderPositionReq.instrument)
}

// string index = 2;
inline void OrderPositionReq::clear_index() {
  _impl_.index_.ClearToEmpty();
}
inline const std::string& OrderPositionReq::index() const {
  // @@protoc_insertion_point(field_get:strategy_trader.OrderPositionReq.index)
  return _internal_index();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void OrderPositionReq::set_index(ArgT0&& arg0, ArgT... args) {
 
 _impl_.index_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:strategy_trader.OrderPositionReq.index)
}
inline std::string* OrderPositionReq::mutable_index() {
  std::string* _s = _internal_mutable_index();
  // @@protoc_insertion_point(field_mutable:strategy_trader.OrderPositionReq.index)
  return _s;
}
inline const std::string& OrderPositionReq::_internal_index() const {
  return _impl_.index_.Get();
}
inline void OrderPositionReq::_internal_set_index(const std::string& value) {
  
  _impl_.index_.Set(value, GetArenaForAllocation());
}
inline std::string* OrderPositionReq::_internal_mutable_index() {
  
  return _impl_.index_.Mutable(GetArenaForAllocation());
}
inline std::string* OrderPositionReq::release_index() {
  // @@protoc_insertion_point(field_release:strategy_trader.OrderPositionReq.index)
  return _impl_.index_.Release();
}
inline void OrderPositionReq::set_allocated_index(std::string* index) {
  if (index != nullptr) {
    
  } else {
    
  }
  _impl_.index_.SetAllocated(index, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.index_.IsDefault()) {
    _impl_.index_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:strategy_trader.OrderPositionReq.index)
}

// -------------------------------------------------------------------

// OrderPositionRsp

// string instrument = 1;
inline void OrderPositionRsp::clear_instrument() {
  _impl_.instrument_.ClearToEmpty();
}
inline const std::string& OrderPositionRsp::instrument() const {
  // @@protoc_insertion_point(field_get:strategy_trader.OrderPositionRsp.instrument)
  return _internal_instrument();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void OrderPositionRsp::set_instrument(ArgT0&& arg0, ArgT... args) {
 
 _impl_.instrument_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:strategy_trader.OrderPositionRsp.instrument)
}
inline std::string* OrderPositionRsp::mutable_instrument() {
  std::string* _s = _internal_mutable_instrument();
  // @@protoc_insertion_point(field_mutable:strategy_trader.OrderPositionRsp.instrument)
  return _s;
}
inline const std::string& OrderPositionRsp::_internal_instrument() const {
  return _impl_.instrument_.Get();
}
inline void OrderPositionRsp::_internal_set_instrument(const std::string& value) {
  
  _impl_.instrument_.Set(value, GetArenaForAllocation());
}
inline std::string* OrderPositionRsp::_internal_mutable_instrument() {
  
  return _impl_.instrument_.Mutable(GetArenaForAllocation());
}
inline std::string* OrderPositionRsp::release_instrument() {
  // @@protoc_insertion_point(field_release:strategy_trader.OrderPositionRsp.instrument)
  return _impl_.instrument_.Release();
}
inline void OrderPositionRsp::set_allocated_instrument(std::string* instrument) {
  if (instrument != nullptr) {
    
  } else {
    
  }
  _impl_.instrument_.SetAllocated(instrument, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.instrument_.IsDefault()) {
    _impl_.instrument_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:strategy_trader.OrderPositionRsp.instrument)
}

// string index = 2;
inline void OrderPositionRsp::clear_index() {
  _impl_.index_.ClearToEmpty();
}
inline const std::string& OrderPositionRsp::index() const {
  // @@protoc_insertion_point(field_get:strategy_trader.OrderPositionRsp.index)
  return _internal_index();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void OrderPositionRsp::set_index(ArgT0&& arg0, ArgT... args) {
 
 _impl_.index_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:strategy_trader.OrderPositionRsp.index)
}
inline std::string* OrderPositionRsp::mutable_index() {
  std::string* _s = _internal_mutable_index();
  // @@protoc_insertion_point(field_mutable:strategy_trader.OrderPositionRsp.index)
  return _s;
}
inline const std::string& OrderPositionRsp::_internal_index() const {
  return _impl_.index_.Get();
}
inline void OrderPositionRsp::_internal_set_index(const std::string& value) {
  
  _impl_.index_.Set(value, GetArenaForAllocation());
}
inline std::string* OrderPositionRsp::_internal_mutable_index() {
  
  return _impl_.index_.Mutable(GetArenaForAllocation());
}
inline std::string* OrderPositionRsp::release_index() {
  // @@protoc_insertion_point(field_release:strategy_trader.OrderPositionRsp.index)
  return _impl_.index_.Release();
}
inline void OrderPositionRsp::set_allocated_index(std::string* index) {
  if (index != nullptr) {
    
  } else {
    
  }
  _impl_.index_.SetAllocated(index, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.index_.IsDefault()) {
    _impl_.index_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:strategy_trader.OrderPositionRsp.index)
}

// uint32 volume = 3;
inline void OrderPositionRsp::clear_volume() {
  _impl_.volume_ = 0u;
}
inline uint32_t OrderPositionRsp::_internal_volume() const {
  return _impl_.volume_;
}
inline uint32_t OrderPositionRsp::volume() const {
  // @@protoc_insertion_point(field_get:strategy_trader.OrderPositionRsp.volume)
  return _internal_volume();
}
inline void OrderPositionRsp::_internal_set_volume(uint32_t value) {
  
  _impl_.volume_ = value;
}
inline void OrderPositionRsp::set_volume(uint32_t value) {
  _internal_set_volume(value);
  // @@protoc_insertion_point(field_set:strategy_trader.OrderPositionRsp.volume)
}

// -------------------------------------------------------------------

// GroupSizeReq

// uint32 size_req = 1;
inline void GroupSizeReq::clear_size_req() {
  _impl_.size_req_ = 0u;
}
inline uint32_t GroupSizeReq::_internal_size_req() const {
  return _impl_.size_req_;
}
inline uint32_t GroupSizeReq::size_req() const {
  // @@protoc_insertion_point(field_get:strategy_trader.GroupSizeReq.size_req)
  return _internal_size_req();
}
inline void GroupSizeReq::_internal_set_size_req(uint32_t value) {
  
  _impl_.size_req_ = value;
}
inline void GroupSizeReq::set_size_req(uint32_t value) {
  _internal_set_size_req(value);
  // @@protoc_insertion_point(field_set:strategy_trader.GroupSizeReq.size_req)
}

// -------------------------------------------------------------------

// GroupSizeRsp

// uint32 size_rsp = 1;
inline void GroupSizeRsp::clear_size_rsp() {
  _impl_.size_rsp_ = 0u;
}
inline uint32_t GroupSizeRsp::_internal_size_rsp() const {
  return _impl_.size_rsp_;
}
inline uint32_t GroupSizeRsp::size_rsp() const {
  // @@protoc_insertion_point(field_get:strategy_trader.GroupSizeRsp.size_rsp)
  return _internal_size_rsp();
}
inline void GroupSizeRsp::_internal_set_size_rsp(uint32_t value) {
  
  _impl_.size_rsp_ = value;
}
inline void GroupSizeRsp::set_size_rsp(uint32_t value) {
  _internal_set_size_rsp(value);
  // @@protoc_insertion_point(field_set:strategy_trader.GroupSizeRsp.size_rsp)
}

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace strategy_trader

PROTOBUF_NAMESPACE_OPEN

template <> struct is_proto_enum< ::strategy_trader::ActiveSafetyReq_MessageType> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::strategy_trader::ActiveSafetyReq_MessageType>() {
  return ::strategy_trader::ActiveSafetyReq_MessageType_descriptor();
}
template <> struct is_proto_enum< ::strategy_trader::Level> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::strategy_trader::Level>() {
  return ::strategy_trader::Level_descriptor();
}
template <> struct is_proto_enum< ::strategy_trader::FailedReason> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::strategy_trader::FailedReason>() {
  return ::strategy_trader::FailedReason_descriptor();
}
template <> struct is_proto_enum< ::strategy_trader::Result> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::strategy_trader::Result>() {
  return ::strategy_trader::Result_descriptor();
}
template <> struct is_proto_enum< ::strategy_trader::Direction> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::strategy_trader::Direction>() {
  return ::strategy_trader::Direction_descriptor();
}
template <> struct is_proto_enum< ::strategy_trader::OrderType> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::strategy_trader::OrderType>() {
  return ::strategy_trader::OrderType_descriptor();
}
template <> struct is_proto_enum< ::strategy_trader::CombOffsetType> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::strategy_trader::CombOffsetType>() {
  return ::strategy_trader::CombOffsetType_descriptor();
}

PROTOBUF_NAMESPACE_CLOSE

// @@protoc_insertion_point(global_scope)

#include <google/protobuf/port_undef.inc>
#endif  // GOOGLE_PROTOBUF_INCLUDED_GOOGLE_PROTOBUF_INCLUDED_strategy_2dtrader_2eproto
