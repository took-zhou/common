// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: strategy-market.proto

#ifndef GOOGLE_PROTOBUF_INCLUDED_strategy_2dmarket_2eproto
#define GOOGLE_PROTOBUF_INCLUDED_strategy_2dmarket_2eproto

#include <limits>
#include <string>

#include <google/protobuf/port_def.inc>
#if PROTOBUF_VERSION < 3021000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers. Please update
#error your headers.
#endif
#if 3021005 < PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers. Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/port_undef.inc>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/metadata_lite.h>
#include <google/protobuf/generated_message_reflection.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/generated_enum_reflection.h>
#include <google/protobuf/unknown_field_set.h>
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>
#define PROTOBUF_INTERNAL_EXPORT_strategy_2dmarket_2eproto
PROTOBUF_NAMESPACE_OPEN
namespace internal {
class AnyMetadata;
}  // namespace internal
PROTOBUF_NAMESPACE_CLOSE

// Internal implementation detail -- do not use these members.
struct TableStruct_strategy_2dmarket_2eproto {
  static const uint32_t offsets[];
};
extern const ::PROTOBUF_NAMESPACE_ID::internal::DescriptorTable descriptor_table_strategy_2dmarket_2eproto;
namespace strategy_market {
class ActiveSafetyReq;
struct ActiveSafetyReqDefaultTypeInternal;
extern ActiveSafetyReqDefaultTypeInternal _ActiveSafetyReq_default_instance_;
class ActiveSafetyRsp;
struct ActiveSafetyRspDefaultTypeInternal;
extern ActiveSafetyRspDefaultTypeInternal _ActiveSafetyRsp_default_instance_;
class CheckMarketAliveReq;
struct CheckMarketAliveReqDefaultTypeInternal;
extern CheckMarketAliveReqDefaultTypeInternal _CheckMarketAliveReq_default_instance_;
class CheckMarketAliveRsp;
struct CheckMarketAliveRspDefaultTypeInternal;
extern CheckMarketAliveRspDefaultTypeInternal _CheckMarketAliveRsp_default_instance_;
class CheckStrategyAliveReq;
struct CheckStrategyAliveReqDefaultTypeInternal;
extern CheckStrategyAliveReqDefaultTypeInternal _CheckStrategyAliveReq_default_instance_;
class CheckStrategyAliveRsp;
struct CheckStrategyAliveRspDefaultTypeInternal;
extern CheckStrategyAliveRspDefaultTypeInternal _CheckStrategyAliveRsp_default_instance_;
class InstrumentInfo;
struct InstrumentInfoDefaultTypeInternal;
extern InstrumentInfoDefaultTypeInternal _InstrumentInfo_default_instance_;
class InstrumentReq;
struct InstrumentReqDefaultTypeInternal;
extern InstrumentReqDefaultTypeInternal _InstrumentReq_default_instance_;
class InstrumentRsp;
struct InstrumentRspDefaultTypeInternal;
extern InstrumentRspDefaultTypeInternal _InstrumentRsp_default_instance_;
class MarketStateReq;
struct MarketStateReqDefaultTypeInternal;
extern MarketStateReqDefaultTypeInternal _MarketStateReq_default_instance_;
class MarketStateRsp;
struct MarketStateRspDefaultTypeInternal;
extern MarketStateRspDefaultTypeInternal _MarketStateRsp_default_instance_;
class TickData;
struct TickDataDefaultTypeInternal;
extern TickDataDefaultTypeInternal _TickData_default_instance_;
class TickSubscribeReq;
struct TickSubscribeReqDefaultTypeInternal;
extern TickSubscribeReqDefaultTypeInternal _TickSubscribeReq_default_instance_;
class TickSubscribeRsp;
struct TickSubscribeRspDefaultTypeInternal;
extern TickSubscribeRspDefaultTypeInternal _TickSubscribeRsp_default_instance_;
class message;
struct messageDefaultTypeInternal;
extern messageDefaultTypeInternal _message_default_instance_;
}  // namespace strategy_market
PROTOBUF_NAMESPACE_OPEN
template<> ::strategy_market::ActiveSafetyReq* Arena::CreateMaybeMessage<::strategy_market::ActiveSafetyReq>(Arena*);
template<> ::strategy_market::ActiveSafetyRsp* Arena::CreateMaybeMessage<::strategy_market::ActiveSafetyRsp>(Arena*);
template<> ::strategy_market::CheckMarketAliveReq* Arena::CreateMaybeMessage<::strategy_market::CheckMarketAliveReq>(Arena*);
template<> ::strategy_market::CheckMarketAliveRsp* Arena::CreateMaybeMessage<::strategy_market::CheckMarketAliveRsp>(Arena*);
template<> ::strategy_market::CheckStrategyAliveReq* Arena::CreateMaybeMessage<::strategy_market::CheckStrategyAliveReq>(Arena*);
template<> ::strategy_market::CheckStrategyAliveRsp* Arena::CreateMaybeMessage<::strategy_market::CheckStrategyAliveRsp>(Arena*);
template<> ::strategy_market::InstrumentInfo* Arena::CreateMaybeMessage<::strategy_market::InstrumentInfo>(Arena*);
template<> ::strategy_market::InstrumentReq* Arena::CreateMaybeMessage<::strategy_market::InstrumentReq>(Arena*);
template<> ::strategy_market::InstrumentRsp* Arena::CreateMaybeMessage<::strategy_market::InstrumentRsp>(Arena*);
template<> ::strategy_market::MarketStateReq* Arena::CreateMaybeMessage<::strategy_market::MarketStateReq>(Arena*);
template<> ::strategy_market::MarketStateRsp* Arena::CreateMaybeMessage<::strategy_market::MarketStateRsp>(Arena*);
template<> ::strategy_market::TickData* Arena::CreateMaybeMessage<::strategy_market::TickData>(Arena*);
template<> ::strategy_market::TickSubscribeReq* Arena::CreateMaybeMessage<::strategy_market::TickSubscribeReq>(Arena*);
template<> ::strategy_market::TickSubscribeRsp* Arena::CreateMaybeMessage<::strategy_market::TickSubscribeRsp>(Arena*);
template<> ::strategy_market::message* Arena::CreateMaybeMessage<::strategy_market::message>(Arena*);
PROTOBUF_NAMESPACE_CLOSE
namespace strategy_market {

enum TickData_TickState : int {
  TickData_TickState_active = 0,
  TickData_TickState_inactive = 1,
  TickData_TickState_TickData_TickState_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  TickData_TickState_TickData_TickState_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
bool TickData_TickState_IsValid(int value);
constexpr TickData_TickState TickData_TickState_TickState_MIN = TickData_TickState_active;
constexpr TickData_TickState TickData_TickState_TickState_MAX = TickData_TickState_inactive;
constexpr int TickData_TickState_TickState_ARRAYSIZE = TickData_TickState_TickState_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* TickData_TickState_descriptor();
template<typename T>
inline const std::string& TickData_TickState_Name(T enum_t_value) {
  static_assert(::std::is_same<T, TickData_TickState>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function TickData_TickState_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    TickData_TickState_descriptor(), enum_t_value);
}
inline bool TickData_TickState_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, TickData_TickState* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<TickData_TickState>(
    TickData_TickState_descriptor(), name, value);
}
enum MarketStateReq_MarketState : int {
  MarketStateReq_MarketState_reserve = 0,
  MarketStateReq_MarketState_day_open = 1,
  MarketStateReq_MarketState_day_close = 2,
  MarketStateReq_MarketState_night_open = 3,
  MarketStateReq_MarketState_night_close = 4,
  MarketStateReq_MarketState_MarketStateReq_MarketState_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  MarketStateReq_MarketState_MarketStateReq_MarketState_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
bool MarketStateReq_MarketState_IsValid(int value);
constexpr MarketStateReq_MarketState MarketStateReq_MarketState_MarketState_MIN = MarketStateReq_MarketState_reserve;
constexpr MarketStateReq_MarketState MarketStateReq_MarketState_MarketState_MAX = MarketStateReq_MarketState_night_close;
constexpr int MarketStateReq_MarketState_MarketState_ARRAYSIZE = MarketStateReq_MarketState_MarketState_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* MarketStateReq_MarketState_descriptor();
template<typename T>
inline const std::string& MarketStateReq_MarketState_Name(T enum_t_value) {
  static_assert(::std::is_same<T, MarketStateReq_MarketState>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function MarketStateReq_MarketState_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    MarketStateReq_MarketState_descriptor(), enum_t_value);
}
inline bool MarketStateReq_MarketState_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, MarketStateReq_MarketState* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<MarketStateReq_MarketState>(
    MarketStateReq_MarketState_descriptor(), name, value);
}
enum TickSubscribeReq_Action : int {
  TickSubscribeReq_Action_sub = 0,
  TickSubscribeReq_Action_unsub = 1,
  TickSubscribeReq_Action_TickSubscribeReq_Action_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  TickSubscribeReq_Action_TickSubscribeReq_Action_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
bool TickSubscribeReq_Action_IsValid(int value);
constexpr TickSubscribeReq_Action TickSubscribeReq_Action_Action_MIN = TickSubscribeReq_Action_sub;
constexpr TickSubscribeReq_Action TickSubscribeReq_Action_Action_MAX = TickSubscribeReq_Action_unsub;
constexpr int TickSubscribeReq_Action_Action_ARRAYSIZE = TickSubscribeReq_Action_Action_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* TickSubscribeReq_Action_descriptor();
template<typename T>
inline const std::string& TickSubscribeReq_Action_Name(T enum_t_value) {
  static_assert(::std::is_same<T, TickSubscribeReq_Action>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function TickSubscribeReq_Action_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    TickSubscribeReq_Action_descriptor(), enum_t_value);
}
inline bool TickSubscribeReq_Action_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, TickSubscribeReq_Action* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<TickSubscribeReq_Action>(
    TickSubscribeReq_Action_descriptor(), name, value);
}
enum ActiveSafetyReq_MessageType : int {
  ActiveSafetyReq_MessageType_reserve = 0,
  ActiveSafetyReq_MessageType_isrun = 1,
  ActiveSafetyReq_MessageType_ActiveSafetyReq_MessageType_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  ActiveSafetyReq_MessageType_ActiveSafetyReq_MessageType_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
bool ActiveSafetyReq_MessageType_IsValid(int value);
constexpr ActiveSafetyReq_MessageType ActiveSafetyReq_MessageType_MessageType_MIN = ActiveSafetyReq_MessageType_reserve;
constexpr ActiveSafetyReq_MessageType ActiveSafetyReq_MessageType_MessageType_MAX = ActiveSafetyReq_MessageType_isrun;
constexpr int ActiveSafetyReq_MessageType_MessageType_ARRAYSIZE = ActiveSafetyReq_MessageType_MessageType_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* ActiveSafetyReq_MessageType_descriptor();
template<typename T>
inline const std::string& ActiveSafetyReq_MessageType_Name(T enum_t_value) {
  static_assert(::std::is_same<T, ActiveSafetyReq_MessageType>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function ActiveSafetyReq_MessageType_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    ActiveSafetyReq_MessageType_descriptor(), enum_t_value);
}
inline bool ActiveSafetyReq_MessageType_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, ActiveSafetyReq_MessageType* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<ActiveSafetyReq_MessageType>(
    ActiveSafetyReq_MessageType_descriptor(), name, value);
}
enum Result : int {
  Result_INVALID = 0,
  success = 1,
  failed = 2,
  Result_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  Result_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
bool Result_IsValid(int value);
constexpr Result Result_MIN = Result_INVALID;
constexpr Result Result_MAX = failed;
constexpr int Result_ARRAYSIZE = Result_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* Result_descriptor();
template<typename T>
inline const std::string& Result_Name(T enum_t_value) {
  static_assert(::std::is_same<T, Result>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function Result_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    Result_descriptor(), enum_t_value);
}
inline bool Result_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, Result* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<Result>(
    Result_descriptor(), name, value);
}
// ===================================================================

class message final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:strategy_market.message) */ {
 public:
  inline message() : message(nullptr) {}
  ~message() override;
  explicit PROTOBUF_CONSTEXPR message(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  message(const message& from);
  message(message&& from) noexcept
    : message() {
    *this = ::std::move(from);
  }

  inline message& operator=(const message& from) {
    CopyFrom(from);
    return *this;
  }
  inline message& operator=(message&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const message& default_instance() {
    return *internal_default_instance();
  }
  enum MessageTypeCase {
    kTickSubReq = 1,
    kTickSubRsp = 2,
    kTickData = 3,
    kMarketStateReq = 4,
    kMarketStateRsp = 5,
    kActiveReq = 6,
    kActiveRsp = 7,
    kInstrumentReq = 8,
    kInstrumentRsp = 9,
    kStrategyAliveReq = 10,
    kStrategyAliveRsp = 11,
    kMarketAliveReq = 12,
    kMarketAliveRsp = 13,
    MESSAGETYPE_NOT_SET = 0,
  };

  static inline const message* internal_default_instance() {
    return reinterpret_cast<const message*>(
               &_message_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  friend void swap(message& a, message& b) {
    a.Swap(&b);
  }
  inline void Swap(message* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(message* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  message* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<message>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const message& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const message& from) {
    message::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(message* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "strategy_market.message";
  }
  protected:
  explicit message(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kTickSubReqFieldNumber = 1,
    kTickSubRspFieldNumber = 2,
    kTickDataFieldNumber = 3,
    kMarketStateReqFieldNumber = 4,
    kMarketStateRspFieldNumber = 5,
    kActiveReqFieldNumber = 6,
    kActiveRspFieldNumber = 7,
    kInstrumentReqFieldNumber = 8,
    kInstrumentRspFieldNumber = 9,
    kStrategyAliveReqFieldNumber = 10,
    kStrategyAliveRspFieldNumber = 11,
    kMarketAliveReqFieldNumber = 12,
    kMarketAliveRspFieldNumber = 13,
  };
  // .strategy_market.TickSubscribeReq tick_sub_req = 1;
  bool has_tick_sub_req() const;
  private:
  bool _internal_has_tick_sub_req() const;
  public:
  void clear_tick_sub_req();
  const ::strategy_market::TickSubscribeReq& tick_sub_req() const;
  PROTOBUF_NODISCARD ::strategy_market::TickSubscribeReq* release_tick_sub_req();
  ::strategy_market::TickSubscribeReq* mutable_tick_sub_req();
  void set_allocated_tick_sub_req(::strategy_market::TickSubscribeReq* tick_sub_req);
  private:
  const ::strategy_market::TickSubscribeReq& _internal_tick_sub_req() const;
  ::strategy_market::TickSubscribeReq* _internal_mutable_tick_sub_req();
  public:
  void unsafe_arena_set_allocated_tick_sub_req(
      ::strategy_market::TickSubscribeReq* tick_sub_req);
  ::strategy_market::TickSubscribeReq* unsafe_arena_release_tick_sub_req();

  // .strategy_market.TickSubscribeRsp tick_sub_rsp = 2;
  bool has_tick_sub_rsp() const;
  private:
  bool _internal_has_tick_sub_rsp() const;
  public:
  void clear_tick_sub_rsp();
  const ::strategy_market::TickSubscribeRsp& tick_sub_rsp() const;
  PROTOBUF_NODISCARD ::strategy_market::TickSubscribeRsp* release_tick_sub_rsp();
  ::strategy_market::TickSubscribeRsp* mutable_tick_sub_rsp();
  void set_allocated_tick_sub_rsp(::strategy_market::TickSubscribeRsp* tick_sub_rsp);
  private:
  const ::strategy_market::TickSubscribeRsp& _internal_tick_sub_rsp() const;
  ::strategy_market::TickSubscribeRsp* _internal_mutable_tick_sub_rsp();
  public:
  void unsafe_arena_set_allocated_tick_sub_rsp(
      ::strategy_market::TickSubscribeRsp* tick_sub_rsp);
  ::strategy_market::TickSubscribeRsp* unsafe_arena_release_tick_sub_rsp();

  // .strategy_market.TickData tick_data = 3;
  bool has_tick_data() const;
  private:
  bool _internal_has_tick_data() const;
  public:
  void clear_tick_data();
  const ::strategy_market::TickData& tick_data() const;
  PROTOBUF_NODISCARD ::strategy_market::TickData* release_tick_data();
  ::strategy_market::TickData* mutable_tick_data();
  void set_allocated_tick_data(::strategy_market::TickData* tick_data);
  private:
  const ::strategy_market::TickData& _internal_tick_data() const;
  ::strategy_market::TickData* _internal_mutable_tick_data();
  public:
  void unsafe_arena_set_allocated_tick_data(
      ::strategy_market::TickData* tick_data);
  ::strategy_market::TickData* unsafe_arena_release_tick_data();

  // .strategy_market.MarketStateReq market_state_req = 4;
  bool has_market_state_req() const;
  private:
  bool _internal_has_market_state_req() const;
  public:
  void clear_market_state_req();
  const ::strategy_market::MarketStateReq& market_state_req() const;
  PROTOBUF_NODISCARD ::strategy_market::MarketStateReq* release_market_state_req();
  ::strategy_market::MarketStateReq* mutable_market_state_req();
  void set_allocated_market_state_req(::strategy_market::MarketStateReq* market_state_req);
  private:
  const ::strategy_market::MarketStateReq& _internal_market_state_req() const;
  ::strategy_market::MarketStateReq* _internal_mutable_market_state_req();
  public:
  void unsafe_arena_set_allocated_market_state_req(
      ::strategy_market::MarketStateReq* market_state_req);
  ::strategy_market::MarketStateReq* unsafe_arena_release_market_state_req();

  // .strategy_market.MarketStateRsp market_state_rsp = 5;
  bool has_market_state_rsp() const;
  private:
  bool _internal_has_market_state_rsp() const;
  public:
  void clear_market_state_rsp();
  const ::strategy_market::MarketStateRsp& market_state_rsp() const;
  PROTOBUF_NODISCARD ::strategy_market::MarketStateRsp* release_market_state_rsp();
  ::strategy_market::MarketStateRsp* mutable_market_state_rsp();
  void set_allocated_market_state_rsp(::strategy_market::MarketStateRsp* market_state_rsp);
  private:
  const ::strategy_market::MarketStateRsp& _internal_market_state_rsp() const;
  ::strategy_market::MarketStateRsp* _internal_mutable_market_state_rsp();
  public:
  void unsafe_arena_set_allocated_market_state_rsp(
      ::strategy_market::MarketStateRsp* market_state_rsp);
  ::strategy_market::MarketStateRsp* unsafe_arena_release_market_state_rsp();

  // .strategy_market.ActiveSafetyReq active_req = 6;
  bool has_active_req() const;
  private:
  bool _internal_has_active_req() const;
  public:
  void clear_active_req();
  const ::strategy_market::ActiveSafetyReq& active_req() const;
  PROTOBUF_NODISCARD ::strategy_market::ActiveSafetyReq* release_active_req();
  ::strategy_market::ActiveSafetyReq* mutable_active_req();
  void set_allocated_active_req(::strategy_market::ActiveSafetyReq* active_req);
  private:
  const ::strategy_market::ActiveSafetyReq& _internal_active_req() const;
  ::strategy_market::ActiveSafetyReq* _internal_mutable_active_req();
  public:
  void unsafe_arena_set_allocated_active_req(
      ::strategy_market::ActiveSafetyReq* active_req);
  ::strategy_market::ActiveSafetyReq* unsafe_arena_release_active_req();

  // .strategy_market.ActiveSafetyRsp active_rsp = 7;
  bool has_active_rsp() const;
  private:
  bool _internal_has_active_rsp() const;
  public:
  void clear_active_rsp();
  const ::strategy_market::ActiveSafetyRsp& active_rsp() const;
  PROTOBUF_NODISCARD ::strategy_market::ActiveSafetyRsp* release_active_rsp();
  ::strategy_market::ActiveSafetyRsp* mutable_active_rsp();
  void set_allocated_active_rsp(::strategy_market::ActiveSafetyRsp* active_rsp);
  private:
  const ::strategy_market::ActiveSafetyRsp& _internal_active_rsp() const;
  ::strategy_market::ActiveSafetyRsp* _internal_mutable_active_rsp();
  public:
  void unsafe_arena_set_allocated_active_rsp(
      ::strategy_market::ActiveSafetyRsp* active_rsp);
  ::strategy_market::ActiveSafetyRsp* unsafe_arena_release_active_rsp();

  // .strategy_market.InstrumentReq instrument_req = 8;
  bool has_instrument_req() const;
  private:
  bool _internal_has_instrument_req() const;
  public:
  void clear_instrument_req();
  const ::strategy_market::InstrumentReq& instrument_req() const;
  PROTOBUF_NODISCARD ::strategy_market::InstrumentReq* release_instrument_req();
  ::strategy_market::InstrumentReq* mutable_instrument_req();
  void set_allocated_instrument_req(::strategy_market::InstrumentReq* instrument_req);
  private:
  const ::strategy_market::InstrumentReq& _internal_instrument_req() const;
  ::strategy_market::InstrumentReq* _internal_mutable_instrument_req();
  public:
  void unsafe_arena_set_allocated_instrument_req(
      ::strategy_market::InstrumentReq* instrument_req);
  ::strategy_market::InstrumentReq* unsafe_arena_release_instrument_req();

  // .strategy_market.InstrumentRsp instrument_rsp = 9;
  bool has_instrument_rsp() const;
  private:
  bool _internal_has_instrument_rsp() const;
  public:
  void clear_instrument_rsp();
  const ::strategy_market::InstrumentRsp& instrument_rsp() const;
  PROTOBUF_NODISCARD ::strategy_market::InstrumentRsp* release_instrument_rsp();
  ::strategy_market::InstrumentRsp* mutable_instrument_rsp();
  void set_allocated_instrument_rsp(::strategy_market::InstrumentRsp* instrument_rsp);
  private:
  const ::strategy_market::InstrumentRsp& _internal_instrument_rsp() const;
  ::strategy_market::InstrumentRsp* _internal_mutable_instrument_rsp();
  public:
  void unsafe_arena_set_allocated_instrument_rsp(
      ::strategy_market::InstrumentRsp* instrument_rsp);
  ::strategy_market::InstrumentRsp* unsafe_arena_release_instrument_rsp();

  // .strategy_market.CheckStrategyAliveReq strategy_alive_req = 10;
  bool has_strategy_alive_req() const;
  private:
  bool _internal_has_strategy_alive_req() const;
  public:
  void clear_strategy_alive_req();
  const ::strategy_market::CheckStrategyAliveReq& strategy_alive_req() const;
  PROTOBUF_NODISCARD ::strategy_market::CheckStrategyAliveReq* release_strategy_alive_req();
  ::strategy_market::CheckStrategyAliveReq* mutable_strategy_alive_req();
  void set_allocated_strategy_alive_req(::strategy_market::CheckStrategyAliveReq* strategy_alive_req);
  private:
  const ::strategy_market::CheckStrategyAliveReq& _internal_strategy_alive_req() const;
  ::strategy_market::CheckStrategyAliveReq* _internal_mutable_strategy_alive_req();
  public:
  void unsafe_arena_set_allocated_strategy_alive_req(
      ::strategy_market::CheckStrategyAliveReq* strategy_alive_req);
  ::strategy_market::CheckStrategyAliveReq* unsafe_arena_release_strategy_alive_req();

  // .strategy_market.CheckStrategyAliveRsp strategy_alive_rsp = 11;
  bool has_strategy_alive_rsp() const;
  private:
  bool _internal_has_strategy_alive_rsp() const;
  public:
  void clear_strategy_alive_rsp();
  const ::strategy_market::CheckStrategyAliveRsp& strategy_alive_rsp() const;
  PROTOBUF_NODISCARD ::strategy_market::CheckStrategyAliveRsp* release_strategy_alive_rsp();
  ::strategy_market::CheckStrategyAliveRsp* mutable_strategy_alive_rsp();
  void set_allocated_strategy_alive_rsp(::strategy_market::CheckStrategyAliveRsp* strategy_alive_rsp);
  private:
  const ::strategy_market::CheckStrategyAliveRsp& _internal_strategy_alive_rsp() const;
  ::strategy_market::CheckStrategyAliveRsp* _internal_mutable_strategy_alive_rsp();
  public:
  void unsafe_arena_set_allocated_strategy_alive_rsp(
      ::strategy_market::CheckStrategyAliveRsp* strategy_alive_rsp);
  ::strategy_market::CheckStrategyAliveRsp* unsafe_arena_release_strategy_alive_rsp();

  // .strategy_market.CheckMarketAliveReq market_alive_req = 12;
  bool has_market_alive_req() const;
  private:
  bool _internal_has_market_alive_req() const;
  public:
  void clear_market_alive_req();
  const ::strategy_market::CheckMarketAliveReq& market_alive_req() const;
  PROTOBUF_NODISCARD ::strategy_market::CheckMarketAliveReq* release_market_alive_req();
  ::strategy_market::CheckMarketAliveReq* mutable_market_alive_req();
  void set_allocated_market_alive_req(::strategy_market::CheckMarketAliveReq* market_alive_req);
  private:
  const ::strategy_market::CheckMarketAliveReq& _internal_market_alive_req() const;
  ::strategy_market::CheckMarketAliveReq* _internal_mutable_market_alive_req();
  public:
  void unsafe_arena_set_allocated_market_alive_req(
      ::strategy_market::CheckMarketAliveReq* market_alive_req);
  ::strategy_market::CheckMarketAliveReq* unsafe_arena_release_market_alive_req();

  // .strategy_market.CheckMarketAliveRsp market_alive_rsp = 13;
  bool has_market_alive_rsp() const;
  private:
  bool _internal_has_market_alive_rsp() const;
  public:
  void clear_market_alive_rsp();
  const ::strategy_market::CheckMarketAliveRsp& market_alive_rsp() const;
  PROTOBUF_NODISCARD ::strategy_market::CheckMarketAliveRsp* release_market_alive_rsp();
  ::strategy_market::CheckMarketAliveRsp* mutable_market_alive_rsp();
  void set_allocated_market_alive_rsp(::strategy_market::CheckMarketAliveRsp* market_alive_rsp);
  private:
  const ::strategy_market::CheckMarketAliveRsp& _internal_market_alive_rsp() const;
  ::strategy_market::CheckMarketAliveRsp* _internal_mutable_market_alive_rsp();
  public:
  void unsafe_arena_set_allocated_market_alive_rsp(
      ::strategy_market::CheckMarketAliveRsp* market_alive_rsp);
  ::strategy_market::CheckMarketAliveRsp* unsafe_arena_release_market_alive_rsp();

  void clear_MessageType();
  MessageTypeCase MessageType_case() const;
  // @@protoc_insertion_point(class_scope:strategy_market.message)
 private:
  class _Internal;
  void set_has_tick_sub_req();
  void set_has_tick_sub_rsp();
  void set_has_tick_data();
  void set_has_market_state_req();
  void set_has_market_state_rsp();
  void set_has_active_req();
  void set_has_active_rsp();
  void set_has_instrument_req();
  void set_has_instrument_rsp();
  void set_has_strategy_alive_req();
  void set_has_strategy_alive_rsp();
  void set_has_market_alive_req();
  void set_has_market_alive_rsp();

  inline bool has_MessageType() const;
  inline void clear_has_MessageType();

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    union MessageTypeUnion {
      constexpr MessageTypeUnion() : _constinit_{} {}
        ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized _constinit_;
      ::strategy_market::TickSubscribeReq* tick_sub_req_;
      ::strategy_market::TickSubscribeRsp* tick_sub_rsp_;
      ::strategy_market::TickData* tick_data_;
      ::strategy_market::MarketStateReq* market_state_req_;
      ::strategy_market::MarketStateRsp* market_state_rsp_;
      ::strategy_market::ActiveSafetyReq* active_req_;
      ::strategy_market::ActiveSafetyRsp* active_rsp_;
      ::strategy_market::InstrumentReq* instrument_req_;
      ::strategy_market::InstrumentRsp* instrument_rsp_;
      ::strategy_market::CheckStrategyAliveReq* strategy_alive_req_;
      ::strategy_market::CheckStrategyAliveRsp* strategy_alive_rsp_;
      ::strategy_market::CheckMarketAliveReq* market_alive_req_;
      ::strategy_market::CheckMarketAliveRsp* market_alive_rsp_;
    } MessageType_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    uint32_t _oneof_case_[1];

  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_strategy_2dmarket_2eproto;
};
// -------------------------------------------------------------------

class TickData final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:strategy_market.TickData) */ {
 public:
  inline TickData() : TickData(nullptr) {}
  ~TickData() override;
  explicit PROTOBUF_CONSTEXPR TickData(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  TickData(const TickData& from);
  TickData(TickData&& from) noexcept
    : TickData() {
    *this = ::std::move(from);
  }

  inline TickData& operator=(const TickData& from) {
    CopyFrom(from);
    return *this;
  }
  inline TickData& operator=(TickData&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const TickData& default_instance() {
    return *internal_default_instance();
  }
  static inline const TickData* internal_default_instance() {
    return reinterpret_cast<const TickData*>(
               &_TickData_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  friend void swap(TickData& a, TickData& b) {
    a.Swap(&b);
  }
  inline void Swap(TickData* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(TickData* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  TickData* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<TickData>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const TickData& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const TickData& from) {
    TickData::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(TickData* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "strategy_market.TickData";
  }
  protected:
  explicit TickData(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef TickData_TickState TickState;
  static constexpr TickState active =
    TickData_TickState_active;
  static constexpr TickState inactive =
    TickData_TickState_inactive;
  static inline bool TickState_IsValid(int value) {
    return TickData_TickState_IsValid(value);
  }
  static constexpr TickState TickState_MIN =
    TickData_TickState_TickState_MIN;
  static constexpr TickState TickState_MAX =
    TickData_TickState_TickState_MAX;
  static constexpr int TickState_ARRAYSIZE =
    TickData_TickState_TickState_ARRAYSIZE;
  static inline const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
  TickState_descriptor() {
    return TickData_TickState_descriptor();
  }
  template<typename T>
  static inline const std::string& TickState_Name(T enum_t_value) {
    static_assert(::std::is_same<T, TickState>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function TickState_Name.");
    return TickData_TickState_Name(enum_t_value);
  }
  static inline bool TickState_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name,
      TickState* value) {
    return TickData_TickState_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  enum : int {
    kTimePointFieldNumber = 1,
    kInstrumentIdFieldNumber = 2,
    kLastPriceFieldNumber = 4,
    kStateFieldNumber = 3,
    kBidVolume1FieldNumber = 6,
    kBidPrice1FieldNumber = 5,
    kAskPrice1FieldNumber = 7,
    kBidPrice2FieldNumber = 9,
    kAskVolume1FieldNumber = 8,
    kBidVolume2FieldNumber = 10,
    kAskPrice2FieldNumber = 11,
    kBidPrice3FieldNumber = 13,
    kAskVolume2FieldNumber = 12,
    kBidVolume3FieldNumber = 14,
    kAskPrice3FieldNumber = 15,
    kBidPrice4FieldNumber = 17,
    kAskVolume3FieldNumber = 16,
    kBidVolume4FieldNumber = 18,
    kAskPrice4FieldNumber = 19,
    kBidPrice5FieldNumber = 21,
    kAskVolume4FieldNumber = 20,
    kBidVolume5FieldNumber = 22,
    kAskPrice5FieldNumber = 23,
    kTurnoverFieldNumber = 25,
    kOpenInterestFieldNumber = 26,
    kUpperLimitPriceFieldNumber = 27,
    kLowerLimitPriceFieldNumber = 28,
    kOpenPriceFieldNumber = 29,
    kPreSettlementPriceFieldNumber = 30,
    kPreClosePriceFieldNumber = 31,
    kPreOpenInterestFieldNumber = 32,
    kVolumeFieldNumber = 33,
    kAskVolume5FieldNumber = 24,
  };
  // string time_point = 1;
  void clear_time_point();
  const std::string& time_point() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_time_point(ArgT0&& arg0, ArgT... args);
  std::string* mutable_time_point();
  PROTOBUF_NODISCARD std::string* release_time_point();
  void set_allocated_time_point(std::string* time_point);
  private:
  const std::string& _internal_time_point() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_time_point(const std::string& value);
  std::string* _internal_mutable_time_point();
  public:

  // string instrument_id = 2;
  void clear_instrument_id();
  const std::string& instrument_id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_instrument_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_instrument_id();
  PROTOBUF_NODISCARD std::string* release_instrument_id();
  void set_allocated_instrument_id(std::string* instrument_id);
  private:
  const std::string& _internal_instrument_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_instrument_id(const std::string& value);
  std::string* _internal_mutable_instrument_id();
  public:

  // double last_price = 4;
  void clear_last_price();
  double last_price() const;
  void set_last_price(double value);
  private:
  double _internal_last_price() const;
  void _internal_set_last_price(double value);
  public:

  // .strategy_market.TickData.TickState state = 3;
  void clear_state();
  ::strategy_market::TickData_TickState state() const;
  void set_state(::strategy_market::TickData_TickState value);
  private:
  ::strategy_market::TickData_TickState _internal_state() const;
  void _internal_set_state(::strategy_market::TickData_TickState value);
  public:

  // uint32 bid_volume1 = 6;
  void clear_bid_volume1();
  uint32_t bid_volume1() const;
  void set_bid_volume1(uint32_t value);
  private:
  uint32_t _internal_bid_volume1() const;
  void _internal_set_bid_volume1(uint32_t value);
  public:

  // double bid_price1 = 5;
  void clear_bid_price1();
  double bid_price1() const;
  void set_bid_price1(double value);
  private:
  double _internal_bid_price1() const;
  void _internal_set_bid_price1(double value);
  public:

  // double ask_price1 = 7;
  void clear_ask_price1();
  double ask_price1() const;
  void set_ask_price1(double value);
  private:
  double _internal_ask_price1() const;
  void _internal_set_ask_price1(double value);
  public:

  // double bid_price2 = 9;
  void clear_bid_price2();
  double bid_price2() const;
  void set_bid_price2(double value);
  private:
  double _internal_bid_price2() const;
  void _internal_set_bid_price2(double value);
  public:

  // uint32 ask_volume1 = 8;
  void clear_ask_volume1();
  uint32_t ask_volume1() const;
  void set_ask_volume1(uint32_t value);
  private:
  uint32_t _internal_ask_volume1() const;
  void _internal_set_ask_volume1(uint32_t value);
  public:

  // uint32 bid_volume2 = 10;
  void clear_bid_volume2();
  uint32_t bid_volume2() const;
  void set_bid_volume2(uint32_t value);
  private:
  uint32_t _internal_bid_volume2() const;
  void _internal_set_bid_volume2(uint32_t value);
  public:

  // double ask_price2 = 11;
  void clear_ask_price2();
  double ask_price2() const;
  void set_ask_price2(double value);
  private:
  double _internal_ask_price2() const;
  void _internal_set_ask_price2(double value);
  public:

  // double bid_price3 = 13;
  void clear_bid_price3();
  double bid_price3() const;
  void set_bid_price3(double value);
  private:
  double _internal_bid_price3() const;
  void _internal_set_bid_price3(double value);
  public:

  // uint32 ask_volume2 = 12;
  void clear_ask_volume2();
  uint32_t ask_volume2() const;
  void set_ask_volume2(uint32_t value);
  private:
  uint32_t _internal_ask_volume2() const;
  void _internal_set_ask_volume2(uint32_t value);
  public:

  // uint32 bid_volume3 = 14;
  void clear_bid_volume3();
  uint32_t bid_volume3() const;
  void set_bid_volume3(uint32_t value);
  private:
  uint32_t _internal_bid_volume3() const;
  void _internal_set_bid_volume3(uint32_t value);
  public:

  // double ask_price3 = 15;
  void clear_ask_price3();
  double ask_price3() const;
  void set_ask_price3(double value);
  private:
  double _internal_ask_price3() const;
  void _internal_set_ask_price3(double value);
  public:

  // double bid_price4 = 17;
  void clear_bid_price4();
  double bid_price4() const;
  void set_bid_price4(double value);
  private:
  double _internal_bid_price4() const;
  void _internal_set_bid_price4(double value);
  public:

  // uint32 ask_volume3 = 16;
  void clear_ask_volume3();
  uint32_t ask_volume3() const;
  void set_ask_volume3(uint32_t value);
  private:
  uint32_t _internal_ask_volume3() const;
  void _internal_set_ask_volume3(uint32_t value);
  public:

  // uint32 bid_volume4 = 18;
  void clear_bid_volume4();
  uint32_t bid_volume4() const;
  void set_bid_volume4(uint32_t value);
  private:
  uint32_t _internal_bid_volume4() const;
  void _internal_set_bid_volume4(uint32_t value);
  public:

  // double ask_price4 = 19;
  void clear_ask_price4();
  double ask_price4() const;
  void set_ask_price4(double value);
  private:
  double _internal_ask_price4() const;
  void _internal_set_ask_price4(double value);
  public:

  // double bid_price5 = 21;
  void clear_bid_price5();
  double bid_price5() const;
  void set_bid_price5(double value);
  private:
  double _internal_bid_price5() const;
  void _internal_set_bid_price5(double value);
  public:

  // uint32 ask_volume4 = 20;
  void clear_ask_volume4();
  uint32_t ask_volume4() const;
  void set_ask_volume4(uint32_t value);
  private:
  uint32_t _internal_ask_volume4() const;
  void _internal_set_ask_volume4(uint32_t value);
  public:

  // uint32 bid_volume5 = 22;
  void clear_bid_volume5();
  uint32_t bid_volume5() const;
  void set_bid_volume5(uint32_t value);
  private:
  uint32_t _internal_bid_volume5() const;
  void _internal_set_bid_volume5(uint32_t value);
  public:

  // double ask_price5 = 23;
  void clear_ask_price5();
  double ask_price5() const;
  void set_ask_price5(double value);
  private:
  double _internal_ask_price5() const;
  void _internal_set_ask_price5(double value);
  public:

  // double turnover = 25;
  void clear_turnover();
  double turnover() const;
  void set_turnover(double value);
  private:
  double _internal_turnover() const;
  void _internal_set_turnover(double value);
  public:

  // uint64 open_interest = 26;
  void clear_open_interest();
  uint64_t open_interest() const;
  void set_open_interest(uint64_t value);
  private:
  uint64_t _internal_open_interest() const;
  void _internal_set_open_interest(uint64_t value);
  public:

  // double upper_limit_price = 27;
  void clear_upper_limit_price();
  double upper_limit_price() const;
  void set_upper_limit_price(double value);
  private:
  double _internal_upper_limit_price() const;
  void _internal_set_upper_limit_price(double value);
  public:

  // double lower_limit_price = 28;
  void clear_lower_limit_price();
  double lower_limit_price() const;
  void set_lower_limit_price(double value);
  private:
  double _internal_lower_limit_price() const;
  void _internal_set_lower_limit_price(double value);
  public:

  // double open_price = 29;
  void clear_open_price();
  double open_price() const;
  void set_open_price(double value);
  private:
  double _internal_open_price() const;
  void _internal_set_open_price(double value);
  public:

  // double pre_settlement_price = 30;
  void clear_pre_settlement_price();
  double pre_settlement_price() const;
  void set_pre_settlement_price(double value);
  private:
  double _internal_pre_settlement_price() const;
  void _internal_set_pre_settlement_price(double value);
  public:

  // double pre_close_price = 31;
  void clear_pre_close_price();
  double pre_close_price() const;
  void set_pre_close_price(double value);
  private:
  double _internal_pre_close_price() const;
  void _internal_set_pre_close_price(double value);
  public:

  // uint64 pre_open_interest = 32;
  void clear_pre_open_interest();
  uint64_t pre_open_interest() const;
  void set_pre_open_interest(uint64_t value);
  private:
  uint64_t _internal_pre_open_interest() const;
  void _internal_set_pre_open_interest(uint64_t value);
  public:

  // uint64 volume = 33;
  void clear_volume();
  uint64_t volume() const;
  void set_volume(uint64_t value);
  private:
  uint64_t _internal_volume() const;
  void _internal_set_volume(uint64_t value);
  public:

  // uint32 ask_volume5 = 24;
  void clear_ask_volume5();
  uint32_t ask_volume5() const;
  void set_ask_volume5(uint32_t value);
  private:
  uint32_t _internal_ask_volume5() const;
  void _internal_set_ask_volume5(uint32_t value);
  public:

  // @@protoc_insertion_point(class_scope:strategy_market.TickData)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr time_point_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr instrument_id_;
    double last_price_;
    int state_;
    uint32_t bid_volume1_;
    double bid_price1_;
    double ask_price1_;
    double bid_price2_;
    uint32_t ask_volume1_;
    uint32_t bid_volume2_;
    double ask_price2_;
    double bid_price3_;
    uint32_t ask_volume2_;
    uint32_t bid_volume3_;
    double ask_price3_;
    double bid_price4_;
    uint32_t ask_volume3_;
    uint32_t bid_volume4_;
    double ask_price4_;
    double bid_price5_;
    uint32_t ask_volume4_;
    uint32_t bid_volume5_;
    double ask_price5_;
    double turnover_;
    uint64_t open_interest_;
    double upper_limit_price_;
    double lower_limit_price_;
    double open_price_;
    double pre_settlement_price_;
    double pre_close_price_;
    uint64_t pre_open_interest_;
    uint64_t volume_;
    uint32_t ask_volume5_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_strategy_2dmarket_2eproto;
};
// -------------------------------------------------------------------

class MarketStateReq final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:strategy_market.MarketStateReq) */ {
 public:
  inline MarketStateReq() : MarketStateReq(nullptr) {}
  ~MarketStateReq() override;
  explicit PROTOBUF_CONSTEXPR MarketStateReq(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  MarketStateReq(const MarketStateReq& from);
  MarketStateReq(MarketStateReq&& from) noexcept
    : MarketStateReq() {
    *this = ::std::move(from);
  }

  inline MarketStateReq& operator=(const MarketStateReq& from) {
    CopyFrom(from);
    return *this;
  }
  inline MarketStateReq& operator=(MarketStateReq&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const MarketStateReq& default_instance() {
    return *internal_default_instance();
  }
  static inline const MarketStateReq* internal_default_instance() {
    return reinterpret_cast<const MarketStateReq*>(
               &_MarketStateReq_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  friend void swap(MarketStateReq& a, MarketStateReq& b) {
    a.Swap(&b);
  }
  inline void Swap(MarketStateReq* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(MarketStateReq* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  MarketStateReq* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<MarketStateReq>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const MarketStateReq& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const MarketStateReq& from) {
    MarketStateReq::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(MarketStateReq* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "strategy_market.MarketStateReq";
  }
  protected:
  explicit MarketStateReq(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef MarketStateReq_MarketState MarketState;
  static constexpr MarketState reserve =
    MarketStateReq_MarketState_reserve;
  static constexpr MarketState day_open =
    MarketStateReq_MarketState_day_open;
  static constexpr MarketState day_close =
    MarketStateReq_MarketState_day_close;
  static constexpr MarketState night_open =
    MarketStateReq_MarketState_night_open;
  static constexpr MarketState night_close =
    MarketStateReq_MarketState_night_close;
  static inline bool MarketState_IsValid(int value) {
    return MarketStateReq_MarketState_IsValid(value);
  }
  static constexpr MarketState MarketState_MIN =
    MarketStateReq_MarketState_MarketState_MIN;
  static constexpr MarketState MarketState_MAX =
    MarketStateReq_MarketState_MarketState_MAX;
  static constexpr int MarketState_ARRAYSIZE =
    MarketStateReq_MarketState_MarketState_ARRAYSIZE;
  static inline const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
  MarketState_descriptor() {
    return MarketStateReq_MarketState_descriptor();
  }
  template<typename T>
  static inline const std::string& MarketState_Name(T enum_t_value) {
    static_assert(::std::is_same<T, MarketState>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function MarketState_Name.");
    return MarketStateReq_MarketState_Name(enum_t_value);
  }
  static inline bool MarketState_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name,
      MarketState* value) {
    return MarketStateReq_MarketState_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  enum : int {
    kDateFieldNumber = 2,
    kMarketStateFieldNumber = 1,
    kIsLastFieldNumber = 3,
  };
  // string date = 2;
  void clear_date();
  const std::string& date() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_date(ArgT0&& arg0, ArgT... args);
  std::string* mutable_date();
  PROTOBUF_NODISCARD std::string* release_date();
  void set_allocated_date(std::string* date);
  private:
  const std::string& _internal_date() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_date(const std::string& value);
  std::string* _internal_mutable_date();
  public:

  // .strategy_market.MarketStateReq.MarketState market_state = 1;
  void clear_market_state();
  ::strategy_market::MarketStateReq_MarketState market_state() const;
  void set_market_state(::strategy_market::MarketStateReq_MarketState value);
  private:
  ::strategy_market::MarketStateReq_MarketState _internal_market_state() const;
  void _internal_set_market_state(::strategy_market::MarketStateReq_MarketState value);
  public:

  // bool is_last = 3;
  void clear_is_last();
  bool is_last() const;
  void set_is_last(bool value);
  private:
  bool _internal_is_last() const;
  void _internal_set_is_last(bool value);
  public:

  // @@protoc_insertion_point(class_scope:strategy_market.MarketStateReq)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr date_;
    int market_state_;
    bool is_last_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_strategy_2dmarket_2eproto;
};
// -------------------------------------------------------------------

class MarketStateRsp final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:strategy_market.MarketStateRsp) */ {
 public:
  inline MarketStateRsp() : MarketStateRsp(nullptr) {}
  ~MarketStateRsp() override;
  explicit PROTOBUF_CONSTEXPR MarketStateRsp(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  MarketStateRsp(const MarketStateRsp& from);
  MarketStateRsp(MarketStateRsp&& from) noexcept
    : MarketStateRsp() {
    *this = ::std::move(from);
  }

  inline MarketStateRsp& operator=(const MarketStateRsp& from) {
    CopyFrom(from);
    return *this;
  }
  inline MarketStateRsp& operator=(MarketStateRsp&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const MarketStateRsp& default_instance() {
    return *internal_default_instance();
  }
  static inline const MarketStateRsp* internal_default_instance() {
    return reinterpret_cast<const MarketStateRsp*>(
               &_MarketStateRsp_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  friend void swap(MarketStateRsp& a, MarketStateRsp& b) {
    a.Swap(&b);
  }
  inline void Swap(MarketStateRsp* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(MarketStateRsp* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  MarketStateRsp* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<MarketStateRsp>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const MarketStateRsp& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const MarketStateRsp& from) {
    MarketStateRsp::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(MarketStateRsp* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "strategy_market.MarketStateRsp";
  }
  protected:
  explicit MarketStateRsp(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kResultFieldNumber = 1,
  };
  // uint32 result = 1;
  void clear_result();
  uint32_t result() const;
  void set_result(uint32_t value);
  private:
  uint32_t _internal_result() const;
  void _internal_set_result(uint32_t value);
  public:

  // @@protoc_insertion_point(class_scope:strategy_market.MarketStateRsp)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    uint32_t result_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_strategy_2dmarket_2eproto;
};
// -------------------------------------------------------------------

class TickSubscribeRsp final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:strategy_market.TickSubscribeRsp) */ {
 public:
  inline TickSubscribeRsp() : TickSubscribeRsp(nullptr) {}
  ~TickSubscribeRsp() override;
  explicit PROTOBUF_CONSTEXPR TickSubscribeRsp(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  TickSubscribeRsp(const TickSubscribeRsp& from);
  TickSubscribeRsp(TickSubscribeRsp&& from) noexcept
    : TickSubscribeRsp() {
    *this = ::std::move(from);
  }

  inline TickSubscribeRsp& operator=(const TickSubscribeRsp& from) {
    CopyFrom(from);
    return *this;
  }
  inline TickSubscribeRsp& operator=(TickSubscribeRsp&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const TickSubscribeRsp& default_instance() {
    return *internal_default_instance();
  }
  static inline const TickSubscribeRsp* internal_default_instance() {
    return reinterpret_cast<const TickSubscribeRsp*>(
               &_TickSubscribeRsp_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    4;

  friend void swap(TickSubscribeRsp& a, TickSubscribeRsp& b) {
    a.Swap(&b);
  }
  inline void Swap(TickSubscribeRsp* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(TickSubscribeRsp* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  TickSubscribeRsp* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<TickSubscribeRsp>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const TickSubscribeRsp& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const TickSubscribeRsp& from) {
    TickSubscribeRsp::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(TickSubscribeRsp* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "strategy_market.TickSubscribeRsp";
  }
  protected:
  explicit TickSubscribeRsp(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kResultFieldNumber = 1,
  };
  // uint32 result = 1;
  void clear_result();
  uint32_t result() const;
  void set_result(uint32_t value);
  private:
  uint32_t _internal_result() const;
  void _internal_set_result(uint32_t value);
  public:

  // @@protoc_insertion_point(class_scope:strategy_market.TickSubscribeRsp)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    uint32_t result_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_strategy_2dmarket_2eproto;
};
// -------------------------------------------------------------------

class TickSubscribeReq final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:strategy_market.TickSubscribeReq) */ {
 public:
  inline TickSubscribeReq() : TickSubscribeReq(nullptr) {}
  ~TickSubscribeReq() override;
  explicit PROTOBUF_CONSTEXPR TickSubscribeReq(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  TickSubscribeReq(const TickSubscribeReq& from);
  TickSubscribeReq(TickSubscribeReq&& from) noexcept
    : TickSubscribeReq() {
    *this = ::std::move(from);
  }

  inline TickSubscribeReq& operator=(const TickSubscribeReq& from) {
    CopyFrom(from);
    return *this;
  }
  inline TickSubscribeReq& operator=(TickSubscribeReq&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const TickSubscribeReq& default_instance() {
    return *internal_default_instance();
  }
  static inline const TickSubscribeReq* internal_default_instance() {
    return reinterpret_cast<const TickSubscribeReq*>(
               &_TickSubscribeReq_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    5;

  friend void swap(TickSubscribeReq& a, TickSubscribeReq& b) {
    a.Swap(&b);
  }
  inline void Swap(TickSubscribeReq* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(TickSubscribeReq* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  TickSubscribeReq* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<TickSubscribeReq>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const TickSubscribeReq& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const TickSubscribeReq& from) {
    TickSubscribeReq::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(TickSubscribeReq* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "strategy_market.TickSubscribeReq";
  }
  protected:
  explicit TickSubscribeReq(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef TickSubscribeReq_Action Action;
  static constexpr Action sub =
    TickSubscribeReq_Action_sub;
  static constexpr Action unsub =
    TickSubscribeReq_Action_unsub;
  static inline bool Action_IsValid(int value) {
    return TickSubscribeReq_Action_IsValid(value);
  }
  static constexpr Action Action_MIN =
    TickSubscribeReq_Action_Action_MIN;
  static constexpr Action Action_MAX =
    TickSubscribeReq_Action_Action_MAX;
  static constexpr int Action_ARRAYSIZE =
    TickSubscribeReq_Action_Action_ARRAYSIZE;
  static inline const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
  Action_descriptor() {
    return TickSubscribeReq_Action_descriptor();
  }
  template<typename T>
  static inline const std::string& Action_Name(T enum_t_value) {
    static_assert(::std::is_same<T, Action>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function Action_Name.");
    return TickSubscribeReq_Action_Name(enum_t_value);
  }
  static inline bool Action_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name,
      Action* value) {
    return TickSubscribeReq_Action_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  enum : int {
    kInstrumentInfoFieldNumber = 1,
    kActionFieldNumber = 2,
  };
  // .strategy_market.InstrumentInfo instrument_info = 1;
  bool has_instrument_info() const;
  private:
  bool _internal_has_instrument_info() const;
  public:
  void clear_instrument_info();
  const ::strategy_market::InstrumentInfo& instrument_info() const;
  PROTOBUF_NODISCARD ::strategy_market::InstrumentInfo* release_instrument_info();
  ::strategy_market::InstrumentInfo* mutable_instrument_info();
  void set_allocated_instrument_info(::strategy_market::InstrumentInfo* instrument_info);
  private:
  const ::strategy_market::InstrumentInfo& _internal_instrument_info() const;
  ::strategy_market::InstrumentInfo* _internal_mutable_instrument_info();
  public:
  void unsafe_arena_set_allocated_instrument_info(
      ::strategy_market::InstrumentInfo* instrument_info);
  ::strategy_market::InstrumentInfo* unsafe_arena_release_instrument_info();

  // .strategy_market.TickSubscribeReq.Action action = 2;
  void clear_action();
  ::strategy_market::TickSubscribeReq_Action action() const;
  void set_action(::strategy_market::TickSubscribeReq_Action value);
  private:
  ::strategy_market::TickSubscribeReq_Action _internal_action() const;
  void _internal_set_action(::strategy_market::TickSubscribeReq_Action value);
  public:

  // @@protoc_insertion_point(class_scope:strategy_market.TickSubscribeReq)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::strategy_market::InstrumentInfo* instrument_info_;
    int action_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_strategy_2dmarket_2eproto;
};
// -------------------------------------------------------------------

class InstrumentInfo final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:strategy_market.InstrumentInfo) */ {
 public:
  inline InstrumentInfo() : InstrumentInfo(nullptr) {}
  ~InstrumentInfo() override;
  explicit PROTOBUF_CONSTEXPR InstrumentInfo(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  InstrumentInfo(const InstrumentInfo& from);
  InstrumentInfo(InstrumentInfo&& from) noexcept
    : InstrumentInfo() {
    *this = ::std::move(from);
  }

  inline InstrumentInfo& operator=(const InstrumentInfo& from) {
    CopyFrom(from);
    return *this;
  }
  inline InstrumentInfo& operator=(InstrumentInfo&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const InstrumentInfo& default_instance() {
    return *internal_default_instance();
  }
  static inline const InstrumentInfo* internal_default_instance() {
    return reinterpret_cast<const InstrumentInfo*>(
               &_InstrumentInfo_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    6;

  friend void swap(InstrumentInfo& a, InstrumentInfo& b) {
    a.Swap(&b);
  }
  inline void Swap(InstrumentInfo* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(InstrumentInfo* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  InstrumentInfo* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<InstrumentInfo>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const InstrumentInfo& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const InstrumentInfo& from) {
    InstrumentInfo::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(InstrumentInfo* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "strategy_market.InstrumentInfo";
  }
  protected:
  explicit InstrumentInfo(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kInstrumentIdFieldNumber = 1,
    kExchangeIdFieldNumber = 2,
  };
  // string instrument_id = 1;
  void clear_instrument_id();
  const std::string& instrument_id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_instrument_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_instrument_id();
  PROTOBUF_NODISCARD std::string* release_instrument_id();
  void set_allocated_instrument_id(std::string* instrument_id);
  private:
  const std::string& _internal_instrument_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_instrument_id(const std::string& value);
  std::string* _internal_mutable_instrument_id();
  public:

  // string exchange_id = 2;
  void clear_exchange_id();
  const std::string& exchange_id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_exchange_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_exchange_id();
  PROTOBUF_NODISCARD std::string* release_exchange_id();
  void set_allocated_exchange_id(std::string* exchange_id);
  private:
  const std::string& _internal_exchange_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_exchange_id(const std::string& value);
  std::string* _internal_mutable_exchange_id();
  public:

  // @@protoc_insertion_point(class_scope:strategy_market.InstrumentInfo)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr instrument_id_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr exchange_id_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_strategy_2dmarket_2eproto;
};
// -------------------------------------------------------------------

class ActiveSafetyReq final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:strategy_market.ActiveSafetyReq) */ {
 public:
  inline ActiveSafetyReq() : ActiveSafetyReq(nullptr) {}
  ~ActiveSafetyReq() override;
  explicit PROTOBUF_CONSTEXPR ActiveSafetyReq(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ActiveSafetyReq(const ActiveSafetyReq& from);
  ActiveSafetyReq(ActiveSafetyReq&& from) noexcept
    : ActiveSafetyReq() {
    *this = ::std::move(from);
  }

  inline ActiveSafetyReq& operator=(const ActiveSafetyReq& from) {
    CopyFrom(from);
    return *this;
  }
  inline ActiveSafetyReq& operator=(ActiveSafetyReq&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ActiveSafetyReq& default_instance() {
    return *internal_default_instance();
  }
  static inline const ActiveSafetyReq* internal_default_instance() {
    return reinterpret_cast<const ActiveSafetyReq*>(
               &_ActiveSafetyReq_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    7;

  friend void swap(ActiveSafetyReq& a, ActiveSafetyReq& b) {
    a.Swap(&b);
  }
  inline void Swap(ActiveSafetyReq* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ActiveSafetyReq* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ActiveSafetyReq* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ActiveSafetyReq>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ActiveSafetyReq& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const ActiveSafetyReq& from) {
    ActiveSafetyReq::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ActiveSafetyReq* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "strategy_market.ActiveSafetyReq";
  }
  protected:
  explicit ActiveSafetyReq(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef ActiveSafetyReq_MessageType MessageType;
  static constexpr MessageType reserve =
    ActiveSafetyReq_MessageType_reserve;
  static constexpr MessageType isrun =
    ActiveSafetyReq_MessageType_isrun;
  static inline bool MessageType_IsValid(int value) {
    return ActiveSafetyReq_MessageType_IsValid(value);
  }
  static constexpr MessageType MessageType_MIN =
    ActiveSafetyReq_MessageType_MessageType_MIN;
  static constexpr MessageType MessageType_MAX =
    ActiveSafetyReq_MessageType_MessageType_MAX;
  static constexpr int MessageType_ARRAYSIZE =
    ActiveSafetyReq_MessageType_MessageType_ARRAYSIZE;
  static inline const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
  MessageType_descriptor() {
    return ActiveSafetyReq_MessageType_descriptor();
  }
  template<typename T>
  static inline const std::string& MessageType_Name(T enum_t_value) {
    static_assert(::std::is_same<T, MessageType>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function MessageType_Name.");
    return ActiveSafetyReq_MessageType_Name(enum_t_value);
  }
  static inline bool MessageType_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name,
      MessageType* value) {
    return ActiveSafetyReq_MessageType_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  enum : int {
    kSafeIdFieldNumber = 1,
  };
  // .strategy_market.ActiveSafetyReq.MessageType safe_id = 1;
  void clear_safe_id();
  ::strategy_market::ActiveSafetyReq_MessageType safe_id() const;
  void set_safe_id(::strategy_market::ActiveSafetyReq_MessageType value);
  private:
  ::strategy_market::ActiveSafetyReq_MessageType _internal_safe_id() const;
  void _internal_set_safe_id(::strategy_market::ActiveSafetyReq_MessageType value);
  public:

  // @@protoc_insertion_point(class_scope:strategy_market.ActiveSafetyReq)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    int safe_id_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_strategy_2dmarket_2eproto;
};
// -------------------------------------------------------------------

class ActiveSafetyRsp final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:strategy_market.ActiveSafetyRsp) */ {
 public:
  inline ActiveSafetyRsp() : ActiveSafetyRsp(nullptr) {}
  ~ActiveSafetyRsp() override;
  explicit PROTOBUF_CONSTEXPR ActiveSafetyRsp(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ActiveSafetyRsp(const ActiveSafetyRsp& from);
  ActiveSafetyRsp(ActiveSafetyRsp&& from) noexcept
    : ActiveSafetyRsp() {
    *this = ::std::move(from);
  }

  inline ActiveSafetyRsp& operator=(const ActiveSafetyRsp& from) {
    CopyFrom(from);
    return *this;
  }
  inline ActiveSafetyRsp& operator=(ActiveSafetyRsp&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ActiveSafetyRsp& default_instance() {
    return *internal_default_instance();
  }
  static inline const ActiveSafetyRsp* internal_default_instance() {
    return reinterpret_cast<const ActiveSafetyRsp*>(
               &_ActiveSafetyRsp_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    8;

  friend void swap(ActiveSafetyRsp& a, ActiveSafetyRsp& b) {
    a.Swap(&b);
  }
  inline void Swap(ActiveSafetyRsp* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ActiveSafetyRsp* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ActiveSafetyRsp* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ActiveSafetyRsp>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ActiveSafetyRsp& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const ActiveSafetyRsp& from) {
    ActiveSafetyRsp::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ActiveSafetyRsp* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "strategy_market.ActiveSafetyRsp";
  }
  protected:
  explicit ActiveSafetyRsp(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kStatusFieldNumber = 1,
  };
  // bool status = 1;
  void clear_status();
  bool status() const;
  void set_status(bool value);
  private:
  bool _internal_status() const;
  void _internal_set_status(bool value);
  public:

  // @@protoc_insertion_point(class_scope:strategy_market.ActiveSafetyRsp)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    bool status_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_strategy_2dmarket_2eproto;
};
// -------------------------------------------------------------------

class InstrumentReq final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:strategy_market.InstrumentReq) */ {
 public:
  inline InstrumentReq() : InstrumentReq(nullptr) {}
  ~InstrumentReq() override;
  explicit PROTOBUF_CONSTEXPR InstrumentReq(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  InstrumentReq(const InstrumentReq& from);
  InstrumentReq(InstrumentReq&& from) noexcept
    : InstrumentReq() {
    *this = ::std::move(from);
  }

  inline InstrumentReq& operator=(const InstrumentReq& from) {
    CopyFrom(from);
    return *this;
  }
  inline InstrumentReq& operator=(InstrumentReq&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const InstrumentReq& default_instance() {
    return *internal_default_instance();
  }
  static inline const InstrumentReq* internal_default_instance() {
    return reinterpret_cast<const InstrumentReq*>(
               &_InstrumentReq_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    9;

  friend void swap(InstrumentReq& a, InstrumentReq& b) {
    a.Swap(&b);
  }
  inline void Swap(InstrumentReq* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(InstrumentReq* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  InstrumentReq* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<InstrumentReq>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const InstrumentReq& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const InstrumentReq& from) {
    InstrumentReq::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(InstrumentReq* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "strategy_market.InstrumentReq";
  }
  protected:
  explicit InstrumentReq(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kInstrumentInfoFieldNumber = 1,
  };
  // .strategy_market.InstrumentInfo instrument_info = 1;
  bool has_instrument_info() const;
  private:
  bool _internal_has_instrument_info() const;
  public:
  void clear_instrument_info();
  const ::strategy_market::InstrumentInfo& instrument_info() const;
  PROTOBUF_NODISCARD ::strategy_market::InstrumentInfo* release_instrument_info();
  ::strategy_market::InstrumentInfo* mutable_instrument_info();
  void set_allocated_instrument_info(::strategy_market::InstrumentInfo* instrument_info);
  private:
  const ::strategy_market::InstrumentInfo& _internal_instrument_info() const;
  ::strategy_market::InstrumentInfo* _internal_mutable_instrument_info();
  public:
  void unsafe_arena_set_allocated_instrument_info(
      ::strategy_market::InstrumentInfo* instrument_info);
  ::strategy_market::InstrumentInfo* unsafe_arena_release_instrument_info();

  // @@protoc_insertion_point(class_scope:strategy_market.InstrumentReq)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::strategy_market::InstrumentInfo* instrument_info_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_strategy_2dmarket_2eproto;
};
// -------------------------------------------------------------------

class InstrumentRsp final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:strategy_market.InstrumentRsp) */ {
 public:
  inline InstrumentRsp() : InstrumentRsp(nullptr) {}
  ~InstrumentRsp() override;
  explicit PROTOBUF_CONSTEXPR InstrumentRsp(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  InstrumentRsp(const InstrumentRsp& from);
  InstrumentRsp(InstrumentRsp&& from) noexcept
    : InstrumentRsp() {
    *this = ::std::move(from);
  }

  inline InstrumentRsp& operator=(const InstrumentRsp& from) {
    CopyFrom(from);
    return *this;
  }
  inline InstrumentRsp& operator=(InstrumentRsp&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const InstrumentRsp& default_instance() {
    return *internal_default_instance();
  }
  static inline const InstrumentRsp* internal_default_instance() {
    return reinterpret_cast<const InstrumentRsp*>(
               &_InstrumentRsp_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    10;

  friend void swap(InstrumentRsp& a, InstrumentRsp& b) {
    a.Swap(&b);
  }
  inline void Swap(InstrumentRsp* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(InstrumentRsp* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  InstrumentRsp* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<InstrumentRsp>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const InstrumentRsp& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const InstrumentRsp& from) {
    InstrumentRsp::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(InstrumentRsp* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "strategy_market.InstrumentRsp";
  }
  protected:
  explicit InstrumentRsp(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kInstrumentIdFieldNumber = 1,
    kExchangeIdFieldNumber = 2,
    kFailedReasonFieldNumber = 11,
    kPriceTickFieldNumber = 3,
    kMaxMarketOrderVolumeFieldNumber = 4,
    kMinMarketOrderVolumeFieldNumber = 5,
    kMaxLimitOrderVolumeFieldNumber = 6,
    kMinLimitOrderVolumeFieldNumber = 7,
    kVolumeMultipleFieldNumber = 8,
    kIsTradingFieldNumber = 9,
    kResultFieldNumber = 10,
  };
  // string instrument_id = 1;
  void clear_instrument_id();
  const std::string& instrument_id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_instrument_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_instrument_id();
  PROTOBUF_NODISCARD std::string* release_instrument_id();
  void set_allocated_instrument_id(std::string* instrument_id);
  private:
  const std::string& _internal_instrument_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_instrument_id(const std::string& value);
  std::string* _internal_mutable_instrument_id();
  public:

  // string exchange_id = 2;
  void clear_exchange_id();
  const std::string& exchange_id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_exchange_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_exchange_id();
  PROTOBUF_NODISCARD std::string* release_exchange_id();
  void set_allocated_exchange_id(std::string* exchange_id);
  private:
  const std::string& _internal_exchange_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_exchange_id(const std::string& value);
  std::string* _internal_mutable_exchange_id();
  public:

  // string failedReason = 11;
  void clear_failedreason();
  const std::string& failedreason() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_failedreason(ArgT0&& arg0, ArgT... args);
  std::string* mutable_failedreason();
  PROTOBUF_NODISCARD std::string* release_failedreason();
  void set_allocated_failedreason(std::string* failedreason);
  private:
  const std::string& _internal_failedreason() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_failedreason(const std::string& value);
  std::string* _internal_mutable_failedreason();
  public:

  // double price_tick = 3;
  void clear_price_tick();
  double price_tick() const;
  void set_price_tick(double value);
  private:
  double _internal_price_tick() const;
  void _internal_set_price_tick(double value);
  public:

  // int32 max_market_order_volume = 4;
  void clear_max_market_order_volume();
  int32_t max_market_order_volume() const;
  void set_max_market_order_volume(int32_t value);
  private:
  int32_t _internal_max_market_order_volume() const;
  void _internal_set_max_market_order_volume(int32_t value);
  public:

  // int32 min_market_order_volume = 5;
  void clear_min_market_order_volume();
  int32_t min_market_order_volume() const;
  void set_min_market_order_volume(int32_t value);
  private:
  int32_t _internal_min_market_order_volume() const;
  void _internal_set_min_market_order_volume(int32_t value);
  public:

  // int32 max_limit_order_volume = 6;
  void clear_max_limit_order_volume();
  int32_t max_limit_order_volume() const;
  void set_max_limit_order_volume(int32_t value);
  private:
  int32_t _internal_max_limit_order_volume() const;
  void _internal_set_max_limit_order_volume(int32_t value);
  public:

  // int32 min_limit_order_volume = 7;
  void clear_min_limit_order_volume();
  int32_t min_limit_order_volume() const;
  void set_min_limit_order_volume(int32_t value);
  private:
  int32_t _internal_min_limit_order_volume() const;
  void _internal_set_min_limit_order_volume(int32_t value);
  public:

  // double volume_multiple = 8;
  void clear_volume_multiple();
  double volume_multiple() const;
  void set_volume_multiple(double value);
  private:
  double _internal_volume_multiple() const;
  void _internal_set_volume_multiple(double value);
  public:

  // int32 is_trading = 9;
  void clear_is_trading();
  int32_t is_trading() const;
  void set_is_trading(int32_t value);
  private:
  int32_t _internal_is_trading() const;
  void _internal_set_is_trading(int32_t value);
  public:

  // .strategy_market.Result result = 10;
  void clear_result();
  ::strategy_market::Result result() const;
  void set_result(::strategy_market::Result value);
  private:
  ::strategy_market::Result _internal_result() const;
  void _internal_set_result(::strategy_market::Result value);
  public:

  // @@protoc_insertion_point(class_scope:strategy_market.InstrumentRsp)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr instrument_id_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr exchange_id_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr failedreason_;
    double price_tick_;
    int32_t max_market_order_volume_;
    int32_t min_market_order_volume_;
    int32_t max_limit_order_volume_;
    int32_t min_limit_order_volume_;
    double volume_multiple_;
    int32_t is_trading_;
    int result_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_strategy_2dmarket_2eproto;
};
// -------------------------------------------------------------------

class CheckStrategyAliveReq final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:strategy_market.CheckStrategyAliveReq) */ {
 public:
  inline CheckStrategyAliveReq() : CheckStrategyAliveReq(nullptr) {}
  ~CheckStrategyAliveReq() override;
  explicit PROTOBUF_CONSTEXPR CheckStrategyAliveReq(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  CheckStrategyAliveReq(const CheckStrategyAliveReq& from);
  CheckStrategyAliveReq(CheckStrategyAliveReq&& from) noexcept
    : CheckStrategyAliveReq() {
    *this = ::std::move(from);
  }

  inline CheckStrategyAliveReq& operator=(const CheckStrategyAliveReq& from) {
    CopyFrom(from);
    return *this;
  }
  inline CheckStrategyAliveReq& operator=(CheckStrategyAliveReq&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CheckStrategyAliveReq& default_instance() {
    return *internal_default_instance();
  }
  static inline const CheckStrategyAliveReq* internal_default_instance() {
    return reinterpret_cast<const CheckStrategyAliveReq*>(
               &_CheckStrategyAliveReq_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    11;

  friend void swap(CheckStrategyAliveReq& a, CheckStrategyAliveReq& b) {
    a.Swap(&b);
  }
  inline void Swap(CheckStrategyAliveReq* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CheckStrategyAliveReq* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  CheckStrategyAliveReq* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<CheckStrategyAliveReq>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const CheckStrategyAliveReq& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const CheckStrategyAliveReq& from) {
    CheckStrategyAliveReq::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CheckStrategyAliveReq* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "strategy_market.CheckStrategyAliveReq";
  }
  protected:
  explicit CheckStrategyAliveReq(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kAliveReqFieldNumber = 1,
  };
  // bool alive_req = 1;
  void clear_alive_req();
  bool alive_req() const;
  void set_alive_req(bool value);
  private:
  bool _internal_alive_req() const;
  void _internal_set_alive_req(bool value);
  public:

  // @@protoc_insertion_point(class_scope:strategy_market.CheckStrategyAliveReq)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    bool alive_req_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_strategy_2dmarket_2eproto;
};
// -------------------------------------------------------------------

class CheckStrategyAliveRsp final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:strategy_market.CheckStrategyAliveRsp) */ {
 public:
  inline CheckStrategyAliveRsp() : CheckStrategyAliveRsp(nullptr) {}
  ~CheckStrategyAliveRsp() override;
  explicit PROTOBUF_CONSTEXPR CheckStrategyAliveRsp(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  CheckStrategyAliveRsp(const CheckStrategyAliveRsp& from);
  CheckStrategyAliveRsp(CheckStrategyAliveRsp&& from) noexcept
    : CheckStrategyAliveRsp() {
    *this = ::std::move(from);
  }

  inline CheckStrategyAliveRsp& operator=(const CheckStrategyAliveRsp& from) {
    CopyFrom(from);
    return *this;
  }
  inline CheckStrategyAliveRsp& operator=(CheckStrategyAliveRsp&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CheckStrategyAliveRsp& default_instance() {
    return *internal_default_instance();
  }
  static inline const CheckStrategyAliveRsp* internal_default_instance() {
    return reinterpret_cast<const CheckStrategyAliveRsp*>(
               &_CheckStrategyAliveRsp_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    12;

  friend void swap(CheckStrategyAliveRsp& a, CheckStrategyAliveRsp& b) {
    a.Swap(&b);
  }
  inline void Swap(CheckStrategyAliveRsp* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CheckStrategyAliveRsp* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  CheckStrategyAliveRsp* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<CheckStrategyAliveRsp>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const CheckStrategyAliveRsp& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const CheckStrategyAliveRsp& from) {
    CheckStrategyAliveRsp::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CheckStrategyAliveRsp* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "strategy_market.CheckStrategyAliveRsp";
  }
  protected:
  explicit CheckStrategyAliveRsp(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kAliveRspFieldNumber = 1,
  };
  // bool alive_rsp = 1;
  void clear_alive_rsp();
  bool alive_rsp() const;
  void set_alive_rsp(bool value);
  private:
  bool _internal_alive_rsp() const;
  void _internal_set_alive_rsp(bool value);
  public:

  // @@protoc_insertion_point(class_scope:strategy_market.CheckStrategyAliveRsp)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    bool alive_rsp_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_strategy_2dmarket_2eproto;
};
// -------------------------------------------------------------------

class CheckMarketAliveReq final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:strategy_market.CheckMarketAliveReq) */ {
 public:
  inline CheckMarketAliveReq() : CheckMarketAliveReq(nullptr) {}
  ~CheckMarketAliveReq() override;
  explicit PROTOBUF_CONSTEXPR CheckMarketAliveReq(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  CheckMarketAliveReq(const CheckMarketAliveReq& from);
  CheckMarketAliveReq(CheckMarketAliveReq&& from) noexcept
    : CheckMarketAliveReq() {
    *this = ::std::move(from);
  }

  inline CheckMarketAliveReq& operator=(const CheckMarketAliveReq& from) {
    CopyFrom(from);
    return *this;
  }
  inline CheckMarketAliveReq& operator=(CheckMarketAliveReq&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CheckMarketAliveReq& default_instance() {
    return *internal_default_instance();
  }
  static inline const CheckMarketAliveReq* internal_default_instance() {
    return reinterpret_cast<const CheckMarketAliveReq*>(
               &_CheckMarketAliveReq_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    13;

  friend void swap(CheckMarketAliveReq& a, CheckMarketAliveReq& b) {
    a.Swap(&b);
  }
  inline void Swap(CheckMarketAliveReq* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CheckMarketAliveReq* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  CheckMarketAliveReq* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<CheckMarketAliveReq>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const CheckMarketAliveReq& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const CheckMarketAliveReq& from) {
    CheckMarketAliveReq::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CheckMarketAliveReq* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "strategy_market.CheckMarketAliveReq";
  }
  protected:
  explicit CheckMarketAliveReq(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kAliveReqFieldNumber = 1,
  };
  // bool alive_req = 1;
  void clear_alive_req();
  bool alive_req() const;
  void set_alive_req(bool value);
  private:
  bool _internal_alive_req() const;
  void _internal_set_alive_req(bool value);
  public:

  // @@protoc_insertion_point(class_scope:strategy_market.CheckMarketAliveReq)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    bool alive_req_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_strategy_2dmarket_2eproto;
};
// -------------------------------------------------------------------

class CheckMarketAliveRsp final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:strategy_market.CheckMarketAliveRsp) */ {
 public:
  inline CheckMarketAliveRsp() : CheckMarketAliveRsp(nullptr) {}
  ~CheckMarketAliveRsp() override;
  explicit PROTOBUF_CONSTEXPR CheckMarketAliveRsp(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  CheckMarketAliveRsp(const CheckMarketAliveRsp& from);
  CheckMarketAliveRsp(CheckMarketAliveRsp&& from) noexcept
    : CheckMarketAliveRsp() {
    *this = ::std::move(from);
  }

  inline CheckMarketAliveRsp& operator=(const CheckMarketAliveRsp& from) {
    CopyFrom(from);
    return *this;
  }
  inline CheckMarketAliveRsp& operator=(CheckMarketAliveRsp&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CheckMarketAliveRsp& default_instance() {
    return *internal_default_instance();
  }
  static inline const CheckMarketAliveRsp* internal_default_instance() {
    return reinterpret_cast<const CheckMarketAliveRsp*>(
               &_CheckMarketAliveRsp_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    14;

  friend void swap(CheckMarketAliveRsp& a, CheckMarketAliveRsp& b) {
    a.Swap(&b);
  }
  inline void Swap(CheckMarketAliveRsp* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CheckMarketAliveRsp* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  CheckMarketAliveRsp* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<CheckMarketAliveRsp>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const CheckMarketAliveRsp& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const CheckMarketAliveRsp& from) {
    CheckMarketAliveRsp::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CheckMarketAliveRsp* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "strategy_market.CheckMarketAliveRsp";
  }
  protected:
  explicit CheckMarketAliveRsp(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kAliveRspFieldNumber = 1,
  };
  // bool alive_rsp = 1;
  void clear_alive_rsp();
  bool alive_rsp() const;
  void set_alive_rsp(bool value);
  private:
  bool _internal_alive_rsp() const;
  void _internal_set_alive_rsp(bool value);
  public:

  // @@protoc_insertion_point(class_scope:strategy_market.CheckMarketAliveRsp)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    bool alive_rsp_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_strategy_2dmarket_2eproto;
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// message

// .strategy_market.TickSubscribeReq tick_sub_req = 1;
inline bool message::_internal_has_tick_sub_req() const {
  return MessageType_case() == kTickSubReq;
}
inline bool message::has_tick_sub_req() const {
  return _internal_has_tick_sub_req();
}
inline void message::set_has_tick_sub_req() {
  _impl_._oneof_case_[0] = kTickSubReq;
}
inline void message::clear_tick_sub_req() {
  if (_internal_has_tick_sub_req()) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.MessageType_.tick_sub_req_;
    }
    clear_has_MessageType();
  }
}
inline ::strategy_market::TickSubscribeReq* message::release_tick_sub_req() {
  // @@protoc_insertion_point(field_release:strategy_market.message.tick_sub_req)
  if (_internal_has_tick_sub_req()) {
    clear_has_MessageType();
    ::strategy_market::TickSubscribeReq* temp = _impl_.MessageType_.tick_sub_req_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.MessageType_.tick_sub_req_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::strategy_market::TickSubscribeReq& message::_internal_tick_sub_req() const {
  return _internal_has_tick_sub_req()
      ? *_impl_.MessageType_.tick_sub_req_
      : reinterpret_cast< ::strategy_market::TickSubscribeReq&>(::strategy_market::_TickSubscribeReq_default_instance_);
}
inline const ::strategy_market::TickSubscribeReq& message::tick_sub_req() const {
  // @@protoc_insertion_point(field_get:strategy_market.message.tick_sub_req)
  return _internal_tick_sub_req();
}
inline ::strategy_market::TickSubscribeReq* message::unsafe_arena_release_tick_sub_req() {
  // @@protoc_insertion_point(field_unsafe_arena_release:strategy_market.message.tick_sub_req)
  if (_internal_has_tick_sub_req()) {
    clear_has_MessageType();
    ::strategy_market::TickSubscribeReq* temp = _impl_.MessageType_.tick_sub_req_;
    _impl_.MessageType_.tick_sub_req_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void message::unsafe_arena_set_allocated_tick_sub_req(::strategy_market::TickSubscribeReq* tick_sub_req) {
  clear_MessageType();
  if (tick_sub_req) {
    set_has_tick_sub_req();
    _impl_.MessageType_.tick_sub_req_ = tick_sub_req;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:strategy_market.message.tick_sub_req)
}
inline ::strategy_market::TickSubscribeReq* message::_internal_mutable_tick_sub_req() {
  if (!_internal_has_tick_sub_req()) {
    clear_MessageType();
    set_has_tick_sub_req();
    _impl_.MessageType_.tick_sub_req_ = CreateMaybeMessage< ::strategy_market::TickSubscribeReq >(GetArenaForAllocation());
  }
  return _impl_.MessageType_.tick_sub_req_;
}
inline ::strategy_market::TickSubscribeReq* message::mutable_tick_sub_req() {
  ::strategy_market::TickSubscribeReq* _msg = _internal_mutable_tick_sub_req();
  // @@protoc_insertion_point(field_mutable:strategy_market.message.tick_sub_req)
  return _msg;
}

// .strategy_market.TickSubscribeRsp tick_sub_rsp = 2;
inline bool message::_internal_has_tick_sub_rsp() const {
  return MessageType_case() == kTickSubRsp;
}
inline bool message::has_tick_sub_rsp() const {
  return _internal_has_tick_sub_rsp();
}
inline void message::set_has_tick_sub_rsp() {
  _impl_._oneof_case_[0] = kTickSubRsp;
}
inline void message::clear_tick_sub_rsp() {
  if (_internal_has_tick_sub_rsp()) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.MessageType_.tick_sub_rsp_;
    }
    clear_has_MessageType();
  }
}
inline ::strategy_market::TickSubscribeRsp* message::release_tick_sub_rsp() {
  // @@protoc_insertion_point(field_release:strategy_market.message.tick_sub_rsp)
  if (_internal_has_tick_sub_rsp()) {
    clear_has_MessageType();
    ::strategy_market::TickSubscribeRsp* temp = _impl_.MessageType_.tick_sub_rsp_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.MessageType_.tick_sub_rsp_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::strategy_market::TickSubscribeRsp& message::_internal_tick_sub_rsp() const {
  return _internal_has_tick_sub_rsp()
      ? *_impl_.MessageType_.tick_sub_rsp_
      : reinterpret_cast< ::strategy_market::TickSubscribeRsp&>(::strategy_market::_TickSubscribeRsp_default_instance_);
}
inline const ::strategy_market::TickSubscribeRsp& message::tick_sub_rsp() const {
  // @@protoc_insertion_point(field_get:strategy_market.message.tick_sub_rsp)
  return _internal_tick_sub_rsp();
}
inline ::strategy_market::TickSubscribeRsp* message::unsafe_arena_release_tick_sub_rsp() {
  // @@protoc_insertion_point(field_unsafe_arena_release:strategy_market.message.tick_sub_rsp)
  if (_internal_has_tick_sub_rsp()) {
    clear_has_MessageType();
    ::strategy_market::TickSubscribeRsp* temp = _impl_.MessageType_.tick_sub_rsp_;
    _impl_.MessageType_.tick_sub_rsp_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void message::unsafe_arena_set_allocated_tick_sub_rsp(::strategy_market::TickSubscribeRsp* tick_sub_rsp) {
  clear_MessageType();
  if (tick_sub_rsp) {
    set_has_tick_sub_rsp();
    _impl_.MessageType_.tick_sub_rsp_ = tick_sub_rsp;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:strategy_market.message.tick_sub_rsp)
}
inline ::strategy_market::TickSubscribeRsp* message::_internal_mutable_tick_sub_rsp() {
  if (!_internal_has_tick_sub_rsp()) {
    clear_MessageType();
    set_has_tick_sub_rsp();
    _impl_.MessageType_.tick_sub_rsp_ = CreateMaybeMessage< ::strategy_market::TickSubscribeRsp >(GetArenaForAllocation());
  }
  return _impl_.MessageType_.tick_sub_rsp_;
}
inline ::strategy_market::TickSubscribeRsp* message::mutable_tick_sub_rsp() {
  ::strategy_market::TickSubscribeRsp* _msg = _internal_mutable_tick_sub_rsp();
  // @@protoc_insertion_point(field_mutable:strategy_market.message.tick_sub_rsp)
  return _msg;
}

// .strategy_market.TickData tick_data = 3;
inline bool message::_internal_has_tick_data() const {
  return MessageType_case() == kTickData;
}
inline bool message::has_tick_data() const {
  return _internal_has_tick_data();
}
inline void message::set_has_tick_data() {
  _impl_._oneof_case_[0] = kTickData;
}
inline void message::clear_tick_data() {
  if (_internal_has_tick_data()) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.MessageType_.tick_data_;
    }
    clear_has_MessageType();
  }
}
inline ::strategy_market::TickData* message::release_tick_data() {
  // @@protoc_insertion_point(field_release:strategy_market.message.tick_data)
  if (_internal_has_tick_data()) {
    clear_has_MessageType();
    ::strategy_market::TickData* temp = _impl_.MessageType_.tick_data_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.MessageType_.tick_data_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::strategy_market::TickData& message::_internal_tick_data() const {
  return _internal_has_tick_data()
      ? *_impl_.MessageType_.tick_data_
      : reinterpret_cast< ::strategy_market::TickData&>(::strategy_market::_TickData_default_instance_);
}
inline const ::strategy_market::TickData& message::tick_data() const {
  // @@protoc_insertion_point(field_get:strategy_market.message.tick_data)
  return _internal_tick_data();
}
inline ::strategy_market::TickData* message::unsafe_arena_release_tick_data() {
  // @@protoc_insertion_point(field_unsafe_arena_release:strategy_market.message.tick_data)
  if (_internal_has_tick_data()) {
    clear_has_MessageType();
    ::strategy_market::TickData* temp = _impl_.MessageType_.tick_data_;
    _impl_.MessageType_.tick_data_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void message::unsafe_arena_set_allocated_tick_data(::strategy_market::TickData* tick_data) {
  clear_MessageType();
  if (tick_data) {
    set_has_tick_data();
    _impl_.MessageType_.tick_data_ = tick_data;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:strategy_market.message.tick_data)
}
inline ::strategy_market::TickData* message::_internal_mutable_tick_data() {
  if (!_internal_has_tick_data()) {
    clear_MessageType();
    set_has_tick_data();
    _impl_.MessageType_.tick_data_ = CreateMaybeMessage< ::strategy_market::TickData >(GetArenaForAllocation());
  }
  return _impl_.MessageType_.tick_data_;
}
inline ::strategy_market::TickData* message::mutable_tick_data() {
  ::strategy_market::TickData* _msg = _internal_mutable_tick_data();
  // @@protoc_insertion_point(field_mutable:strategy_market.message.tick_data)
  return _msg;
}

// .strategy_market.MarketStateReq market_state_req = 4;
inline bool message::_internal_has_market_state_req() const {
  return MessageType_case() == kMarketStateReq;
}
inline bool message::has_market_state_req() const {
  return _internal_has_market_state_req();
}
inline void message::set_has_market_state_req() {
  _impl_._oneof_case_[0] = kMarketStateReq;
}
inline void message::clear_market_state_req() {
  if (_internal_has_market_state_req()) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.MessageType_.market_state_req_;
    }
    clear_has_MessageType();
  }
}
inline ::strategy_market::MarketStateReq* message::release_market_state_req() {
  // @@protoc_insertion_point(field_release:strategy_market.message.market_state_req)
  if (_internal_has_market_state_req()) {
    clear_has_MessageType();
    ::strategy_market::MarketStateReq* temp = _impl_.MessageType_.market_state_req_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.MessageType_.market_state_req_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::strategy_market::MarketStateReq& message::_internal_market_state_req() const {
  return _internal_has_market_state_req()
      ? *_impl_.MessageType_.market_state_req_
      : reinterpret_cast< ::strategy_market::MarketStateReq&>(::strategy_market::_MarketStateReq_default_instance_);
}
inline const ::strategy_market::MarketStateReq& message::market_state_req() const {
  // @@protoc_insertion_point(field_get:strategy_market.message.market_state_req)
  return _internal_market_state_req();
}
inline ::strategy_market::MarketStateReq* message::unsafe_arena_release_market_state_req() {
  // @@protoc_insertion_point(field_unsafe_arena_release:strategy_market.message.market_state_req)
  if (_internal_has_market_state_req()) {
    clear_has_MessageType();
    ::strategy_market::MarketStateReq* temp = _impl_.MessageType_.market_state_req_;
    _impl_.MessageType_.market_state_req_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void message::unsafe_arena_set_allocated_market_state_req(::strategy_market::MarketStateReq* market_state_req) {
  clear_MessageType();
  if (market_state_req) {
    set_has_market_state_req();
    _impl_.MessageType_.market_state_req_ = market_state_req;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:strategy_market.message.market_state_req)
}
inline ::strategy_market::MarketStateReq* message::_internal_mutable_market_state_req() {
  if (!_internal_has_market_state_req()) {
    clear_MessageType();
    set_has_market_state_req();
    _impl_.MessageType_.market_state_req_ = CreateMaybeMessage< ::strategy_market::MarketStateReq >(GetArenaForAllocation());
  }
  return _impl_.MessageType_.market_state_req_;
}
inline ::strategy_market::MarketStateReq* message::mutable_market_state_req() {
  ::strategy_market::MarketStateReq* _msg = _internal_mutable_market_state_req();
  // @@protoc_insertion_point(field_mutable:strategy_market.message.market_state_req)
  return _msg;
}

// .strategy_market.MarketStateRsp market_state_rsp = 5;
inline bool message::_internal_has_market_state_rsp() const {
  return MessageType_case() == kMarketStateRsp;
}
inline bool message::has_market_state_rsp() const {
  return _internal_has_market_state_rsp();
}
inline void message::set_has_market_state_rsp() {
  _impl_._oneof_case_[0] = kMarketStateRsp;
}
inline void message::clear_market_state_rsp() {
  if (_internal_has_market_state_rsp()) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.MessageType_.market_state_rsp_;
    }
    clear_has_MessageType();
  }
}
inline ::strategy_market::MarketStateRsp* message::release_market_state_rsp() {
  // @@protoc_insertion_point(field_release:strategy_market.message.market_state_rsp)
  if (_internal_has_market_state_rsp()) {
    clear_has_MessageType();
    ::strategy_market::MarketStateRsp* temp = _impl_.MessageType_.market_state_rsp_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.MessageType_.market_state_rsp_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::strategy_market::MarketStateRsp& message::_internal_market_state_rsp() const {
  return _internal_has_market_state_rsp()
      ? *_impl_.MessageType_.market_state_rsp_
      : reinterpret_cast< ::strategy_market::MarketStateRsp&>(::strategy_market::_MarketStateRsp_default_instance_);
}
inline const ::strategy_market::MarketStateRsp& message::market_state_rsp() const {
  // @@protoc_insertion_point(field_get:strategy_market.message.market_state_rsp)
  return _internal_market_state_rsp();
}
inline ::strategy_market::MarketStateRsp* message::unsafe_arena_release_market_state_rsp() {
  // @@protoc_insertion_point(field_unsafe_arena_release:strategy_market.message.market_state_rsp)
  if (_internal_has_market_state_rsp()) {
    clear_has_MessageType();
    ::strategy_market::MarketStateRsp* temp = _impl_.MessageType_.market_state_rsp_;
    _impl_.MessageType_.market_state_rsp_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void message::unsafe_arena_set_allocated_market_state_rsp(::strategy_market::MarketStateRsp* market_state_rsp) {
  clear_MessageType();
  if (market_state_rsp) {
    set_has_market_state_rsp();
    _impl_.MessageType_.market_state_rsp_ = market_state_rsp;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:strategy_market.message.market_state_rsp)
}
inline ::strategy_market::MarketStateRsp* message::_internal_mutable_market_state_rsp() {
  if (!_internal_has_market_state_rsp()) {
    clear_MessageType();
    set_has_market_state_rsp();
    _impl_.MessageType_.market_state_rsp_ = CreateMaybeMessage< ::strategy_market::MarketStateRsp >(GetArenaForAllocation());
  }
  return _impl_.MessageType_.market_state_rsp_;
}
inline ::strategy_market::MarketStateRsp* message::mutable_market_state_rsp() {
  ::strategy_market::MarketStateRsp* _msg = _internal_mutable_market_state_rsp();
  // @@protoc_insertion_point(field_mutable:strategy_market.message.market_state_rsp)
  return _msg;
}

// .strategy_market.ActiveSafetyReq active_req = 6;
inline bool message::_internal_has_active_req() const {
  return MessageType_case() == kActiveReq;
}
inline bool message::has_active_req() const {
  return _internal_has_active_req();
}
inline void message::set_has_active_req() {
  _impl_._oneof_case_[0] = kActiveReq;
}
inline void message::clear_active_req() {
  if (_internal_has_active_req()) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.MessageType_.active_req_;
    }
    clear_has_MessageType();
  }
}
inline ::strategy_market::ActiveSafetyReq* message::release_active_req() {
  // @@protoc_insertion_point(field_release:strategy_market.message.active_req)
  if (_internal_has_active_req()) {
    clear_has_MessageType();
    ::strategy_market::ActiveSafetyReq* temp = _impl_.MessageType_.active_req_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.MessageType_.active_req_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::strategy_market::ActiveSafetyReq& message::_internal_active_req() const {
  return _internal_has_active_req()
      ? *_impl_.MessageType_.active_req_
      : reinterpret_cast< ::strategy_market::ActiveSafetyReq&>(::strategy_market::_ActiveSafetyReq_default_instance_);
}
inline const ::strategy_market::ActiveSafetyReq& message::active_req() const {
  // @@protoc_insertion_point(field_get:strategy_market.message.active_req)
  return _internal_active_req();
}
inline ::strategy_market::ActiveSafetyReq* message::unsafe_arena_release_active_req() {
  // @@protoc_insertion_point(field_unsafe_arena_release:strategy_market.message.active_req)
  if (_internal_has_active_req()) {
    clear_has_MessageType();
    ::strategy_market::ActiveSafetyReq* temp = _impl_.MessageType_.active_req_;
    _impl_.MessageType_.active_req_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void message::unsafe_arena_set_allocated_active_req(::strategy_market::ActiveSafetyReq* active_req) {
  clear_MessageType();
  if (active_req) {
    set_has_active_req();
    _impl_.MessageType_.active_req_ = active_req;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:strategy_market.message.active_req)
}
inline ::strategy_market::ActiveSafetyReq* message::_internal_mutable_active_req() {
  if (!_internal_has_active_req()) {
    clear_MessageType();
    set_has_active_req();
    _impl_.MessageType_.active_req_ = CreateMaybeMessage< ::strategy_market::ActiveSafetyReq >(GetArenaForAllocation());
  }
  return _impl_.MessageType_.active_req_;
}
inline ::strategy_market::ActiveSafetyReq* message::mutable_active_req() {
  ::strategy_market::ActiveSafetyReq* _msg = _internal_mutable_active_req();
  // @@protoc_insertion_point(field_mutable:strategy_market.message.active_req)
  return _msg;
}

// .strategy_market.ActiveSafetyRsp active_rsp = 7;
inline bool message::_internal_has_active_rsp() const {
  return MessageType_case() == kActiveRsp;
}
inline bool message::has_active_rsp() const {
  return _internal_has_active_rsp();
}
inline void message::set_has_active_rsp() {
  _impl_._oneof_case_[0] = kActiveRsp;
}
inline void message::clear_active_rsp() {
  if (_internal_has_active_rsp()) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.MessageType_.active_rsp_;
    }
    clear_has_MessageType();
  }
}
inline ::strategy_market::ActiveSafetyRsp* message::release_active_rsp() {
  // @@protoc_insertion_point(field_release:strategy_market.message.active_rsp)
  if (_internal_has_active_rsp()) {
    clear_has_MessageType();
    ::strategy_market::ActiveSafetyRsp* temp = _impl_.MessageType_.active_rsp_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.MessageType_.active_rsp_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::strategy_market::ActiveSafetyRsp& message::_internal_active_rsp() const {
  return _internal_has_active_rsp()
      ? *_impl_.MessageType_.active_rsp_
      : reinterpret_cast< ::strategy_market::ActiveSafetyRsp&>(::strategy_market::_ActiveSafetyRsp_default_instance_);
}
inline const ::strategy_market::ActiveSafetyRsp& message::active_rsp() const {
  // @@protoc_insertion_point(field_get:strategy_market.message.active_rsp)
  return _internal_active_rsp();
}
inline ::strategy_market::ActiveSafetyRsp* message::unsafe_arena_release_active_rsp() {
  // @@protoc_insertion_point(field_unsafe_arena_release:strategy_market.message.active_rsp)
  if (_internal_has_active_rsp()) {
    clear_has_MessageType();
    ::strategy_market::ActiveSafetyRsp* temp = _impl_.MessageType_.active_rsp_;
    _impl_.MessageType_.active_rsp_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void message::unsafe_arena_set_allocated_active_rsp(::strategy_market::ActiveSafetyRsp* active_rsp) {
  clear_MessageType();
  if (active_rsp) {
    set_has_active_rsp();
    _impl_.MessageType_.active_rsp_ = active_rsp;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:strategy_market.message.active_rsp)
}
inline ::strategy_market::ActiveSafetyRsp* message::_internal_mutable_active_rsp() {
  if (!_internal_has_active_rsp()) {
    clear_MessageType();
    set_has_active_rsp();
    _impl_.MessageType_.active_rsp_ = CreateMaybeMessage< ::strategy_market::ActiveSafetyRsp >(GetArenaForAllocation());
  }
  return _impl_.MessageType_.active_rsp_;
}
inline ::strategy_market::ActiveSafetyRsp* message::mutable_active_rsp() {
  ::strategy_market::ActiveSafetyRsp* _msg = _internal_mutable_active_rsp();
  // @@protoc_insertion_point(field_mutable:strategy_market.message.active_rsp)
  return _msg;
}

// .strategy_market.InstrumentReq instrument_req = 8;
inline bool message::_internal_has_instrument_req() const {
  return MessageType_case() == kInstrumentReq;
}
inline bool message::has_instrument_req() const {
  return _internal_has_instrument_req();
}
inline void message::set_has_instrument_req() {
  _impl_._oneof_case_[0] = kInstrumentReq;
}
inline void message::clear_instrument_req() {
  if (_internal_has_instrument_req()) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.MessageType_.instrument_req_;
    }
    clear_has_MessageType();
  }
}
inline ::strategy_market::InstrumentReq* message::release_instrument_req() {
  // @@protoc_insertion_point(field_release:strategy_market.message.instrument_req)
  if (_internal_has_instrument_req()) {
    clear_has_MessageType();
    ::strategy_market::InstrumentReq* temp = _impl_.MessageType_.instrument_req_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.MessageType_.instrument_req_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::strategy_market::InstrumentReq& message::_internal_instrument_req() const {
  return _internal_has_instrument_req()
      ? *_impl_.MessageType_.instrument_req_
      : reinterpret_cast< ::strategy_market::InstrumentReq&>(::strategy_market::_InstrumentReq_default_instance_);
}
inline const ::strategy_market::InstrumentReq& message::instrument_req() const {
  // @@protoc_insertion_point(field_get:strategy_market.message.instrument_req)
  return _internal_instrument_req();
}
inline ::strategy_market::InstrumentReq* message::unsafe_arena_release_instrument_req() {
  // @@protoc_insertion_point(field_unsafe_arena_release:strategy_market.message.instrument_req)
  if (_internal_has_instrument_req()) {
    clear_has_MessageType();
    ::strategy_market::InstrumentReq* temp = _impl_.MessageType_.instrument_req_;
    _impl_.MessageType_.instrument_req_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void message::unsafe_arena_set_allocated_instrument_req(::strategy_market::InstrumentReq* instrument_req) {
  clear_MessageType();
  if (instrument_req) {
    set_has_instrument_req();
    _impl_.MessageType_.instrument_req_ = instrument_req;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:strategy_market.message.instrument_req)
}
inline ::strategy_market::InstrumentReq* message::_internal_mutable_instrument_req() {
  if (!_internal_has_instrument_req()) {
    clear_MessageType();
    set_has_instrument_req();
    _impl_.MessageType_.instrument_req_ = CreateMaybeMessage< ::strategy_market::InstrumentReq >(GetArenaForAllocation());
  }
  return _impl_.MessageType_.instrument_req_;
}
inline ::strategy_market::InstrumentReq* message::mutable_instrument_req() {
  ::strategy_market::InstrumentReq* _msg = _internal_mutable_instrument_req();
  // @@protoc_insertion_point(field_mutable:strategy_market.message.instrument_req)
  return _msg;
}

// .strategy_market.InstrumentRsp instrument_rsp = 9;
inline bool message::_internal_has_instrument_rsp() const {
  return MessageType_case() == kInstrumentRsp;
}
inline bool message::has_instrument_rsp() const {
  return _internal_has_instrument_rsp();
}
inline void message::set_has_instrument_rsp() {
  _impl_._oneof_case_[0] = kInstrumentRsp;
}
inline void message::clear_instrument_rsp() {
  if (_internal_has_instrument_rsp()) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.MessageType_.instrument_rsp_;
    }
    clear_has_MessageType();
  }
}
inline ::strategy_market::InstrumentRsp* message::release_instrument_rsp() {
  // @@protoc_insertion_point(field_release:strategy_market.message.instrument_rsp)
  if (_internal_has_instrument_rsp()) {
    clear_has_MessageType();
    ::strategy_market::InstrumentRsp* temp = _impl_.MessageType_.instrument_rsp_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.MessageType_.instrument_rsp_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::strategy_market::InstrumentRsp& message::_internal_instrument_rsp() const {
  return _internal_has_instrument_rsp()
      ? *_impl_.MessageType_.instrument_rsp_
      : reinterpret_cast< ::strategy_market::InstrumentRsp&>(::strategy_market::_InstrumentRsp_default_instance_);
}
inline const ::strategy_market::InstrumentRsp& message::instrument_rsp() const {
  // @@protoc_insertion_point(field_get:strategy_market.message.instrument_rsp)
  return _internal_instrument_rsp();
}
inline ::strategy_market::InstrumentRsp* message::unsafe_arena_release_instrument_rsp() {
  // @@protoc_insertion_point(field_unsafe_arena_release:strategy_market.message.instrument_rsp)
  if (_internal_has_instrument_rsp()) {
    clear_has_MessageType();
    ::strategy_market::InstrumentRsp* temp = _impl_.MessageType_.instrument_rsp_;
    _impl_.MessageType_.instrument_rsp_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void message::unsafe_arena_set_allocated_instrument_rsp(::strategy_market::InstrumentRsp* instrument_rsp) {
  clear_MessageType();
  if (instrument_rsp) {
    set_has_instrument_rsp();
    _impl_.MessageType_.instrument_rsp_ = instrument_rsp;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:strategy_market.message.instrument_rsp)
}
inline ::strategy_market::InstrumentRsp* message::_internal_mutable_instrument_rsp() {
  if (!_internal_has_instrument_rsp()) {
    clear_MessageType();
    set_has_instrument_rsp();
    _impl_.MessageType_.instrument_rsp_ = CreateMaybeMessage< ::strategy_market::InstrumentRsp >(GetArenaForAllocation());
  }
  return _impl_.MessageType_.instrument_rsp_;
}
inline ::strategy_market::InstrumentRsp* message::mutable_instrument_rsp() {
  ::strategy_market::InstrumentRsp* _msg = _internal_mutable_instrument_rsp();
  // @@protoc_insertion_point(field_mutable:strategy_market.message.instrument_rsp)
  return _msg;
}

// .strategy_market.CheckStrategyAliveReq strategy_alive_req = 10;
inline bool message::_internal_has_strategy_alive_req() const {
  return MessageType_case() == kStrategyAliveReq;
}
inline bool message::has_strategy_alive_req() const {
  return _internal_has_strategy_alive_req();
}
inline void message::set_has_strategy_alive_req() {
  _impl_._oneof_case_[0] = kStrategyAliveReq;
}
inline void message::clear_strategy_alive_req() {
  if (_internal_has_strategy_alive_req()) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.MessageType_.strategy_alive_req_;
    }
    clear_has_MessageType();
  }
}
inline ::strategy_market::CheckStrategyAliveReq* message::release_strategy_alive_req() {
  // @@protoc_insertion_point(field_release:strategy_market.message.strategy_alive_req)
  if (_internal_has_strategy_alive_req()) {
    clear_has_MessageType();
    ::strategy_market::CheckStrategyAliveReq* temp = _impl_.MessageType_.strategy_alive_req_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.MessageType_.strategy_alive_req_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::strategy_market::CheckStrategyAliveReq& message::_internal_strategy_alive_req() const {
  return _internal_has_strategy_alive_req()
      ? *_impl_.MessageType_.strategy_alive_req_
      : reinterpret_cast< ::strategy_market::CheckStrategyAliveReq&>(::strategy_market::_CheckStrategyAliveReq_default_instance_);
}
inline const ::strategy_market::CheckStrategyAliveReq& message::strategy_alive_req() const {
  // @@protoc_insertion_point(field_get:strategy_market.message.strategy_alive_req)
  return _internal_strategy_alive_req();
}
inline ::strategy_market::CheckStrategyAliveReq* message::unsafe_arena_release_strategy_alive_req() {
  // @@protoc_insertion_point(field_unsafe_arena_release:strategy_market.message.strategy_alive_req)
  if (_internal_has_strategy_alive_req()) {
    clear_has_MessageType();
    ::strategy_market::CheckStrategyAliveReq* temp = _impl_.MessageType_.strategy_alive_req_;
    _impl_.MessageType_.strategy_alive_req_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void message::unsafe_arena_set_allocated_strategy_alive_req(::strategy_market::CheckStrategyAliveReq* strategy_alive_req) {
  clear_MessageType();
  if (strategy_alive_req) {
    set_has_strategy_alive_req();
    _impl_.MessageType_.strategy_alive_req_ = strategy_alive_req;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:strategy_market.message.strategy_alive_req)
}
inline ::strategy_market::CheckStrategyAliveReq* message::_internal_mutable_strategy_alive_req() {
  if (!_internal_has_strategy_alive_req()) {
    clear_MessageType();
    set_has_strategy_alive_req();
    _impl_.MessageType_.strategy_alive_req_ = CreateMaybeMessage< ::strategy_market::CheckStrategyAliveReq >(GetArenaForAllocation());
  }
  return _impl_.MessageType_.strategy_alive_req_;
}
inline ::strategy_market::CheckStrategyAliveReq* message::mutable_strategy_alive_req() {
  ::strategy_market::CheckStrategyAliveReq* _msg = _internal_mutable_strategy_alive_req();
  // @@protoc_insertion_point(field_mutable:strategy_market.message.strategy_alive_req)
  return _msg;
}

// .strategy_market.CheckStrategyAliveRsp strategy_alive_rsp = 11;
inline bool message::_internal_has_strategy_alive_rsp() const {
  return MessageType_case() == kStrategyAliveRsp;
}
inline bool message::has_strategy_alive_rsp() const {
  return _internal_has_strategy_alive_rsp();
}
inline void message::set_has_strategy_alive_rsp() {
  _impl_._oneof_case_[0] = kStrategyAliveRsp;
}
inline void message::clear_strategy_alive_rsp() {
  if (_internal_has_strategy_alive_rsp()) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.MessageType_.strategy_alive_rsp_;
    }
    clear_has_MessageType();
  }
}
inline ::strategy_market::CheckStrategyAliveRsp* message::release_strategy_alive_rsp() {
  // @@protoc_insertion_point(field_release:strategy_market.message.strategy_alive_rsp)
  if (_internal_has_strategy_alive_rsp()) {
    clear_has_MessageType();
    ::strategy_market::CheckStrategyAliveRsp* temp = _impl_.MessageType_.strategy_alive_rsp_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.MessageType_.strategy_alive_rsp_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::strategy_market::CheckStrategyAliveRsp& message::_internal_strategy_alive_rsp() const {
  return _internal_has_strategy_alive_rsp()
      ? *_impl_.MessageType_.strategy_alive_rsp_
      : reinterpret_cast< ::strategy_market::CheckStrategyAliveRsp&>(::strategy_market::_CheckStrategyAliveRsp_default_instance_);
}
inline const ::strategy_market::CheckStrategyAliveRsp& message::strategy_alive_rsp() const {
  // @@protoc_insertion_point(field_get:strategy_market.message.strategy_alive_rsp)
  return _internal_strategy_alive_rsp();
}
inline ::strategy_market::CheckStrategyAliveRsp* message::unsafe_arena_release_strategy_alive_rsp() {
  // @@protoc_insertion_point(field_unsafe_arena_release:strategy_market.message.strategy_alive_rsp)
  if (_internal_has_strategy_alive_rsp()) {
    clear_has_MessageType();
    ::strategy_market::CheckStrategyAliveRsp* temp = _impl_.MessageType_.strategy_alive_rsp_;
    _impl_.MessageType_.strategy_alive_rsp_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void message::unsafe_arena_set_allocated_strategy_alive_rsp(::strategy_market::CheckStrategyAliveRsp* strategy_alive_rsp) {
  clear_MessageType();
  if (strategy_alive_rsp) {
    set_has_strategy_alive_rsp();
    _impl_.MessageType_.strategy_alive_rsp_ = strategy_alive_rsp;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:strategy_market.message.strategy_alive_rsp)
}
inline ::strategy_market::CheckStrategyAliveRsp* message::_internal_mutable_strategy_alive_rsp() {
  if (!_internal_has_strategy_alive_rsp()) {
    clear_MessageType();
    set_has_strategy_alive_rsp();
    _impl_.MessageType_.strategy_alive_rsp_ = CreateMaybeMessage< ::strategy_market::CheckStrategyAliveRsp >(GetArenaForAllocation());
  }
  return _impl_.MessageType_.strategy_alive_rsp_;
}
inline ::strategy_market::CheckStrategyAliveRsp* message::mutable_strategy_alive_rsp() {
  ::strategy_market::CheckStrategyAliveRsp* _msg = _internal_mutable_strategy_alive_rsp();
  // @@protoc_insertion_point(field_mutable:strategy_market.message.strategy_alive_rsp)
  return _msg;
}

// .strategy_market.CheckMarketAliveReq market_alive_req = 12;
inline bool message::_internal_has_market_alive_req() const {
  return MessageType_case() == kMarketAliveReq;
}
inline bool message::has_market_alive_req() const {
  return _internal_has_market_alive_req();
}
inline void message::set_has_market_alive_req() {
  _impl_._oneof_case_[0] = kMarketAliveReq;
}
inline void message::clear_market_alive_req() {
  if (_internal_has_market_alive_req()) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.MessageType_.market_alive_req_;
    }
    clear_has_MessageType();
  }
}
inline ::strategy_market::CheckMarketAliveReq* message::release_market_alive_req() {
  // @@protoc_insertion_point(field_release:strategy_market.message.market_alive_req)
  if (_internal_has_market_alive_req()) {
    clear_has_MessageType();
    ::strategy_market::CheckMarketAliveReq* temp = _impl_.MessageType_.market_alive_req_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.MessageType_.market_alive_req_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::strategy_market::CheckMarketAliveReq& message::_internal_market_alive_req() const {
  return _internal_has_market_alive_req()
      ? *_impl_.MessageType_.market_alive_req_
      : reinterpret_cast< ::strategy_market::CheckMarketAliveReq&>(::strategy_market::_CheckMarketAliveReq_default_instance_);
}
inline const ::strategy_market::CheckMarketAliveReq& message::market_alive_req() const {
  // @@protoc_insertion_point(field_get:strategy_market.message.market_alive_req)
  return _internal_market_alive_req();
}
inline ::strategy_market::CheckMarketAliveReq* message::unsafe_arena_release_market_alive_req() {
  // @@protoc_insertion_point(field_unsafe_arena_release:strategy_market.message.market_alive_req)
  if (_internal_has_market_alive_req()) {
    clear_has_MessageType();
    ::strategy_market::CheckMarketAliveReq* temp = _impl_.MessageType_.market_alive_req_;
    _impl_.MessageType_.market_alive_req_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void message::unsafe_arena_set_allocated_market_alive_req(::strategy_market::CheckMarketAliveReq* market_alive_req) {
  clear_MessageType();
  if (market_alive_req) {
    set_has_market_alive_req();
    _impl_.MessageType_.market_alive_req_ = market_alive_req;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:strategy_market.message.market_alive_req)
}
inline ::strategy_market::CheckMarketAliveReq* message::_internal_mutable_market_alive_req() {
  if (!_internal_has_market_alive_req()) {
    clear_MessageType();
    set_has_market_alive_req();
    _impl_.MessageType_.market_alive_req_ = CreateMaybeMessage< ::strategy_market::CheckMarketAliveReq >(GetArenaForAllocation());
  }
  return _impl_.MessageType_.market_alive_req_;
}
inline ::strategy_market::CheckMarketAliveReq* message::mutable_market_alive_req() {
  ::strategy_market::CheckMarketAliveReq* _msg = _internal_mutable_market_alive_req();
  // @@protoc_insertion_point(field_mutable:strategy_market.message.market_alive_req)
  return _msg;
}

// .strategy_market.CheckMarketAliveRsp market_alive_rsp = 13;
inline bool message::_internal_has_market_alive_rsp() const {
  return MessageType_case() == kMarketAliveRsp;
}
inline bool message::has_market_alive_rsp() const {
  return _internal_has_market_alive_rsp();
}
inline void message::set_has_market_alive_rsp() {
  _impl_._oneof_case_[0] = kMarketAliveRsp;
}
inline void message::clear_market_alive_rsp() {
  if (_internal_has_market_alive_rsp()) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.MessageType_.market_alive_rsp_;
    }
    clear_has_MessageType();
  }
}
inline ::strategy_market::CheckMarketAliveRsp* message::release_market_alive_rsp() {
  // @@protoc_insertion_point(field_release:strategy_market.message.market_alive_rsp)
  if (_internal_has_market_alive_rsp()) {
    clear_has_MessageType();
    ::strategy_market::CheckMarketAliveRsp* temp = _impl_.MessageType_.market_alive_rsp_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.MessageType_.market_alive_rsp_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::strategy_market::CheckMarketAliveRsp& message::_internal_market_alive_rsp() const {
  return _internal_has_market_alive_rsp()
      ? *_impl_.MessageType_.market_alive_rsp_
      : reinterpret_cast< ::strategy_market::CheckMarketAliveRsp&>(::strategy_market::_CheckMarketAliveRsp_default_instance_);
}
inline const ::strategy_market::CheckMarketAliveRsp& message::market_alive_rsp() const {
  // @@protoc_insertion_point(field_get:strategy_market.message.market_alive_rsp)
  return _internal_market_alive_rsp();
}
inline ::strategy_market::CheckMarketAliveRsp* message::unsafe_arena_release_market_alive_rsp() {
  // @@protoc_insertion_point(field_unsafe_arena_release:strategy_market.message.market_alive_rsp)
  if (_internal_has_market_alive_rsp()) {
    clear_has_MessageType();
    ::strategy_market::CheckMarketAliveRsp* temp = _impl_.MessageType_.market_alive_rsp_;
    _impl_.MessageType_.market_alive_rsp_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void message::unsafe_arena_set_allocated_market_alive_rsp(::strategy_market::CheckMarketAliveRsp* market_alive_rsp) {
  clear_MessageType();
  if (market_alive_rsp) {
    set_has_market_alive_rsp();
    _impl_.MessageType_.market_alive_rsp_ = market_alive_rsp;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:strategy_market.message.market_alive_rsp)
}
inline ::strategy_market::CheckMarketAliveRsp* message::_internal_mutable_market_alive_rsp() {
  if (!_internal_has_market_alive_rsp()) {
    clear_MessageType();
    set_has_market_alive_rsp();
    _impl_.MessageType_.market_alive_rsp_ = CreateMaybeMessage< ::strategy_market::CheckMarketAliveRsp >(GetArenaForAllocation());
  }
  return _impl_.MessageType_.market_alive_rsp_;
}
inline ::strategy_market::CheckMarketAliveRsp* message::mutable_market_alive_rsp() {
  ::strategy_market::CheckMarketAliveRsp* _msg = _internal_mutable_market_alive_rsp();
  // @@protoc_insertion_point(field_mutable:strategy_market.message.market_alive_rsp)
  return _msg;
}

inline bool message::has_MessageType() const {
  return MessageType_case() != MESSAGETYPE_NOT_SET;
}
inline void message::clear_has_MessageType() {
  _impl_._oneof_case_[0] = MESSAGETYPE_NOT_SET;
}
inline message::MessageTypeCase message::MessageType_case() const {
  return message::MessageTypeCase(_impl_._oneof_case_[0]);
}
// -------------------------------------------------------------------

// TickData

// string time_point = 1;
inline void TickData::clear_time_point() {
  _impl_.time_point_.ClearToEmpty();
}
inline const std::string& TickData::time_point() const {
  // @@protoc_insertion_point(field_get:strategy_market.TickData.time_point)
  return _internal_time_point();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void TickData::set_time_point(ArgT0&& arg0, ArgT... args) {
 
 _impl_.time_point_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:strategy_market.TickData.time_point)
}
inline std::string* TickData::mutable_time_point() {
  std::string* _s = _internal_mutable_time_point();
  // @@protoc_insertion_point(field_mutable:strategy_market.TickData.time_point)
  return _s;
}
inline const std::string& TickData::_internal_time_point() const {
  return _impl_.time_point_.Get();
}
inline void TickData::_internal_set_time_point(const std::string& value) {
  
  _impl_.time_point_.Set(value, GetArenaForAllocation());
}
inline std::string* TickData::_internal_mutable_time_point() {
  
  return _impl_.time_point_.Mutable(GetArenaForAllocation());
}
inline std::string* TickData::release_time_point() {
  // @@protoc_insertion_point(field_release:strategy_market.TickData.time_point)
  return _impl_.time_point_.Release();
}
inline void TickData::set_allocated_time_point(std::string* time_point) {
  if (time_point != nullptr) {
    
  } else {
    
  }
  _impl_.time_point_.SetAllocated(time_point, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.time_point_.IsDefault()) {
    _impl_.time_point_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:strategy_market.TickData.time_point)
}

// string instrument_id = 2;
inline void TickData::clear_instrument_id() {
  _impl_.instrument_id_.ClearToEmpty();
}
inline const std::string& TickData::instrument_id() const {
  // @@protoc_insertion_point(field_get:strategy_market.TickData.instrument_id)
  return _internal_instrument_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void TickData::set_instrument_id(ArgT0&& arg0, ArgT... args) {
 
 _impl_.instrument_id_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:strategy_market.TickData.instrument_id)
}
inline std::string* TickData::mutable_instrument_id() {
  std::string* _s = _internal_mutable_instrument_id();
  // @@protoc_insertion_point(field_mutable:strategy_market.TickData.instrument_id)
  return _s;
}
inline const std::string& TickData::_internal_instrument_id() const {
  return _impl_.instrument_id_.Get();
}
inline void TickData::_internal_set_instrument_id(const std::string& value) {
  
  _impl_.instrument_id_.Set(value, GetArenaForAllocation());
}
inline std::string* TickData::_internal_mutable_instrument_id() {
  
  return _impl_.instrument_id_.Mutable(GetArenaForAllocation());
}
inline std::string* TickData::release_instrument_id() {
  // @@protoc_insertion_point(field_release:strategy_market.TickData.instrument_id)
  return _impl_.instrument_id_.Release();
}
inline void TickData::set_allocated_instrument_id(std::string* instrument_id) {
  if (instrument_id != nullptr) {
    
  } else {
    
  }
  _impl_.instrument_id_.SetAllocated(instrument_id, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.instrument_id_.IsDefault()) {
    _impl_.instrument_id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:strategy_market.TickData.instrument_id)
}

// .strategy_market.TickData.TickState state = 3;
inline void TickData::clear_state() {
  _impl_.state_ = 0;
}
inline ::strategy_market::TickData_TickState TickData::_internal_state() const {
  return static_cast< ::strategy_market::TickData_TickState >(_impl_.state_);
}
inline ::strategy_market::TickData_TickState TickData::state() const {
  // @@protoc_insertion_point(field_get:strategy_market.TickData.state)
  return _internal_state();
}
inline void TickData::_internal_set_state(::strategy_market::TickData_TickState value) {
  
  _impl_.state_ = value;
}
inline void TickData::set_state(::strategy_market::TickData_TickState value) {
  _internal_set_state(value);
  // @@protoc_insertion_point(field_set:strategy_market.TickData.state)
}

// double last_price = 4;
inline void TickData::clear_last_price() {
  _impl_.last_price_ = 0;
}
inline double TickData::_internal_last_price() const {
  return _impl_.last_price_;
}
inline double TickData::last_price() const {
  // @@protoc_insertion_point(field_get:strategy_market.TickData.last_price)
  return _internal_last_price();
}
inline void TickData::_internal_set_last_price(double value) {
  
  _impl_.last_price_ = value;
}
inline void TickData::set_last_price(double value) {
  _internal_set_last_price(value);
  // @@protoc_insertion_point(field_set:strategy_market.TickData.last_price)
}

// double bid_price1 = 5;
inline void TickData::clear_bid_price1() {
  _impl_.bid_price1_ = 0;
}
inline double TickData::_internal_bid_price1() const {
  return _impl_.bid_price1_;
}
inline double TickData::bid_price1() const {
  // @@protoc_insertion_point(field_get:strategy_market.TickData.bid_price1)
  return _internal_bid_price1();
}
inline void TickData::_internal_set_bid_price1(double value) {
  
  _impl_.bid_price1_ = value;
}
inline void TickData::set_bid_price1(double value) {
  _internal_set_bid_price1(value);
  // @@protoc_insertion_point(field_set:strategy_market.TickData.bid_price1)
}

// uint32 bid_volume1 = 6;
inline void TickData::clear_bid_volume1() {
  _impl_.bid_volume1_ = 0u;
}
inline uint32_t TickData::_internal_bid_volume1() const {
  return _impl_.bid_volume1_;
}
inline uint32_t TickData::bid_volume1() const {
  // @@protoc_insertion_point(field_get:strategy_market.TickData.bid_volume1)
  return _internal_bid_volume1();
}
inline void TickData::_internal_set_bid_volume1(uint32_t value) {
  
  _impl_.bid_volume1_ = value;
}
inline void TickData::set_bid_volume1(uint32_t value) {
  _internal_set_bid_volume1(value);
  // @@protoc_insertion_point(field_set:strategy_market.TickData.bid_volume1)
}

// double ask_price1 = 7;
inline void TickData::clear_ask_price1() {
  _impl_.ask_price1_ = 0;
}
inline double TickData::_internal_ask_price1() const {
  return _impl_.ask_price1_;
}
inline double TickData::ask_price1() const {
  // @@protoc_insertion_point(field_get:strategy_market.TickData.ask_price1)
  return _internal_ask_price1();
}
inline void TickData::_internal_set_ask_price1(double value) {
  
  _impl_.ask_price1_ = value;
}
inline void TickData::set_ask_price1(double value) {
  _internal_set_ask_price1(value);
  // @@protoc_insertion_point(field_set:strategy_market.TickData.ask_price1)
}

// uint32 ask_volume1 = 8;
inline void TickData::clear_ask_volume1() {
  _impl_.ask_volume1_ = 0u;
}
inline uint32_t TickData::_internal_ask_volume1() const {
  return _impl_.ask_volume1_;
}
inline uint32_t TickData::ask_volume1() const {
  // @@protoc_insertion_point(field_get:strategy_market.TickData.ask_volume1)
  return _internal_ask_volume1();
}
inline void TickData::_internal_set_ask_volume1(uint32_t value) {
  
  _impl_.ask_volume1_ = value;
}
inline void TickData::set_ask_volume1(uint32_t value) {
  _internal_set_ask_volume1(value);
  // @@protoc_insertion_point(field_set:strategy_market.TickData.ask_volume1)
}

// double bid_price2 = 9;
inline void TickData::clear_bid_price2() {
  _impl_.bid_price2_ = 0;
}
inline double TickData::_internal_bid_price2() const {
  return _impl_.bid_price2_;
}
inline double TickData::bid_price2() const {
  // @@protoc_insertion_point(field_get:strategy_market.TickData.bid_price2)
  return _internal_bid_price2();
}
inline void TickData::_internal_set_bid_price2(double value) {
  
  _impl_.bid_price2_ = value;
}
inline void TickData::set_bid_price2(double value) {
  _internal_set_bid_price2(value);
  // @@protoc_insertion_point(field_set:strategy_market.TickData.bid_price2)
}

// uint32 bid_volume2 = 10;
inline void TickData::clear_bid_volume2() {
  _impl_.bid_volume2_ = 0u;
}
inline uint32_t TickData::_internal_bid_volume2() const {
  return _impl_.bid_volume2_;
}
inline uint32_t TickData::bid_volume2() const {
  // @@protoc_insertion_point(field_get:strategy_market.TickData.bid_volume2)
  return _internal_bid_volume2();
}
inline void TickData::_internal_set_bid_volume2(uint32_t value) {
  
  _impl_.bid_volume2_ = value;
}
inline void TickData::set_bid_volume2(uint32_t value) {
  _internal_set_bid_volume2(value);
  // @@protoc_insertion_point(field_set:strategy_market.TickData.bid_volume2)
}

// double ask_price2 = 11;
inline void TickData::clear_ask_price2() {
  _impl_.ask_price2_ = 0;
}
inline double TickData::_internal_ask_price2() const {
  return _impl_.ask_price2_;
}
inline double TickData::ask_price2() const {
  // @@protoc_insertion_point(field_get:strategy_market.TickData.ask_price2)
  return _internal_ask_price2();
}
inline void TickData::_internal_set_ask_price2(double value) {
  
  _impl_.ask_price2_ = value;
}
inline void TickData::set_ask_price2(double value) {
  _internal_set_ask_price2(value);
  // @@protoc_insertion_point(field_set:strategy_market.TickData.ask_price2)
}

// uint32 ask_volume2 = 12;
inline void TickData::clear_ask_volume2() {
  _impl_.ask_volume2_ = 0u;
}
inline uint32_t TickData::_internal_ask_volume2() const {
  return _impl_.ask_volume2_;
}
inline uint32_t TickData::ask_volume2() const {
  // @@protoc_insertion_point(field_get:strategy_market.TickData.ask_volume2)
  return _internal_ask_volume2();
}
inline void TickData::_internal_set_ask_volume2(uint32_t value) {
  
  _impl_.ask_volume2_ = value;
}
inline void TickData::set_ask_volume2(uint32_t value) {
  _internal_set_ask_volume2(value);
  // @@protoc_insertion_point(field_set:strategy_market.TickData.ask_volume2)
}

// double bid_price3 = 13;
inline void TickData::clear_bid_price3() {
  _impl_.bid_price3_ = 0;
}
inline double TickData::_internal_bid_price3() const {
  return _impl_.bid_price3_;
}
inline double TickData::bid_price3() const {
  // @@protoc_insertion_point(field_get:strategy_market.TickData.bid_price3)
  return _internal_bid_price3();
}
inline void TickData::_internal_set_bid_price3(double value) {
  
  _impl_.bid_price3_ = value;
}
inline void TickData::set_bid_price3(double value) {
  _internal_set_bid_price3(value);
  // @@protoc_insertion_point(field_set:strategy_market.TickData.bid_price3)
}

// uint32 bid_volume3 = 14;
inline void TickData::clear_bid_volume3() {
  _impl_.bid_volume3_ = 0u;
}
inline uint32_t TickData::_internal_bid_volume3() const {
  return _impl_.bid_volume3_;
}
inline uint32_t TickData::bid_volume3() const {
  // @@protoc_insertion_point(field_get:strategy_market.TickData.bid_volume3)
  return _internal_bid_volume3();
}
inline void TickData::_internal_set_bid_volume3(uint32_t value) {
  
  _impl_.bid_volume3_ = value;
}
inline void TickData::set_bid_volume3(uint32_t value) {
  _internal_set_bid_volume3(value);
  // @@protoc_insertion_point(field_set:strategy_market.TickData.bid_volume3)
}

// double ask_price3 = 15;
inline void TickData::clear_ask_price3() {
  _impl_.ask_price3_ = 0;
}
inline double TickData::_internal_ask_price3() const {
  return _impl_.ask_price3_;
}
inline double TickData::ask_price3() const {
  // @@protoc_insertion_point(field_get:strategy_market.TickData.ask_price3)
  return _internal_ask_price3();
}
inline void TickData::_internal_set_ask_price3(double value) {
  
  _impl_.ask_price3_ = value;
}
inline void TickData::set_ask_price3(double value) {
  _internal_set_ask_price3(value);
  // @@protoc_insertion_point(field_set:strategy_market.TickData.ask_price3)
}

// uint32 ask_volume3 = 16;
inline void TickData::clear_ask_volume3() {
  _impl_.ask_volume3_ = 0u;
}
inline uint32_t TickData::_internal_ask_volume3() const {
  return _impl_.ask_volume3_;
}
inline uint32_t TickData::ask_volume3() const {
  // @@protoc_insertion_point(field_get:strategy_market.TickData.ask_volume3)
  return _internal_ask_volume3();
}
inline void TickData::_internal_set_ask_volume3(uint32_t value) {
  
  _impl_.ask_volume3_ = value;
}
inline void TickData::set_ask_volume3(uint32_t value) {
  _internal_set_ask_volume3(value);
  // @@protoc_insertion_point(field_set:strategy_market.TickData.ask_volume3)
}

// double bid_price4 = 17;
inline void TickData::clear_bid_price4() {
  _impl_.bid_price4_ = 0;
}
inline double TickData::_internal_bid_price4() const {
  return _impl_.bid_price4_;
}
inline double TickData::bid_price4() const {
  // @@protoc_insertion_point(field_get:strategy_market.TickData.bid_price4)
  return _internal_bid_price4();
}
inline void TickData::_internal_set_bid_price4(double value) {
  
  _impl_.bid_price4_ = value;
}
inline void TickData::set_bid_price4(double value) {
  _internal_set_bid_price4(value);
  // @@protoc_insertion_point(field_set:strategy_market.TickData.bid_price4)
}

// uint32 bid_volume4 = 18;
inline void TickData::clear_bid_volume4() {
  _impl_.bid_volume4_ = 0u;
}
inline uint32_t TickData::_internal_bid_volume4() const {
  return _impl_.bid_volume4_;
}
inline uint32_t TickData::bid_volume4() const {
  // @@protoc_insertion_point(field_get:strategy_market.TickData.bid_volume4)
  return _internal_bid_volume4();
}
inline void TickData::_internal_set_bid_volume4(uint32_t value) {
  
  _impl_.bid_volume4_ = value;
}
inline void TickData::set_bid_volume4(uint32_t value) {
  _internal_set_bid_volume4(value);
  // @@protoc_insertion_point(field_set:strategy_market.TickData.bid_volume4)
}

// double ask_price4 = 19;
inline void TickData::clear_ask_price4() {
  _impl_.ask_price4_ = 0;
}
inline double TickData::_internal_ask_price4() const {
  return _impl_.ask_price4_;
}
inline double TickData::ask_price4() const {
  // @@protoc_insertion_point(field_get:strategy_market.TickData.ask_price4)
  return _internal_ask_price4();
}
inline void TickData::_internal_set_ask_price4(double value) {
  
  _impl_.ask_price4_ = value;
}
inline void TickData::set_ask_price4(double value) {
  _internal_set_ask_price4(value);
  // @@protoc_insertion_point(field_set:strategy_market.TickData.ask_price4)
}

// uint32 ask_volume4 = 20;
inline void TickData::clear_ask_volume4() {
  _impl_.ask_volume4_ = 0u;
}
inline uint32_t TickData::_internal_ask_volume4() const {
  return _impl_.ask_volume4_;
}
inline uint32_t TickData::ask_volume4() const {
  // @@protoc_insertion_point(field_get:strategy_market.TickData.ask_volume4)
  return _internal_ask_volume4();
}
inline void TickData::_internal_set_ask_volume4(uint32_t value) {
  
  _impl_.ask_volume4_ = value;
}
inline void TickData::set_ask_volume4(uint32_t value) {
  _internal_set_ask_volume4(value);
  // @@protoc_insertion_point(field_set:strategy_market.TickData.ask_volume4)
}

// double bid_price5 = 21;
inline void TickData::clear_bid_price5() {
  _impl_.bid_price5_ = 0;
}
inline double TickData::_internal_bid_price5() const {
  return _impl_.bid_price5_;
}
inline double TickData::bid_price5() const {
  // @@protoc_insertion_point(field_get:strategy_market.TickData.bid_price5)
  return _internal_bid_price5();
}
inline void TickData::_internal_set_bid_price5(double value) {
  
  _impl_.bid_price5_ = value;
}
inline void TickData::set_bid_price5(double value) {
  _internal_set_bid_price5(value);
  // @@protoc_insertion_point(field_set:strategy_market.TickData.bid_price5)
}

// uint32 bid_volume5 = 22;
inline void TickData::clear_bid_volume5() {
  _impl_.bid_volume5_ = 0u;
}
inline uint32_t TickData::_internal_bid_volume5() const {
  return _impl_.bid_volume5_;
}
inline uint32_t TickData::bid_volume5() const {
  // @@protoc_insertion_point(field_get:strategy_market.TickData.bid_volume5)
  return _internal_bid_volume5();
}
inline void TickData::_internal_set_bid_volume5(uint32_t value) {
  
  _impl_.bid_volume5_ = value;
}
inline void TickData::set_bid_volume5(uint32_t value) {
  _internal_set_bid_volume5(value);
  // @@protoc_insertion_point(field_set:strategy_market.TickData.bid_volume5)
}

// double ask_price5 = 23;
inline void TickData::clear_ask_price5() {
  _impl_.ask_price5_ = 0;
}
inline double TickData::_internal_ask_price5() const {
  return _impl_.ask_price5_;
}
inline double TickData::ask_price5() const {
  // @@protoc_insertion_point(field_get:strategy_market.TickData.ask_price5)
  return _internal_ask_price5();
}
inline void TickData::_internal_set_ask_price5(double value) {
  
  _impl_.ask_price5_ = value;
}
inline void TickData::set_ask_price5(double value) {
  _internal_set_ask_price5(value);
  // @@protoc_insertion_point(field_set:strategy_market.TickData.ask_price5)
}

// uint32 ask_volume5 = 24;
inline void TickData::clear_ask_volume5() {
  _impl_.ask_volume5_ = 0u;
}
inline uint32_t TickData::_internal_ask_volume5() const {
  return _impl_.ask_volume5_;
}
inline uint32_t TickData::ask_volume5() const {
  // @@protoc_insertion_point(field_get:strategy_market.TickData.ask_volume5)
  return _internal_ask_volume5();
}
inline void TickData::_internal_set_ask_volume5(uint32_t value) {
  
  _impl_.ask_volume5_ = value;
}
inline void TickData::set_ask_volume5(uint32_t value) {
  _internal_set_ask_volume5(value);
  // @@protoc_insertion_point(field_set:strategy_market.TickData.ask_volume5)
}

// double turnover = 25;
inline void TickData::clear_turnover() {
  _impl_.turnover_ = 0;
}
inline double TickData::_internal_turnover() const {
  return _impl_.turnover_;
}
inline double TickData::turnover() const {
  // @@protoc_insertion_point(field_get:strategy_market.TickData.turnover)
  return _internal_turnover();
}
inline void TickData::_internal_set_turnover(double value) {
  
  _impl_.turnover_ = value;
}
inline void TickData::set_turnover(double value) {
  _internal_set_turnover(value);
  // @@protoc_insertion_point(field_set:strategy_market.TickData.turnover)
}

// uint64 open_interest = 26;
inline void TickData::clear_open_interest() {
  _impl_.open_interest_ = uint64_t{0u};
}
inline uint64_t TickData::_internal_open_interest() const {
  return _impl_.open_interest_;
}
inline uint64_t TickData::open_interest() const {
  // @@protoc_insertion_point(field_get:strategy_market.TickData.open_interest)
  return _internal_open_interest();
}
inline void TickData::_internal_set_open_interest(uint64_t value) {
  
  _impl_.open_interest_ = value;
}
inline void TickData::set_open_interest(uint64_t value) {
  _internal_set_open_interest(value);
  // @@protoc_insertion_point(field_set:strategy_market.TickData.open_interest)
}

// double upper_limit_price = 27;
inline void TickData::clear_upper_limit_price() {
  _impl_.upper_limit_price_ = 0;
}
inline double TickData::_internal_upper_limit_price() const {
  return _impl_.upper_limit_price_;
}
inline double TickData::upper_limit_price() const {
  // @@protoc_insertion_point(field_get:strategy_market.TickData.upper_limit_price)
  return _internal_upper_limit_price();
}
inline void TickData::_internal_set_upper_limit_price(double value) {
  
  _impl_.upper_limit_price_ = value;
}
inline void TickData::set_upper_limit_price(double value) {
  _internal_set_upper_limit_price(value);
  // @@protoc_insertion_point(field_set:strategy_market.TickData.upper_limit_price)
}

// double lower_limit_price = 28;
inline void TickData::clear_lower_limit_price() {
  _impl_.lower_limit_price_ = 0;
}
inline double TickData::_internal_lower_limit_price() const {
  return _impl_.lower_limit_price_;
}
inline double TickData::lower_limit_price() const {
  // @@protoc_insertion_point(field_get:strategy_market.TickData.lower_limit_price)
  return _internal_lower_limit_price();
}
inline void TickData::_internal_set_lower_limit_price(double value) {
  
  _impl_.lower_limit_price_ = value;
}
inline void TickData::set_lower_limit_price(double value) {
  _internal_set_lower_limit_price(value);
  // @@protoc_insertion_point(field_set:strategy_market.TickData.lower_limit_price)
}

// double open_price = 29;
inline void TickData::clear_open_price() {
  _impl_.open_price_ = 0;
}
inline double TickData::_internal_open_price() const {
  return _impl_.open_price_;
}
inline double TickData::open_price() const {
  // @@protoc_insertion_point(field_get:strategy_market.TickData.open_price)
  return _internal_open_price();
}
inline void TickData::_internal_set_open_price(double value) {
  
  _impl_.open_price_ = value;
}
inline void TickData::set_open_price(double value) {
  _internal_set_open_price(value);
  // @@protoc_insertion_point(field_set:strategy_market.TickData.open_price)
}

// double pre_settlement_price = 30;
inline void TickData::clear_pre_settlement_price() {
  _impl_.pre_settlement_price_ = 0;
}
inline double TickData::_internal_pre_settlement_price() const {
  return _impl_.pre_settlement_price_;
}
inline double TickData::pre_settlement_price() const {
  // @@protoc_insertion_point(field_get:strategy_market.TickData.pre_settlement_price)
  return _internal_pre_settlement_price();
}
inline void TickData::_internal_set_pre_settlement_price(double value) {
  
  _impl_.pre_settlement_price_ = value;
}
inline void TickData::set_pre_settlement_price(double value) {
  _internal_set_pre_settlement_price(value);
  // @@protoc_insertion_point(field_set:strategy_market.TickData.pre_settlement_price)
}

// double pre_close_price = 31;
inline void TickData::clear_pre_close_price() {
  _impl_.pre_close_price_ = 0;
}
inline double TickData::_internal_pre_close_price() const {
  return _impl_.pre_close_price_;
}
inline double TickData::pre_close_price() const {
  // @@protoc_insertion_point(field_get:strategy_market.TickData.pre_close_price)
  return _internal_pre_close_price();
}
inline void TickData::_internal_set_pre_close_price(double value) {
  
  _impl_.pre_close_price_ = value;
}
inline void TickData::set_pre_close_price(double value) {
  _internal_set_pre_close_price(value);
  // @@protoc_insertion_point(field_set:strategy_market.TickData.pre_close_price)
}

// uint64 pre_open_interest = 32;
inline void TickData::clear_pre_open_interest() {
  _impl_.pre_open_interest_ = uint64_t{0u};
}
inline uint64_t TickData::_internal_pre_open_interest() const {
  return _impl_.pre_open_interest_;
}
inline uint64_t TickData::pre_open_interest() const {
  // @@protoc_insertion_point(field_get:strategy_market.TickData.pre_open_interest)
  return _internal_pre_open_interest();
}
inline void TickData::_internal_set_pre_open_interest(uint64_t value) {
  
  _impl_.pre_open_interest_ = value;
}
inline void TickData::set_pre_open_interest(uint64_t value) {
  _internal_set_pre_open_interest(value);
  // @@protoc_insertion_point(field_set:strategy_market.TickData.pre_open_interest)
}

// uint64 volume = 33;
inline void TickData::clear_volume() {
  _impl_.volume_ = uint64_t{0u};
}
inline uint64_t TickData::_internal_volume() const {
  return _impl_.volume_;
}
inline uint64_t TickData::volume() const {
  // @@protoc_insertion_point(field_get:strategy_market.TickData.volume)
  return _internal_volume();
}
inline void TickData::_internal_set_volume(uint64_t value) {
  
  _impl_.volume_ = value;
}
inline void TickData::set_volume(uint64_t value) {
  _internal_set_volume(value);
  // @@protoc_insertion_point(field_set:strategy_market.TickData.volume)
}

// -------------------------------------------------------------------

// MarketStateReq

// .strategy_market.MarketStateReq.MarketState market_state = 1;
inline void MarketStateReq::clear_market_state() {
  _impl_.market_state_ = 0;
}
inline ::strategy_market::MarketStateReq_MarketState MarketStateReq::_internal_market_state() const {
  return static_cast< ::strategy_market::MarketStateReq_MarketState >(_impl_.market_state_);
}
inline ::strategy_market::MarketStateReq_MarketState MarketStateReq::market_state() const {
  // @@protoc_insertion_point(field_get:strategy_market.MarketStateReq.market_state)
  return _internal_market_state();
}
inline void MarketStateReq::_internal_set_market_state(::strategy_market::MarketStateReq_MarketState value) {
  
  _impl_.market_state_ = value;
}
inline void MarketStateReq::set_market_state(::strategy_market::MarketStateReq_MarketState value) {
  _internal_set_market_state(value);
  // @@protoc_insertion_point(field_set:strategy_market.MarketStateReq.market_state)
}

// string date = 2;
inline void MarketStateReq::clear_date() {
  _impl_.date_.ClearToEmpty();
}
inline const std::string& MarketStateReq::date() const {
  // @@protoc_insertion_point(field_get:strategy_market.MarketStateReq.date)
  return _internal_date();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void MarketStateReq::set_date(ArgT0&& arg0, ArgT... args) {
 
 _impl_.date_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:strategy_market.MarketStateReq.date)
}
inline std::string* MarketStateReq::mutable_date() {
  std::string* _s = _internal_mutable_date();
  // @@protoc_insertion_point(field_mutable:strategy_market.MarketStateReq.date)
  return _s;
}
inline const std::string& MarketStateReq::_internal_date() const {
  return _impl_.date_.Get();
}
inline void MarketStateReq::_internal_set_date(const std::string& value) {
  
  _impl_.date_.Set(value, GetArenaForAllocation());
}
inline std::string* MarketStateReq::_internal_mutable_date() {
  
  return _impl_.date_.Mutable(GetArenaForAllocation());
}
inline std::string* MarketStateReq::release_date() {
  // @@protoc_insertion_point(field_release:strategy_market.MarketStateReq.date)
  return _impl_.date_.Release();
}
inline void MarketStateReq::set_allocated_date(std::string* date) {
  if (date != nullptr) {
    
  } else {
    
  }
  _impl_.date_.SetAllocated(date, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.date_.IsDefault()) {
    _impl_.date_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:strategy_market.MarketStateReq.date)
}

// bool is_last = 3;
inline void MarketStateReq::clear_is_last() {
  _impl_.is_last_ = false;
}
inline bool MarketStateReq::_internal_is_last() const {
  return _impl_.is_last_;
}
inline bool MarketStateReq::is_last() const {
  // @@protoc_insertion_point(field_get:strategy_market.MarketStateReq.is_last)
  return _internal_is_last();
}
inline void MarketStateReq::_internal_set_is_last(bool value) {
  
  _impl_.is_last_ = value;
}
inline void MarketStateReq::set_is_last(bool value) {
  _internal_set_is_last(value);
  // @@protoc_insertion_point(field_set:strategy_market.MarketStateReq.is_last)
}

// -------------------------------------------------------------------

// MarketStateRsp

// uint32 result = 1;
inline void MarketStateRsp::clear_result() {
  _impl_.result_ = 0u;
}
inline uint32_t MarketStateRsp::_internal_result() const {
  return _impl_.result_;
}
inline uint32_t MarketStateRsp::result() const {
  // @@protoc_insertion_point(field_get:strategy_market.MarketStateRsp.result)
  return _internal_result();
}
inline void MarketStateRsp::_internal_set_result(uint32_t value) {
  
  _impl_.result_ = value;
}
inline void MarketStateRsp::set_result(uint32_t value) {
  _internal_set_result(value);
  // @@protoc_insertion_point(field_set:strategy_market.MarketStateRsp.result)
}

// -------------------------------------------------------------------

// TickSubscribeRsp

// uint32 result = 1;
inline void TickSubscribeRsp::clear_result() {
  _impl_.result_ = 0u;
}
inline uint32_t TickSubscribeRsp::_internal_result() const {
  return _impl_.result_;
}
inline uint32_t TickSubscribeRsp::result() const {
  // @@protoc_insertion_point(field_get:strategy_market.TickSubscribeRsp.result)
  return _internal_result();
}
inline void TickSubscribeRsp::_internal_set_result(uint32_t value) {
  
  _impl_.result_ = value;
}
inline void TickSubscribeRsp::set_result(uint32_t value) {
  _internal_set_result(value);
  // @@protoc_insertion_point(field_set:strategy_market.TickSubscribeRsp.result)
}

// -------------------------------------------------------------------

// TickSubscribeReq

// .strategy_market.InstrumentInfo instrument_info = 1;
inline bool TickSubscribeReq::_internal_has_instrument_info() const {
  return this != internal_default_instance() && _impl_.instrument_info_ != nullptr;
}
inline bool TickSubscribeReq::has_instrument_info() const {
  return _internal_has_instrument_info();
}
inline void TickSubscribeReq::clear_instrument_info() {
  if (GetArenaForAllocation() == nullptr && _impl_.instrument_info_ != nullptr) {
    delete _impl_.instrument_info_;
  }
  _impl_.instrument_info_ = nullptr;
}
inline const ::strategy_market::InstrumentInfo& TickSubscribeReq::_internal_instrument_info() const {
  const ::strategy_market::InstrumentInfo* p = _impl_.instrument_info_;
  return p != nullptr ? *p : reinterpret_cast<const ::strategy_market::InstrumentInfo&>(
      ::strategy_market::_InstrumentInfo_default_instance_);
}
inline const ::strategy_market::InstrumentInfo& TickSubscribeReq::instrument_info() const {
  // @@protoc_insertion_point(field_get:strategy_market.TickSubscribeReq.instrument_info)
  return _internal_instrument_info();
}
inline void TickSubscribeReq::unsafe_arena_set_allocated_instrument_info(
    ::strategy_market::InstrumentInfo* instrument_info) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.instrument_info_);
  }
  _impl_.instrument_info_ = instrument_info;
  if (instrument_info) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:strategy_market.TickSubscribeReq.instrument_info)
}
inline ::strategy_market::InstrumentInfo* TickSubscribeReq::release_instrument_info() {
  
  ::strategy_market::InstrumentInfo* temp = _impl_.instrument_info_;
  _impl_.instrument_info_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::strategy_market::InstrumentInfo* TickSubscribeReq::unsafe_arena_release_instrument_info() {
  // @@protoc_insertion_point(field_release:strategy_market.TickSubscribeReq.instrument_info)
  
  ::strategy_market::InstrumentInfo* temp = _impl_.instrument_info_;
  _impl_.instrument_info_ = nullptr;
  return temp;
}
inline ::strategy_market::InstrumentInfo* TickSubscribeReq::_internal_mutable_instrument_info() {
  
  if (_impl_.instrument_info_ == nullptr) {
    auto* p = CreateMaybeMessage<::strategy_market::InstrumentInfo>(GetArenaForAllocation());
    _impl_.instrument_info_ = p;
  }
  return _impl_.instrument_info_;
}
inline ::strategy_market::InstrumentInfo* TickSubscribeReq::mutable_instrument_info() {
  ::strategy_market::InstrumentInfo* _msg = _internal_mutable_instrument_info();
  // @@protoc_insertion_point(field_mutable:strategy_market.TickSubscribeReq.instrument_info)
  return _msg;
}
inline void TickSubscribeReq::set_allocated_instrument_info(::strategy_market::InstrumentInfo* instrument_info) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.instrument_info_;
  }
  if (instrument_info) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(instrument_info);
    if (message_arena != submessage_arena) {
      instrument_info = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, instrument_info, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.instrument_info_ = instrument_info;
  // @@protoc_insertion_point(field_set_allocated:strategy_market.TickSubscribeReq.instrument_info)
}

// .strategy_market.TickSubscribeReq.Action action = 2;
inline void TickSubscribeReq::clear_action() {
  _impl_.action_ = 0;
}
inline ::strategy_market::TickSubscribeReq_Action TickSubscribeReq::_internal_action() const {
  return static_cast< ::strategy_market::TickSubscribeReq_Action >(_impl_.action_);
}
inline ::strategy_market::TickSubscribeReq_Action TickSubscribeReq::action() const {
  // @@protoc_insertion_point(field_get:strategy_market.TickSubscribeReq.action)
  return _internal_action();
}
inline void TickSubscribeReq::_internal_set_action(::strategy_market::TickSubscribeReq_Action value) {
  
  _impl_.action_ = value;
}
inline void TickSubscribeReq::set_action(::strategy_market::TickSubscribeReq_Action value) {
  _internal_set_action(value);
  // @@protoc_insertion_point(field_set:strategy_market.TickSubscribeReq.action)
}

// -------------------------------------------------------------------

// InstrumentInfo

// string instrument_id = 1;
inline void InstrumentInfo::clear_instrument_id() {
  _impl_.instrument_id_.ClearToEmpty();
}
inline const std::string& InstrumentInfo::instrument_id() const {
  // @@protoc_insertion_point(field_get:strategy_market.InstrumentInfo.instrument_id)
  return _internal_instrument_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void InstrumentInfo::set_instrument_id(ArgT0&& arg0, ArgT... args) {
 
 _impl_.instrument_id_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:strategy_market.InstrumentInfo.instrument_id)
}
inline std::string* InstrumentInfo::mutable_instrument_id() {
  std::string* _s = _internal_mutable_instrument_id();
  // @@protoc_insertion_point(field_mutable:strategy_market.InstrumentInfo.instrument_id)
  return _s;
}
inline const std::string& InstrumentInfo::_internal_instrument_id() const {
  return _impl_.instrument_id_.Get();
}
inline void InstrumentInfo::_internal_set_instrument_id(const std::string& value) {
  
  _impl_.instrument_id_.Set(value, GetArenaForAllocation());
}
inline std::string* InstrumentInfo::_internal_mutable_instrument_id() {
  
  return _impl_.instrument_id_.Mutable(GetArenaForAllocation());
}
inline std::string* InstrumentInfo::release_instrument_id() {
  // @@protoc_insertion_point(field_release:strategy_market.InstrumentInfo.instrument_id)
  return _impl_.instrument_id_.Release();
}
inline void InstrumentInfo::set_allocated_instrument_id(std::string* instrument_id) {
  if (instrument_id != nullptr) {
    
  } else {
    
  }
  _impl_.instrument_id_.SetAllocated(instrument_id, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.instrument_id_.IsDefault()) {
    _impl_.instrument_id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:strategy_market.InstrumentInfo.instrument_id)
}

// string exchange_id = 2;
inline void InstrumentInfo::clear_exchange_id() {
  _impl_.exchange_id_.ClearToEmpty();
}
inline const std::string& InstrumentInfo::exchange_id() const {
  // @@protoc_insertion_point(field_get:strategy_market.InstrumentInfo.exchange_id)
  return _internal_exchange_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void InstrumentInfo::set_exchange_id(ArgT0&& arg0, ArgT... args) {
 
 _impl_.exchange_id_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:strategy_market.InstrumentInfo.exchange_id)
}
inline std::string* InstrumentInfo::mutable_exchange_id() {
  std::string* _s = _internal_mutable_exchange_id();
  // @@protoc_insertion_point(field_mutable:strategy_market.InstrumentInfo.exchange_id)
  return _s;
}
inline const std::string& InstrumentInfo::_internal_exchange_id() const {
  return _impl_.exchange_id_.Get();
}
inline void InstrumentInfo::_internal_set_exchange_id(const std::string& value) {
  
  _impl_.exchange_id_.Set(value, GetArenaForAllocation());
}
inline std::string* InstrumentInfo::_internal_mutable_exchange_id() {
  
  return _impl_.exchange_id_.Mutable(GetArenaForAllocation());
}
inline std::string* InstrumentInfo::release_exchange_id() {
  // @@protoc_insertion_point(field_release:strategy_market.InstrumentInfo.exchange_id)
  return _impl_.exchange_id_.Release();
}
inline void InstrumentInfo::set_allocated_exchange_id(std::string* exchange_id) {
  if (exchange_id != nullptr) {
    
  } else {
    
  }
  _impl_.exchange_id_.SetAllocated(exchange_id, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.exchange_id_.IsDefault()) {
    _impl_.exchange_id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:strategy_market.InstrumentInfo.exchange_id)
}

// -------------------------------------------------------------------

// ActiveSafetyReq

// .strategy_market.ActiveSafetyReq.MessageType safe_id = 1;
inline void ActiveSafetyReq::clear_safe_id() {
  _impl_.safe_id_ = 0;
}
inline ::strategy_market::ActiveSafetyReq_MessageType ActiveSafetyReq::_internal_safe_id() const {
  return static_cast< ::strategy_market::ActiveSafetyReq_MessageType >(_impl_.safe_id_);
}
inline ::strategy_market::ActiveSafetyReq_MessageType ActiveSafetyReq::safe_id() const {
  // @@protoc_insertion_point(field_get:strategy_market.ActiveSafetyReq.safe_id)
  return _internal_safe_id();
}
inline void ActiveSafetyReq::_internal_set_safe_id(::strategy_market::ActiveSafetyReq_MessageType value) {
  
  _impl_.safe_id_ = value;
}
inline void ActiveSafetyReq::set_safe_id(::strategy_market::ActiveSafetyReq_MessageType value) {
  _internal_set_safe_id(value);
  // @@protoc_insertion_point(field_set:strategy_market.ActiveSafetyReq.safe_id)
}

// -------------------------------------------------------------------

// ActiveSafetyRsp

// bool status = 1;
inline void ActiveSafetyRsp::clear_status() {
  _impl_.status_ = false;
}
inline bool ActiveSafetyRsp::_internal_status() const {
  return _impl_.status_;
}
inline bool ActiveSafetyRsp::status() const {
  // @@protoc_insertion_point(field_get:strategy_market.ActiveSafetyRsp.status)
  return _internal_status();
}
inline void ActiveSafetyRsp::_internal_set_status(bool value) {
  
  _impl_.status_ = value;
}
inline void ActiveSafetyRsp::set_status(bool value) {
  _internal_set_status(value);
  // @@protoc_insertion_point(field_set:strategy_market.ActiveSafetyRsp.status)
}

// -------------------------------------------------------------------

// InstrumentReq

// .strategy_market.InstrumentInfo instrument_info = 1;
inline bool InstrumentReq::_internal_has_instrument_info() const {
  return this != internal_default_instance() && _impl_.instrument_info_ != nullptr;
}
inline bool InstrumentReq::has_instrument_info() const {
  return _internal_has_instrument_info();
}
inline void InstrumentReq::clear_instrument_info() {
  if (GetArenaForAllocation() == nullptr && _impl_.instrument_info_ != nullptr) {
    delete _impl_.instrument_info_;
  }
  _impl_.instrument_info_ = nullptr;
}
inline const ::strategy_market::InstrumentInfo& InstrumentReq::_internal_instrument_info() const {
  const ::strategy_market::InstrumentInfo* p = _impl_.instrument_info_;
  return p != nullptr ? *p : reinterpret_cast<const ::strategy_market::InstrumentInfo&>(
      ::strategy_market::_InstrumentInfo_default_instance_);
}
inline const ::strategy_market::InstrumentInfo& InstrumentReq::instrument_info() const {
  // @@protoc_insertion_point(field_get:strategy_market.InstrumentReq.instrument_info)
  return _internal_instrument_info();
}
inline void InstrumentReq::unsafe_arena_set_allocated_instrument_info(
    ::strategy_market::InstrumentInfo* instrument_info) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.instrument_info_);
  }
  _impl_.instrument_info_ = instrument_info;
  if (instrument_info) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:strategy_market.InstrumentReq.instrument_info)
}
inline ::strategy_market::InstrumentInfo* InstrumentReq::release_instrument_info() {
  
  ::strategy_market::InstrumentInfo* temp = _impl_.instrument_info_;
  _impl_.instrument_info_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::strategy_market::InstrumentInfo* InstrumentReq::unsafe_arena_release_instrument_info() {
  // @@protoc_insertion_point(field_release:strategy_market.InstrumentReq.instrument_info)
  
  ::strategy_market::InstrumentInfo* temp = _impl_.instrument_info_;
  _impl_.instrument_info_ = nullptr;
  return temp;
}
inline ::strategy_market::InstrumentInfo* InstrumentReq::_internal_mutable_instrument_info() {
  
  if (_impl_.instrument_info_ == nullptr) {
    auto* p = CreateMaybeMessage<::strategy_market::InstrumentInfo>(GetArenaForAllocation());
    _impl_.instrument_info_ = p;
  }
  return _impl_.instrument_info_;
}
inline ::strategy_market::InstrumentInfo* InstrumentReq::mutable_instrument_info() {
  ::strategy_market::InstrumentInfo* _msg = _internal_mutable_instrument_info();
  // @@protoc_insertion_point(field_mutable:strategy_market.InstrumentReq.instrument_info)
  return _msg;
}
inline void InstrumentReq::set_allocated_instrument_info(::strategy_market::InstrumentInfo* instrument_info) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.instrument_info_;
  }
  if (instrument_info) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(instrument_info);
    if (message_arena != submessage_arena) {
      instrument_info = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, instrument_info, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.instrument_info_ = instrument_info;
  // @@protoc_insertion_point(field_set_allocated:strategy_market.InstrumentReq.instrument_info)
}

// -------------------------------------------------------------------

// InstrumentRsp

// string instrument_id = 1;
inline void InstrumentRsp::clear_instrument_id() {
  _impl_.instrument_id_.ClearToEmpty();
}
inline const std::string& InstrumentRsp::instrument_id() const {
  // @@protoc_insertion_point(field_get:strategy_market.InstrumentRsp.instrument_id)
  return _internal_instrument_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void InstrumentRsp::set_instrument_id(ArgT0&& arg0, ArgT... args) {
 
 _impl_.instrument_id_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:strategy_market.InstrumentRsp.instrument_id)
}
inline std::string* InstrumentRsp::mutable_instrument_id() {
  std::string* _s = _internal_mutable_instrument_id();
  // @@protoc_insertion_point(field_mutable:strategy_market.InstrumentRsp.instrument_id)
  return _s;
}
inline const std::string& InstrumentRsp::_internal_instrument_id() const {
  return _impl_.instrument_id_.Get();
}
inline void InstrumentRsp::_internal_set_instrument_id(const std::string& value) {
  
  _impl_.instrument_id_.Set(value, GetArenaForAllocation());
}
inline std::string* InstrumentRsp::_internal_mutable_instrument_id() {
  
  return _impl_.instrument_id_.Mutable(GetArenaForAllocation());
}
inline std::string* InstrumentRsp::release_instrument_id() {
  // @@protoc_insertion_point(field_release:strategy_market.InstrumentRsp.instrument_id)
  return _impl_.instrument_id_.Release();
}
inline void InstrumentRsp::set_allocated_instrument_id(std::string* instrument_id) {
  if (instrument_id != nullptr) {
    
  } else {
    
  }
  _impl_.instrument_id_.SetAllocated(instrument_id, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.instrument_id_.IsDefault()) {
    _impl_.instrument_id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:strategy_market.InstrumentRsp.instrument_id)
}

// string exchange_id = 2;
inline void InstrumentRsp::clear_exchange_id() {
  _impl_.exchange_id_.ClearToEmpty();
}
inline const std::string& InstrumentRsp::exchange_id() const {
  // @@protoc_insertion_point(field_get:strategy_market.InstrumentRsp.exchange_id)
  return _internal_exchange_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void InstrumentRsp::set_exchange_id(ArgT0&& arg0, ArgT... args) {
 
 _impl_.exchange_id_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:strategy_market.InstrumentRsp.exchange_id)
}
inline std::string* InstrumentRsp::mutable_exchange_id() {
  std::string* _s = _internal_mutable_exchange_id();
  // @@protoc_insertion_point(field_mutable:strategy_market.InstrumentRsp.exchange_id)
  return _s;
}
inline const std::string& InstrumentRsp::_internal_exchange_id() const {
  return _impl_.exchange_id_.Get();
}
inline void InstrumentRsp::_internal_set_exchange_id(const std::string& value) {
  
  _impl_.exchange_id_.Set(value, GetArenaForAllocation());
}
inline std::string* InstrumentRsp::_internal_mutable_exchange_id() {
  
  return _impl_.exchange_id_.Mutable(GetArenaForAllocation());
}
inline std::string* InstrumentRsp::release_exchange_id() {
  // @@protoc_insertion_point(field_release:strategy_market.InstrumentRsp.exchange_id)
  return _impl_.exchange_id_.Release();
}
inline void InstrumentRsp::set_allocated_exchange_id(std::string* exchange_id) {
  if (exchange_id != nullptr) {
    
  } else {
    
  }
  _impl_.exchange_id_.SetAllocated(exchange_id, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.exchange_id_.IsDefault()) {
    _impl_.exchange_id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:strategy_market.InstrumentRsp.exchange_id)
}

// double price_tick = 3;
inline void InstrumentRsp::clear_price_tick() {
  _impl_.price_tick_ = 0;
}
inline double InstrumentRsp::_internal_price_tick() const {
  return _impl_.price_tick_;
}
inline double InstrumentRsp::price_tick() const {
  // @@protoc_insertion_point(field_get:strategy_market.InstrumentRsp.price_tick)
  return _internal_price_tick();
}
inline void InstrumentRsp::_internal_set_price_tick(double value) {
  
  _impl_.price_tick_ = value;
}
inline void InstrumentRsp::set_price_tick(double value) {
  _internal_set_price_tick(value);
  // @@protoc_insertion_point(field_set:strategy_market.InstrumentRsp.price_tick)
}

// int32 max_market_order_volume = 4;
inline void InstrumentRsp::clear_max_market_order_volume() {
  _impl_.max_market_order_volume_ = 0;
}
inline int32_t InstrumentRsp::_internal_max_market_order_volume() const {
  return _impl_.max_market_order_volume_;
}
inline int32_t InstrumentRsp::max_market_order_volume() const {
  // @@protoc_insertion_point(field_get:strategy_market.InstrumentRsp.max_market_order_volume)
  return _internal_max_market_order_volume();
}
inline void InstrumentRsp::_internal_set_max_market_order_volume(int32_t value) {
  
  _impl_.max_market_order_volume_ = value;
}
inline void InstrumentRsp::set_max_market_order_volume(int32_t value) {
  _internal_set_max_market_order_volume(value);
  // @@protoc_insertion_point(field_set:strategy_market.InstrumentRsp.max_market_order_volume)
}

// int32 min_market_order_volume = 5;
inline void InstrumentRsp::clear_min_market_order_volume() {
  _impl_.min_market_order_volume_ = 0;
}
inline int32_t InstrumentRsp::_internal_min_market_order_volume() const {
  return _impl_.min_market_order_volume_;
}
inline int32_t InstrumentRsp::min_market_order_volume() const {
  // @@protoc_insertion_point(field_get:strategy_market.InstrumentRsp.min_market_order_volume)
  return _internal_min_market_order_volume();
}
inline void InstrumentRsp::_internal_set_min_market_order_volume(int32_t value) {
  
  _impl_.min_market_order_volume_ = value;
}
inline void InstrumentRsp::set_min_market_order_volume(int32_t value) {
  _internal_set_min_market_order_volume(value);
  // @@protoc_insertion_point(field_set:strategy_market.InstrumentRsp.min_market_order_volume)
}

// int32 max_limit_order_volume = 6;
inline void InstrumentRsp::clear_max_limit_order_volume() {
  _impl_.max_limit_order_volume_ = 0;
}
inline int32_t InstrumentRsp::_internal_max_limit_order_volume() const {
  return _impl_.max_limit_order_volume_;
}
inline int32_t InstrumentRsp::max_limit_order_volume() const {
  // @@protoc_insertion_point(field_get:strategy_market.InstrumentRsp.max_limit_order_volume)
  return _internal_max_limit_order_volume();
}
inline void InstrumentRsp::_internal_set_max_limit_order_volume(int32_t value) {
  
  _impl_.max_limit_order_volume_ = value;
}
inline void InstrumentRsp::set_max_limit_order_volume(int32_t value) {
  _internal_set_max_limit_order_volume(value);
  // @@protoc_insertion_point(field_set:strategy_market.InstrumentRsp.max_limit_order_volume)
}

// int32 min_limit_order_volume = 7;
inline void InstrumentRsp::clear_min_limit_order_volume() {
  _impl_.min_limit_order_volume_ = 0;
}
inline int32_t InstrumentRsp::_internal_min_limit_order_volume() const {
  return _impl_.min_limit_order_volume_;
}
inline int32_t InstrumentRsp::min_limit_order_volume() const {
  // @@protoc_insertion_point(field_get:strategy_market.InstrumentRsp.min_limit_order_volume)
  return _internal_min_limit_order_volume();
}
inline void InstrumentRsp::_internal_set_min_limit_order_volume(int32_t value) {
  
  _impl_.min_limit_order_volume_ = value;
}
inline void InstrumentRsp::set_min_limit_order_volume(int32_t value) {
  _internal_set_min_limit_order_volume(value);
  // @@protoc_insertion_point(field_set:strategy_market.InstrumentRsp.min_limit_order_volume)
}

// double volume_multiple = 8;
inline void InstrumentRsp::clear_volume_multiple() {
  _impl_.volume_multiple_ = 0;
}
inline double InstrumentRsp::_internal_volume_multiple() const {
  return _impl_.volume_multiple_;
}
inline double InstrumentRsp::volume_multiple() const {
  // @@protoc_insertion_point(field_get:strategy_market.InstrumentRsp.volume_multiple)
  return _internal_volume_multiple();
}
inline void InstrumentRsp::_internal_set_volume_multiple(double value) {
  
  _impl_.volume_multiple_ = value;
}
inline void InstrumentRsp::set_volume_multiple(double value) {
  _internal_set_volume_multiple(value);
  // @@protoc_insertion_point(field_set:strategy_market.InstrumentRsp.volume_multiple)
}

// int32 is_trading = 9;
inline void InstrumentRsp::clear_is_trading() {
  _impl_.is_trading_ = 0;
}
inline int32_t InstrumentRsp::_internal_is_trading() const {
  return _impl_.is_trading_;
}
inline int32_t InstrumentRsp::is_trading() const {
  // @@protoc_insertion_point(field_get:strategy_market.InstrumentRsp.is_trading)
  return _internal_is_trading();
}
inline void InstrumentRsp::_internal_set_is_trading(int32_t value) {
  
  _impl_.is_trading_ = value;
}
inline void InstrumentRsp::set_is_trading(int32_t value) {
  _internal_set_is_trading(value);
  // @@protoc_insertion_point(field_set:strategy_market.InstrumentRsp.is_trading)
}

// .strategy_market.Result result = 10;
inline void InstrumentRsp::clear_result() {
  _impl_.result_ = 0;
}
inline ::strategy_market::Result InstrumentRsp::_internal_result() const {
  return static_cast< ::strategy_market::Result >(_impl_.result_);
}
inline ::strategy_market::Result InstrumentRsp::result() const {
  // @@protoc_insertion_point(field_get:strategy_market.InstrumentRsp.result)
  return _internal_result();
}
inline void InstrumentRsp::_internal_set_result(::strategy_market::Result value) {
  
  _impl_.result_ = value;
}
inline void InstrumentRsp::set_result(::strategy_market::Result value) {
  _internal_set_result(value);
  // @@protoc_insertion_point(field_set:strategy_market.InstrumentRsp.result)
}

// string failedReason = 11;
inline void InstrumentRsp::clear_failedreason() {
  _impl_.failedreason_.ClearToEmpty();
}
inline const std::string& InstrumentRsp::failedreason() const {
  // @@protoc_insertion_point(field_get:strategy_market.InstrumentRsp.failedReason)
  return _internal_failedreason();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void InstrumentRsp::set_failedreason(ArgT0&& arg0, ArgT... args) {
 
 _impl_.failedreason_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:strategy_market.InstrumentRsp.failedReason)
}
inline std::string* InstrumentRsp::mutable_failedreason() {
  std::string* _s = _internal_mutable_failedreason();
  // @@protoc_insertion_point(field_mutable:strategy_market.InstrumentRsp.failedReason)
  return _s;
}
inline const std::string& InstrumentRsp::_internal_failedreason() const {
  return _impl_.failedreason_.Get();
}
inline void InstrumentRsp::_internal_set_failedreason(const std::string& value) {
  
  _impl_.failedreason_.Set(value, GetArenaForAllocation());
}
inline std::string* InstrumentRsp::_internal_mutable_failedreason() {
  
  return _impl_.failedreason_.Mutable(GetArenaForAllocation());
}
inline std::string* InstrumentRsp::release_failedreason() {
  // @@protoc_insertion_point(field_release:strategy_market.InstrumentRsp.failedReason)
  return _impl_.failedreason_.Release();
}
inline void InstrumentRsp::set_allocated_failedreason(std::string* failedreason) {
  if (failedreason != nullptr) {
    
  } else {
    
  }
  _impl_.failedreason_.SetAllocated(failedreason, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.failedreason_.IsDefault()) {
    _impl_.failedreason_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:strategy_market.InstrumentRsp.failedReason)
}

// -------------------------------------------------------------------

// CheckStrategyAliveReq

// bool alive_req = 1;
inline void CheckStrategyAliveReq::clear_alive_req() {
  _impl_.alive_req_ = false;
}
inline bool CheckStrategyAliveReq::_internal_alive_req() const {
  return _impl_.alive_req_;
}
inline bool CheckStrategyAliveReq::alive_req() const {
  // @@protoc_insertion_point(field_get:strategy_market.CheckStrategyAliveReq.alive_req)
  return _internal_alive_req();
}
inline void CheckStrategyAliveReq::_internal_set_alive_req(bool value) {
  
  _impl_.alive_req_ = value;
}
inline void CheckStrategyAliveReq::set_alive_req(bool value) {
  _internal_set_alive_req(value);
  // @@protoc_insertion_point(field_set:strategy_market.CheckStrategyAliveReq.alive_req)
}

// -------------------------------------------------------------------

// CheckStrategyAliveRsp

// bool alive_rsp = 1;
inline void CheckStrategyAliveRsp::clear_alive_rsp() {
  _impl_.alive_rsp_ = false;
}
inline bool CheckStrategyAliveRsp::_internal_alive_rsp() const {
  return _impl_.alive_rsp_;
}
inline bool CheckStrategyAliveRsp::alive_rsp() const {
  // @@protoc_insertion_point(field_get:strategy_market.CheckStrategyAliveRsp.alive_rsp)
  return _internal_alive_rsp();
}
inline void CheckStrategyAliveRsp::_internal_set_alive_rsp(bool value) {
  
  _impl_.alive_rsp_ = value;
}
inline void CheckStrategyAliveRsp::set_alive_rsp(bool value) {
  _internal_set_alive_rsp(value);
  // @@protoc_insertion_point(field_set:strategy_market.CheckStrategyAliveRsp.alive_rsp)
}

// -------------------------------------------------------------------

// CheckMarketAliveReq

// bool alive_req = 1;
inline void CheckMarketAliveReq::clear_alive_req() {
  _impl_.alive_req_ = false;
}
inline bool CheckMarketAliveReq::_internal_alive_req() const {
  return _impl_.alive_req_;
}
inline bool CheckMarketAliveReq::alive_req() const {
  // @@protoc_insertion_point(field_get:strategy_market.CheckMarketAliveReq.alive_req)
  return _internal_alive_req();
}
inline void CheckMarketAliveReq::_internal_set_alive_req(bool value) {
  
  _impl_.alive_req_ = value;
}
inline void CheckMarketAliveReq::set_alive_req(bool value) {
  _internal_set_alive_req(value);
  // @@protoc_insertion_point(field_set:strategy_market.CheckMarketAliveReq.alive_req)
}

// -------------------------------------------------------------------

// CheckMarketAliveRsp

// bool alive_rsp = 1;
inline void CheckMarketAliveRsp::clear_alive_rsp() {
  _impl_.alive_rsp_ = false;
}
inline bool CheckMarketAliveRsp::_internal_alive_rsp() const {
  return _impl_.alive_rsp_;
}
inline bool CheckMarketAliveRsp::alive_rsp() const {
  // @@protoc_insertion_point(field_get:strategy_market.CheckMarketAliveRsp.alive_rsp)
  return _internal_alive_rsp();
}
inline void CheckMarketAliveRsp::_internal_set_alive_rsp(bool value) {
  
  _impl_.alive_rsp_ = value;
}
inline void CheckMarketAliveRsp::set_alive_rsp(bool value) {
  _internal_set_alive_rsp(value);
  // @@protoc_insertion_point(field_set:strategy_market.CheckMarketAliveRsp.alive_rsp)
}

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace strategy_market

PROTOBUF_NAMESPACE_OPEN

template <> struct is_proto_enum< ::strategy_market::TickData_TickState> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::strategy_market::TickData_TickState>() {
  return ::strategy_market::TickData_TickState_descriptor();
}
template <> struct is_proto_enum< ::strategy_market::MarketStateReq_MarketState> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::strategy_market::MarketStateReq_MarketState>() {
  return ::strategy_market::MarketStateReq_MarketState_descriptor();
}
template <> struct is_proto_enum< ::strategy_market::TickSubscribeReq_Action> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::strategy_market::TickSubscribeReq_Action>() {
  return ::strategy_market::TickSubscribeReq_Action_descriptor();
}
template <> struct is_proto_enum< ::strategy_market::ActiveSafetyReq_MessageType> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::strategy_market::ActiveSafetyReq_MessageType>() {
  return ::strategy_market::ActiveSafetyReq_MessageType_descriptor();
}
template <> struct is_proto_enum< ::strategy_market::Result> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::strategy_market::Result>() {
  return ::strategy_market::Result_descriptor();
}

PROTOBUF_NAMESPACE_CLOSE

// @@protoc_insertion_point(global_scope)

#include <google/protobuf/port_undef.inc>
#endif  // GOOGLE_PROTOBUF_INCLUDED_GOOGLE_PROTOBUF_INCLUDED_strategy_2dmarket_2eproto
