// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: market-trader.proto

#ifndef GOOGLE_PROTOBUF_INCLUDED_market_2dtrader_2eproto
#define GOOGLE_PROTOBUF_INCLUDED_market_2dtrader_2eproto

#include <limits>
#include <string>

#include <google/protobuf/port_def.inc>
#if PROTOBUF_VERSION < 3021000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers. Please update
#error your headers.
#endif
#if 3021005 < PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers. Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/port_undef.inc>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/metadata_lite.h>
#include <google/protobuf/generated_message_reflection.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/generated_enum_reflection.h>
#include <google/protobuf/unknown_field_set.h>
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>
#define PROTOBUF_INTERNAL_EXPORT_market_2dtrader_2eproto
PROTOBUF_NAMESPACE_OPEN
namespace internal {
class AnyMetadata;
}  // namespace internal
PROTOBUF_NAMESPACE_CLOSE

// Internal implementation detail -- do not use these members.
struct TableStruct_market_2dtrader_2eproto {
  static const uint32_t offsets[];
};
extern const ::PROTOBUF_NAMESPACE_ID::internal::DescriptorTable descriptor_table_market_2dtrader_2eproto;
namespace market_trader {
class ActiveInstrumentReq;
struct ActiveInstrumentReqDefaultTypeInternal;
extern ActiveInstrumentReqDefaultTypeInternal _ActiveInstrumentReq_default_instance_;
class ActiveInstrumentRsp;
struct ActiveInstrumentRspDefaultTypeInternal;
extern ActiveInstrumentRspDefaultTypeInternal _ActiveInstrumentRsp_default_instance_;
class MarketStateReq;
struct MarketStateReqDefaultTypeInternal;
extern MarketStateReqDefaultTypeInternal _MarketStateReq_default_instance_;
class MarketStateRsp;
struct MarketStateRspDefaultTypeInternal;
extern MarketStateRspDefaultTypeInternal _MarketStateRsp_default_instance_;
class QryInstrumentReq;
struct QryInstrumentReqDefaultTypeInternal;
extern QryInstrumentReqDefaultTypeInternal _QryInstrumentReq_default_instance_;
class QryInstrumentRsp;
struct QryInstrumentRspDefaultTypeInternal;
extern QryInstrumentRspDefaultTypeInternal _QryInstrumentRsp_default_instance_;
class message;
struct messageDefaultTypeInternal;
extern messageDefaultTypeInternal _message_default_instance_;
}  // namespace market_trader
PROTOBUF_NAMESPACE_OPEN
template<> ::market_trader::ActiveInstrumentReq* Arena::CreateMaybeMessage<::market_trader::ActiveInstrumentReq>(Arena*);
template<> ::market_trader::ActiveInstrumentRsp* Arena::CreateMaybeMessage<::market_trader::ActiveInstrumentRsp>(Arena*);
template<> ::market_trader::MarketStateReq* Arena::CreateMaybeMessage<::market_trader::MarketStateReq>(Arena*);
template<> ::market_trader::MarketStateRsp* Arena::CreateMaybeMessage<::market_trader::MarketStateRsp>(Arena*);
template<> ::market_trader::QryInstrumentReq* Arena::CreateMaybeMessage<::market_trader::QryInstrumentReq>(Arena*);
template<> ::market_trader::QryInstrumentRsp* Arena::CreateMaybeMessage<::market_trader::QryInstrumentRsp>(Arena*);
template<> ::market_trader::message* Arena::CreateMaybeMessage<::market_trader::message>(Arena*);
PROTOBUF_NAMESPACE_CLOSE
namespace market_trader {

enum ActiveInstrumentReq_InstrumentType : int {
  ActiveInstrumentReq_InstrumentType_reserve = 0,
  ActiveInstrumentReq_InstrumentType_futures = 1,
  ActiveInstrumentReq_InstrumentType_options = 2,
  ActiveInstrumentReq_InstrumentType_futures_options = 3,
  ActiveInstrumentReq_InstrumentType_ActiveInstrumentReq_InstrumentType_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  ActiveInstrumentReq_InstrumentType_ActiveInstrumentReq_InstrumentType_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
bool ActiveInstrumentReq_InstrumentType_IsValid(int value);
constexpr ActiveInstrumentReq_InstrumentType ActiveInstrumentReq_InstrumentType_InstrumentType_MIN = ActiveInstrumentReq_InstrumentType_reserve;
constexpr ActiveInstrumentReq_InstrumentType ActiveInstrumentReq_InstrumentType_InstrumentType_MAX = ActiveInstrumentReq_InstrumentType_futures_options;
constexpr int ActiveInstrumentReq_InstrumentType_InstrumentType_ARRAYSIZE = ActiveInstrumentReq_InstrumentType_InstrumentType_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* ActiveInstrumentReq_InstrumentType_descriptor();
template<typename T>
inline const std::string& ActiveInstrumentReq_InstrumentType_Name(T enum_t_value) {
  static_assert(::std::is_same<T, ActiveInstrumentReq_InstrumentType>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function ActiveInstrumentReq_InstrumentType_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    ActiveInstrumentReq_InstrumentType_descriptor(), enum_t_value);
}
inline bool ActiveInstrumentReq_InstrumentType_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, ActiveInstrumentReq_InstrumentType* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<ActiveInstrumentReq_InstrumentType>(
    ActiveInstrumentReq_InstrumentType_descriptor(), name, value);
}
enum MarketStateReq_MarketState : int {
  MarketStateReq_MarketState_reserve = 0,
  MarketStateReq_MarketState_day_open = 1,
  MarketStateReq_MarketState_day_close = 2,
  MarketStateReq_MarketState_night_open = 3,
  MarketStateReq_MarketState_night_close = 4,
  MarketStateReq_MarketState_MarketStateReq_MarketState_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  MarketStateReq_MarketState_MarketStateReq_MarketState_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
bool MarketStateReq_MarketState_IsValid(int value);
constexpr MarketStateReq_MarketState MarketStateReq_MarketState_MarketState_MIN = MarketStateReq_MarketState_reserve;
constexpr MarketStateReq_MarketState MarketStateReq_MarketState_MarketState_MAX = MarketStateReq_MarketState_night_close;
constexpr int MarketStateReq_MarketState_MarketState_ARRAYSIZE = MarketStateReq_MarketState_MarketState_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* MarketStateReq_MarketState_descriptor();
template<typename T>
inline const std::string& MarketStateReq_MarketState_Name(T enum_t_value) {
  static_assert(::std::is_same<T, MarketStateReq_MarketState>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function MarketStateReq_MarketState_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    MarketStateReq_MarketState_descriptor(), enum_t_value);
}
inline bool MarketStateReq_MarketState_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, MarketStateReq_MarketState* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<MarketStateReq_MarketState>(
    MarketStateReq_MarketState_descriptor(), name, value);
}
enum Result : int {
  Result_INVALID = 0,
  success = 1,
  failed = 2,
  Result_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  Result_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
bool Result_IsValid(int value);
constexpr Result Result_MIN = Result_INVALID;
constexpr Result Result_MAX = failed;
constexpr int Result_ARRAYSIZE = Result_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* Result_descriptor();
template<typename T>
inline const std::string& Result_Name(T enum_t_value) {
  static_assert(::std::is_same<T, Result>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function Result_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    Result_descriptor(), enum_t_value);
}
inline bool Result_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, Result* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<Result>(
    Result_descriptor(), name, value);
}
// ===================================================================

class message final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:market_trader.message) */ {
 public:
  inline message() : message(nullptr) {}
  ~message() override;
  explicit PROTOBUF_CONSTEXPR message(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  message(const message& from);
  message(message&& from) noexcept
    : message() {
    *this = ::std::move(from);
  }

  inline message& operator=(const message& from) {
    CopyFrom(from);
    return *this;
  }
  inline message& operator=(message&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const message& default_instance() {
    return *internal_default_instance();
  }
  enum MessageTypeCase {
    kActiveInstrumentReq = 1,
    kActiveInstrumentRsp = 2,
    kQryInstrumentReq = 3,
    kQryInstrumentRsp = 4,
    kMarketStateReq = 5,
    kMarketStateRsp = 6,
    MESSAGETYPE_NOT_SET = 0,
  };

  static inline const message* internal_default_instance() {
    return reinterpret_cast<const message*>(
               &_message_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  friend void swap(message& a, message& b) {
    a.Swap(&b);
  }
  inline void Swap(message* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(message* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  message* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<message>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const message& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const message& from) {
    message::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(message* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "market_trader.message";
  }
  protected:
  explicit message(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kActiveInstrumentReqFieldNumber = 1,
    kActiveInstrumentRspFieldNumber = 2,
    kQryInstrumentReqFieldNumber = 3,
    kQryInstrumentRspFieldNumber = 4,
    kMarketStateReqFieldNumber = 5,
    kMarketStateRspFieldNumber = 6,
  };
  // .market_trader.ActiveInstrumentReq active_instrument_req = 1;
  bool has_active_instrument_req() const;
  private:
  bool _internal_has_active_instrument_req() const;
  public:
  void clear_active_instrument_req();
  const ::market_trader::ActiveInstrumentReq& active_instrument_req() const;
  PROTOBUF_NODISCARD ::market_trader::ActiveInstrumentReq* release_active_instrument_req();
  ::market_trader::ActiveInstrumentReq* mutable_active_instrument_req();
  void set_allocated_active_instrument_req(::market_trader::ActiveInstrumentReq* active_instrument_req);
  private:
  const ::market_trader::ActiveInstrumentReq& _internal_active_instrument_req() const;
  ::market_trader::ActiveInstrumentReq* _internal_mutable_active_instrument_req();
  public:
  void unsafe_arena_set_allocated_active_instrument_req(
      ::market_trader::ActiveInstrumentReq* active_instrument_req);
  ::market_trader::ActiveInstrumentReq* unsafe_arena_release_active_instrument_req();

  // .market_trader.ActiveInstrumentRsp active_instrument_rsp = 2;
  bool has_active_instrument_rsp() const;
  private:
  bool _internal_has_active_instrument_rsp() const;
  public:
  void clear_active_instrument_rsp();
  const ::market_trader::ActiveInstrumentRsp& active_instrument_rsp() const;
  PROTOBUF_NODISCARD ::market_trader::ActiveInstrumentRsp* release_active_instrument_rsp();
  ::market_trader::ActiveInstrumentRsp* mutable_active_instrument_rsp();
  void set_allocated_active_instrument_rsp(::market_trader::ActiveInstrumentRsp* active_instrument_rsp);
  private:
  const ::market_trader::ActiveInstrumentRsp& _internal_active_instrument_rsp() const;
  ::market_trader::ActiveInstrumentRsp* _internal_mutable_active_instrument_rsp();
  public:
  void unsafe_arena_set_allocated_active_instrument_rsp(
      ::market_trader::ActiveInstrumentRsp* active_instrument_rsp);
  ::market_trader::ActiveInstrumentRsp* unsafe_arena_release_active_instrument_rsp();

  // .market_trader.QryInstrumentReq qry_instrument_req = 3;
  bool has_qry_instrument_req() const;
  private:
  bool _internal_has_qry_instrument_req() const;
  public:
  void clear_qry_instrument_req();
  const ::market_trader::QryInstrumentReq& qry_instrument_req() const;
  PROTOBUF_NODISCARD ::market_trader::QryInstrumentReq* release_qry_instrument_req();
  ::market_trader::QryInstrumentReq* mutable_qry_instrument_req();
  void set_allocated_qry_instrument_req(::market_trader::QryInstrumentReq* qry_instrument_req);
  private:
  const ::market_trader::QryInstrumentReq& _internal_qry_instrument_req() const;
  ::market_trader::QryInstrumentReq* _internal_mutable_qry_instrument_req();
  public:
  void unsafe_arena_set_allocated_qry_instrument_req(
      ::market_trader::QryInstrumentReq* qry_instrument_req);
  ::market_trader::QryInstrumentReq* unsafe_arena_release_qry_instrument_req();

  // .market_trader.QryInstrumentRsp qry_instrument_rsp = 4;
  bool has_qry_instrument_rsp() const;
  private:
  bool _internal_has_qry_instrument_rsp() const;
  public:
  void clear_qry_instrument_rsp();
  const ::market_trader::QryInstrumentRsp& qry_instrument_rsp() const;
  PROTOBUF_NODISCARD ::market_trader::QryInstrumentRsp* release_qry_instrument_rsp();
  ::market_trader::QryInstrumentRsp* mutable_qry_instrument_rsp();
  void set_allocated_qry_instrument_rsp(::market_trader::QryInstrumentRsp* qry_instrument_rsp);
  private:
  const ::market_trader::QryInstrumentRsp& _internal_qry_instrument_rsp() const;
  ::market_trader::QryInstrumentRsp* _internal_mutable_qry_instrument_rsp();
  public:
  void unsafe_arena_set_allocated_qry_instrument_rsp(
      ::market_trader::QryInstrumentRsp* qry_instrument_rsp);
  ::market_trader::QryInstrumentRsp* unsafe_arena_release_qry_instrument_rsp();

  // .market_trader.MarketStateReq market_state_req = 5;
  bool has_market_state_req() const;
  private:
  bool _internal_has_market_state_req() const;
  public:
  void clear_market_state_req();
  const ::market_trader::MarketStateReq& market_state_req() const;
  PROTOBUF_NODISCARD ::market_trader::MarketStateReq* release_market_state_req();
  ::market_trader::MarketStateReq* mutable_market_state_req();
  void set_allocated_market_state_req(::market_trader::MarketStateReq* market_state_req);
  private:
  const ::market_trader::MarketStateReq& _internal_market_state_req() const;
  ::market_trader::MarketStateReq* _internal_mutable_market_state_req();
  public:
  void unsafe_arena_set_allocated_market_state_req(
      ::market_trader::MarketStateReq* market_state_req);
  ::market_trader::MarketStateReq* unsafe_arena_release_market_state_req();

  // .market_trader.MarketStateRsp market_state_rsp = 6;
  bool has_market_state_rsp() const;
  private:
  bool _internal_has_market_state_rsp() const;
  public:
  void clear_market_state_rsp();
  const ::market_trader::MarketStateRsp& market_state_rsp() const;
  PROTOBUF_NODISCARD ::market_trader::MarketStateRsp* release_market_state_rsp();
  ::market_trader::MarketStateRsp* mutable_market_state_rsp();
  void set_allocated_market_state_rsp(::market_trader::MarketStateRsp* market_state_rsp);
  private:
  const ::market_trader::MarketStateRsp& _internal_market_state_rsp() const;
  ::market_trader::MarketStateRsp* _internal_mutable_market_state_rsp();
  public:
  void unsafe_arena_set_allocated_market_state_rsp(
      ::market_trader::MarketStateRsp* market_state_rsp);
  ::market_trader::MarketStateRsp* unsafe_arena_release_market_state_rsp();

  void clear_MessageType();
  MessageTypeCase MessageType_case() const;
  // @@protoc_insertion_point(class_scope:market_trader.message)
 private:
  class _Internal;
  void set_has_active_instrument_req();
  void set_has_active_instrument_rsp();
  void set_has_qry_instrument_req();
  void set_has_qry_instrument_rsp();
  void set_has_market_state_req();
  void set_has_market_state_rsp();

  inline bool has_MessageType() const;
  inline void clear_has_MessageType();

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    union MessageTypeUnion {
      constexpr MessageTypeUnion() : _constinit_{} {}
        ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized _constinit_;
      ::market_trader::ActiveInstrumentReq* active_instrument_req_;
      ::market_trader::ActiveInstrumentRsp* active_instrument_rsp_;
      ::market_trader::QryInstrumentReq* qry_instrument_req_;
      ::market_trader::QryInstrumentRsp* qry_instrument_rsp_;
      ::market_trader::MarketStateReq* market_state_req_;
      ::market_trader::MarketStateRsp* market_state_rsp_;
    } MessageType_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    uint32_t _oneof_case_[1];

  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_market_2dtrader_2eproto;
};
// -------------------------------------------------------------------

class QryInstrumentRsp final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:market_trader.QryInstrumentRsp) */ {
 public:
  inline QryInstrumentRsp() : QryInstrumentRsp(nullptr) {}
  ~QryInstrumentRsp() override;
  explicit PROTOBUF_CONSTEXPR QryInstrumentRsp(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  QryInstrumentRsp(const QryInstrumentRsp& from);
  QryInstrumentRsp(QryInstrumentRsp&& from) noexcept
    : QryInstrumentRsp() {
    *this = ::std::move(from);
  }

  inline QryInstrumentRsp& operator=(const QryInstrumentRsp& from) {
    CopyFrom(from);
    return *this;
  }
  inline QryInstrumentRsp& operator=(QryInstrumentRsp&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const QryInstrumentRsp& default_instance() {
    return *internal_default_instance();
  }
  static inline const QryInstrumentRsp* internal_default_instance() {
    return reinterpret_cast<const QryInstrumentRsp*>(
               &_QryInstrumentRsp_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  friend void swap(QryInstrumentRsp& a, QryInstrumentRsp& b) {
    a.Swap(&b);
  }
  inline void Swap(QryInstrumentRsp* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(QryInstrumentRsp* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  QryInstrumentRsp* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<QryInstrumentRsp>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const QryInstrumentRsp& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const QryInstrumentRsp& from) {
    QryInstrumentRsp::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(QryInstrumentRsp* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "market_trader.QryInstrumentRsp";
  }
  protected:
  explicit QryInstrumentRsp(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kInstrumentIdFieldNumber = 3,
    kExchangeIdFieldNumber = 4,
    kResultFieldNumber = 1,
    kFinishFlagFieldNumber = 2,
    kIsTradeFieldNumber = 11,
    kTicksizeFieldNumber = 5,
    kTradeuintFieldNumber = 6,
    kMinLimitVolumeFieldNumber = 7,
    kMaxLimitVolumeFieldNumber = 8,
    kMinMarketVolumeFieldNumber = 9,
    kMaxMarketVolumeFieldNumber = 10,
  };
  // string instrument_id = 3;
  void clear_instrument_id();
  const std::string& instrument_id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_instrument_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_instrument_id();
  PROTOBUF_NODISCARD std::string* release_instrument_id();
  void set_allocated_instrument_id(std::string* instrument_id);
  private:
  const std::string& _internal_instrument_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_instrument_id(const std::string& value);
  std::string* _internal_mutable_instrument_id();
  public:

  // string exchange_id = 4;
  void clear_exchange_id();
  const std::string& exchange_id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_exchange_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_exchange_id();
  PROTOBUF_NODISCARD std::string* release_exchange_id();
  void set_allocated_exchange_id(std::string* exchange_id);
  private:
  const std::string& _internal_exchange_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_exchange_id(const std::string& value);
  std::string* _internal_mutable_exchange_id();
  public:

  // .market_trader.Result result = 1;
  void clear_result();
  ::market_trader::Result result() const;
  void set_result(::market_trader::Result value);
  private:
  ::market_trader::Result _internal_result() const;
  void _internal_set_result(::market_trader::Result value);
  public:

  // bool finish_flag = 2;
  void clear_finish_flag();
  bool finish_flag() const;
  void set_finish_flag(bool value);
  private:
  bool _internal_finish_flag() const;
  void _internal_set_finish_flag(bool value);
  public:

  // bool is_trade = 11;
  void clear_is_trade();
  bool is_trade() const;
  void set_is_trade(bool value);
  private:
  bool _internal_is_trade() const;
  void _internal_set_is_trade(bool value);
  public:

  // double ticksize = 5;
  void clear_ticksize();
  double ticksize() const;
  void set_ticksize(double value);
  private:
  double _internal_ticksize() const;
  void _internal_set_ticksize(double value);
  public:

  // double tradeuint = 6;
  void clear_tradeuint();
  double tradeuint() const;
  void set_tradeuint(double value);
  private:
  double _internal_tradeuint() const;
  void _internal_set_tradeuint(double value);
  public:

  // uint32 min_limit_volume = 7;
  void clear_min_limit_volume();
  uint32_t min_limit_volume() const;
  void set_min_limit_volume(uint32_t value);
  private:
  uint32_t _internal_min_limit_volume() const;
  void _internal_set_min_limit_volume(uint32_t value);
  public:

  // uint32 max_limit_volume = 8;
  void clear_max_limit_volume();
  uint32_t max_limit_volume() const;
  void set_max_limit_volume(uint32_t value);
  private:
  uint32_t _internal_max_limit_volume() const;
  void _internal_set_max_limit_volume(uint32_t value);
  public:

  // uint32 min_market_volume = 9;
  void clear_min_market_volume();
  uint32_t min_market_volume() const;
  void set_min_market_volume(uint32_t value);
  private:
  uint32_t _internal_min_market_volume() const;
  void _internal_set_min_market_volume(uint32_t value);
  public:

  // uint32 max_market_volume = 10;
  void clear_max_market_volume();
  uint32_t max_market_volume() const;
  void set_max_market_volume(uint32_t value);
  private:
  uint32_t _internal_max_market_volume() const;
  void _internal_set_max_market_volume(uint32_t value);
  public:

  // @@protoc_insertion_point(class_scope:market_trader.QryInstrumentRsp)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr instrument_id_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr exchange_id_;
    int result_;
    bool finish_flag_;
    bool is_trade_;
    double ticksize_;
    double tradeuint_;
    uint32_t min_limit_volume_;
    uint32_t max_limit_volume_;
    uint32_t min_market_volume_;
    uint32_t max_market_volume_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_market_2dtrader_2eproto;
};
// -------------------------------------------------------------------

class QryInstrumentReq final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:market_trader.QryInstrumentReq) */ {
 public:
  inline QryInstrumentReq() : QryInstrumentReq(nullptr) {}
  ~QryInstrumentReq() override;
  explicit PROTOBUF_CONSTEXPR QryInstrumentReq(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  QryInstrumentReq(const QryInstrumentReq& from);
  QryInstrumentReq(QryInstrumentReq&& from) noexcept
    : QryInstrumentReq() {
    *this = ::std::move(from);
  }

  inline QryInstrumentReq& operator=(const QryInstrumentReq& from) {
    CopyFrom(from);
    return *this;
  }
  inline QryInstrumentReq& operator=(QryInstrumentReq&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const QryInstrumentReq& default_instance() {
    return *internal_default_instance();
  }
  static inline const QryInstrumentReq* internal_default_instance() {
    return reinterpret_cast<const QryInstrumentReq*>(
               &_QryInstrumentReq_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  friend void swap(QryInstrumentReq& a, QryInstrumentReq& b) {
    a.Swap(&b);
  }
  inline void Swap(QryInstrumentReq* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(QryInstrumentReq* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  QryInstrumentReq* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<QryInstrumentReq>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const QryInstrumentReq& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const QryInstrumentReq& from) {
    QryInstrumentReq::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(QryInstrumentReq* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "market_trader.QryInstrumentReq";
  }
  protected:
  explicit QryInstrumentReq(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kIdentityFieldNumber = 1,
  };
  // string identity = 1;
  void clear_identity();
  const std::string& identity() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_identity(ArgT0&& arg0, ArgT... args);
  std::string* mutable_identity();
  PROTOBUF_NODISCARD std::string* release_identity();
  void set_allocated_identity(std::string* identity);
  private:
  const std::string& _internal_identity() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_identity(const std::string& value);
  std::string* _internal_mutable_identity();
  public:

  // @@protoc_insertion_point(class_scope:market_trader.QryInstrumentReq)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr identity_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_market_2dtrader_2eproto;
};
// -------------------------------------------------------------------

class ActiveInstrumentRsp final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:market_trader.ActiveInstrumentRsp) */ {
 public:
  inline ActiveInstrumentRsp() : ActiveInstrumentRsp(nullptr) {}
  ~ActiveInstrumentRsp() override;
  explicit PROTOBUF_CONSTEXPR ActiveInstrumentRsp(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ActiveInstrumentRsp(const ActiveInstrumentRsp& from);
  ActiveInstrumentRsp(ActiveInstrumentRsp&& from) noexcept
    : ActiveInstrumentRsp() {
    *this = ::std::move(from);
  }

  inline ActiveInstrumentRsp& operator=(const ActiveInstrumentRsp& from) {
    CopyFrom(from);
    return *this;
  }
  inline ActiveInstrumentRsp& operator=(ActiveInstrumentRsp&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ActiveInstrumentRsp& default_instance() {
    return *internal_default_instance();
  }
  static inline const ActiveInstrumentRsp* internal_default_instance() {
    return reinterpret_cast<const ActiveInstrumentRsp*>(
               &_ActiveInstrumentRsp_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  friend void swap(ActiveInstrumentRsp& a, ActiveInstrumentRsp& b) {
    a.Swap(&b);
  }
  inline void Swap(ActiveInstrumentRsp* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ActiveInstrumentRsp* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ActiveInstrumentRsp* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ActiveInstrumentRsp>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ActiveInstrumentRsp& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const ActiveInstrumentRsp& from) {
    ActiveInstrumentRsp::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ActiveInstrumentRsp* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "market_trader.ActiveInstrumentRsp";
  }
  protected:
  explicit ActiveInstrumentRsp(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kInstrumensFieldNumber = 1,
    kExchangeIDFieldNumber = 2,
    kBIsLastFieldNumber = 3,
  };
  // string instrumens = 1;
  void clear_instrumens();
  const std::string& instrumens() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_instrumens(ArgT0&& arg0, ArgT... args);
  std::string* mutable_instrumens();
  PROTOBUF_NODISCARD std::string* release_instrumens();
  void set_allocated_instrumens(std::string* instrumens);
  private:
  const std::string& _internal_instrumens() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_instrumens(const std::string& value);
  std::string* _internal_mutable_instrumens();
  public:

  // string ExchangeID = 2;
  void clear_exchangeid();
  const std::string& exchangeid() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_exchangeid(ArgT0&& arg0, ArgT... args);
  std::string* mutable_exchangeid();
  PROTOBUF_NODISCARD std::string* release_exchangeid();
  void set_allocated_exchangeid(std::string* exchangeid);
  private:
  const std::string& _internal_exchangeid() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_exchangeid(const std::string& value);
  std::string* _internal_mutable_exchangeid();
  public:

  // uint32 bIsLast = 3;
  void clear_bislast();
  uint32_t bislast() const;
  void set_bislast(uint32_t value);
  private:
  uint32_t _internal_bislast() const;
  void _internal_set_bislast(uint32_t value);
  public:

  // @@protoc_insertion_point(class_scope:market_trader.ActiveInstrumentRsp)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr instrumens_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr exchangeid_;
    uint32_t bislast_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_market_2dtrader_2eproto;
};
// -------------------------------------------------------------------

class ActiveInstrumentReq final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:market_trader.ActiveInstrumentReq) */ {
 public:
  inline ActiveInstrumentReq() : ActiveInstrumentReq(nullptr) {}
  ~ActiveInstrumentReq() override;
  explicit PROTOBUF_CONSTEXPR ActiveInstrumentReq(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ActiveInstrumentReq(const ActiveInstrumentReq& from);
  ActiveInstrumentReq(ActiveInstrumentReq&& from) noexcept
    : ActiveInstrumentReq() {
    *this = ::std::move(from);
  }

  inline ActiveInstrumentReq& operator=(const ActiveInstrumentReq& from) {
    CopyFrom(from);
    return *this;
  }
  inline ActiveInstrumentReq& operator=(ActiveInstrumentReq&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ActiveInstrumentReq& default_instance() {
    return *internal_default_instance();
  }
  static inline const ActiveInstrumentReq* internal_default_instance() {
    return reinterpret_cast<const ActiveInstrumentReq*>(
               &_ActiveInstrumentReq_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    4;

  friend void swap(ActiveInstrumentReq& a, ActiveInstrumentReq& b) {
    a.Swap(&b);
  }
  inline void Swap(ActiveInstrumentReq* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ActiveInstrumentReq* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ActiveInstrumentReq* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ActiveInstrumentReq>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ActiveInstrumentReq& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const ActiveInstrumentReq& from) {
    ActiveInstrumentReq::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ActiveInstrumentReq* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "market_trader.ActiveInstrumentReq";
  }
  protected:
  explicit ActiveInstrumentReq(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef ActiveInstrumentReq_InstrumentType InstrumentType;
  static constexpr InstrumentType reserve =
    ActiveInstrumentReq_InstrumentType_reserve;
  static constexpr InstrumentType futures =
    ActiveInstrumentReq_InstrumentType_futures;
  static constexpr InstrumentType options =
    ActiveInstrumentReq_InstrumentType_options;
  static constexpr InstrumentType futures_options =
    ActiveInstrumentReq_InstrumentType_futures_options;
  static inline bool InstrumentType_IsValid(int value) {
    return ActiveInstrumentReq_InstrumentType_IsValid(value);
  }
  static constexpr InstrumentType InstrumentType_MIN =
    ActiveInstrumentReq_InstrumentType_InstrumentType_MIN;
  static constexpr InstrumentType InstrumentType_MAX =
    ActiveInstrumentReq_InstrumentType_InstrumentType_MAX;
  static constexpr int InstrumentType_ARRAYSIZE =
    ActiveInstrumentReq_InstrumentType_InstrumentType_ARRAYSIZE;
  static inline const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
  InstrumentType_descriptor() {
    return ActiveInstrumentReq_InstrumentType_descriptor();
  }
  template<typename T>
  static inline const std::string& InstrumentType_Name(T enum_t_value) {
    static_assert(::std::is_same<T, InstrumentType>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function InstrumentType_Name.");
    return ActiveInstrumentReq_InstrumentType_Name(enum_t_value);
  }
  static inline bool InstrumentType_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name,
      InstrumentType* value) {
    return ActiveInstrumentReq_InstrumentType_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  enum : int {
    kInstrumentTypeFieldNumber = 1,
  };
  // .market_trader.ActiveInstrumentReq.InstrumentType instrument_type = 1;
  void clear_instrument_type();
  ::market_trader::ActiveInstrumentReq_InstrumentType instrument_type() const;
  void set_instrument_type(::market_trader::ActiveInstrumentReq_InstrumentType value);
  private:
  ::market_trader::ActiveInstrumentReq_InstrumentType _internal_instrument_type() const;
  void _internal_set_instrument_type(::market_trader::ActiveInstrumentReq_InstrumentType value);
  public:

  // @@protoc_insertion_point(class_scope:market_trader.ActiveInstrumentReq)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    int instrument_type_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_market_2dtrader_2eproto;
};
// -------------------------------------------------------------------

class MarketStateReq final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:market_trader.MarketStateReq) */ {
 public:
  inline MarketStateReq() : MarketStateReq(nullptr) {}
  ~MarketStateReq() override;
  explicit PROTOBUF_CONSTEXPR MarketStateReq(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  MarketStateReq(const MarketStateReq& from);
  MarketStateReq(MarketStateReq&& from) noexcept
    : MarketStateReq() {
    *this = ::std::move(from);
  }

  inline MarketStateReq& operator=(const MarketStateReq& from) {
    CopyFrom(from);
    return *this;
  }
  inline MarketStateReq& operator=(MarketStateReq&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const MarketStateReq& default_instance() {
    return *internal_default_instance();
  }
  static inline const MarketStateReq* internal_default_instance() {
    return reinterpret_cast<const MarketStateReq*>(
               &_MarketStateReq_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    5;

  friend void swap(MarketStateReq& a, MarketStateReq& b) {
    a.Swap(&b);
  }
  inline void Swap(MarketStateReq* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(MarketStateReq* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  MarketStateReq* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<MarketStateReq>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const MarketStateReq& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const MarketStateReq& from) {
    MarketStateReq::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(MarketStateReq* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "market_trader.MarketStateReq";
  }
  protected:
  explicit MarketStateReq(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef MarketStateReq_MarketState MarketState;
  static constexpr MarketState reserve =
    MarketStateReq_MarketState_reserve;
  static constexpr MarketState day_open =
    MarketStateReq_MarketState_day_open;
  static constexpr MarketState day_close =
    MarketStateReq_MarketState_day_close;
  static constexpr MarketState night_open =
    MarketStateReq_MarketState_night_open;
  static constexpr MarketState night_close =
    MarketStateReq_MarketState_night_close;
  static inline bool MarketState_IsValid(int value) {
    return MarketStateReq_MarketState_IsValid(value);
  }
  static constexpr MarketState MarketState_MIN =
    MarketStateReq_MarketState_MarketState_MIN;
  static constexpr MarketState MarketState_MAX =
    MarketStateReq_MarketState_MarketState_MAX;
  static constexpr int MarketState_ARRAYSIZE =
    MarketStateReq_MarketState_MarketState_ARRAYSIZE;
  static inline const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
  MarketState_descriptor() {
    return MarketStateReq_MarketState_descriptor();
  }
  template<typename T>
  static inline const std::string& MarketState_Name(T enum_t_value) {
    static_assert(::std::is_same<T, MarketState>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function MarketState_Name.");
    return MarketStateReq_MarketState_Name(enum_t_value);
  }
  static inline bool MarketState_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name,
      MarketState* value) {
    return MarketStateReq_MarketState_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  enum : int {
    kDateFieldNumber = 2,
    kMarketStateFieldNumber = 1,
    kIsLastFieldNumber = 3,
  };
  // string date = 2;
  void clear_date();
  const std::string& date() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_date(ArgT0&& arg0, ArgT... args);
  std::string* mutable_date();
  PROTOBUF_NODISCARD std::string* release_date();
  void set_allocated_date(std::string* date);
  private:
  const std::string& _internal_date() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_date(const std::string& value);
  std::string* _internal_mutable_date();
  public:

  // .market_trader.MarketStateReq.MarketState market_state = 1;
  void clear_market_state();
  ::market_trader::MarketStateReq_MarketState market_state() const;
  void set_market_state(::market_trader::MarketStateReq_MarketState value);
  private:
  ::market_trader::MarketStateReq_MarketState _internal_market_state() const;
  void _internal_set_market_state(::market_trader::MarketStateReq_MarketState value);
  public:

  // bool is_last = 3;
  void clear_is_last();
  bool is_last() const;
  void set_is_last(bool value);
  private:
  bool _internal_is_last() const;
  void _internal_set_is_last(bool value);
  public:

  // @@protoc_insertion_point(class_scope:market_trader.MarketStateReq)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr date_;
    int market_state_;
    bool is_last_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_market_2dtrader_2eproto;
};
// -------------------------------------------------------------------

class MarketStateRsp final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:market_trader.MarketStateRsp) */ {
 public:
  inline MarketStateRsp() : MarketStateRsp(nullptr) {}
  ~MarketStateRsp() override;
  explicit PROTOBUF_CONSTEXPR MarketStateRsp(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  MarketStateRsp(const MarketStateRsp& from);
  MarketStateRsp(MarketStateRsp&& from) noexcept
    : MarketStateRsp() {
    *this = ::std::move(from);
  }

  inline MarketStateRsp& operator=(const MarketStateRsp& from) {
    CopyFrom(from);
    return *this;
  }
  inline MarketStateRsp& operator=(MarketStateRsp&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const MarketStateRsp& default_instance() {
    return *internal_default_instance();
  }
  static inline const MarketStateRsp* internal_default_instance() {
    return reinterpret_cast<const MarketStateRsp*>(
               &_MarketStateRsp_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    6;

  friend void swap(MarketStateRsp& a, MarketStateRsp& b) {
    a.Swap(&b);
  }
  inline void Swap(MarketStateRsp* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(MarketStateRsp* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  MarketStateRsp* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<MarketStateRsp>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const MarketStateRsp& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const MarketStateRsp& from) {
    MarketStateRsp::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(MarketStateRsp* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "market_trader.MarketStateRsp";
  }
  protected:
  explicit MarketStateRsp(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kResultFieldNumber = 1,
  };
  // uint32 result = 1;
  void clear_result();
  uint32_t result() const;
  void set_result(uint32_t value);
  private:
  uint32_t _internal_result() const;
  void _internal_set_result(uint32_t value);
  public:

  // @@protoc_insertion_point(class_scope:market_trader.MarketStateRsp)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    uint32_t result_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_market_2dtrader_2eproto;
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// message

// .market_trader.ActiveInstrumentReq active_instrument_req = 1;
inline bool message::_internal_has_active_instrument_req() const {
  return MessageType_case() == kActiveInstrumentReq;
}
inline bool message::has_active_instrument_req() const {
  return _internal_has_active_instrument_req();
}
inline void message::set_has_active_instrument_req() {
  _impl_._oneof_case_[0] = kActiveInstrumentReq;
}
inline void message::clear_active_instrument_req() {
  if (_internal_has_active_instrument_req()) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.MessageType_.active_instrument_req_;
    }
    clear_has_MessageType();
  }
}
inline ::market_trader::ActiveInstrumentReq* message::release_active_instrument_req() {
  // @@protoc_insertion_point(field_release:market_trader.message.active_instrument_req)
  if (_internal_has_active_instrument_req()) {
    clear_has_MessageType();
    ::market_trader::ActiveInstrumentReq* temp = _impl_.MessageType_.active_instrument_req_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.MessageType_.active_instrument_req_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::market_trader::ActiveInstrumentReq& message::_internal_active_instrument_req() const {
  return _internal_has_active_instrument_req()
      ? *_impl_.MessageType_.active_instrument_req_
      : reinterpret_cast< ::market_trader::ActiveInstrumentReq&>(::market_trader::_ActiveInstrumentReq_default_instance_);
}
inline const ::market_trader::ActiveInstrumentReq& message::active_instrument_req() const {
  // @@protoc_insertion_point(field_get:market_trader.message.active_instrument_req)
  return _internal_active_instrument_req();
}
inline ::market_trader::ActiveInstrumentReq* message::unsafe_arena_release_active_instrument_req() {
  // @@protoc_insertion_point(field_unsafe_arena_release:market_trader.message.active_instrument_req)
  if (_internal_has_active_instrument_req()) {
    clear_has_MessageType();
    ::market_trader::ActiveInstrumentReq* temp = _impl_.MessageType_.active_instrument_req_;
    _impl_.MessageType_.active_instrument_req_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void message::unsafe_arena_set_allocated_active_instrument_req(::market_trader::ActiveInstrumentReq* active_instrument_req) {
  clear_MessageType();
  if (active_instrument_req) {
    set_has_active_instrument_req();
    _impl_.MessageType_.active_instrument_req_ = active_instrument_req;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:market_trader.message.active_instrument_req)
}
inline ::market_trader::ActiveInstrumentReq* message::_internal_mutable_active_instrument_req() {
  if (!_internal_has_active_instrument_req()) {
    clear_MessageType();
    set_has_active_instrument_req();
    _impl_.MessageType_.active_instrument_req_ = CreateMaybeMessage< ::market_trader::ActiveInstrumentReq >(GetArenaForAllocation());
  }
  return _impl_.MessageType_.active_instrument_req_;
}
inline ::market_trader::ActiveInstrumentReq* message::mutable_active_instrument_req() {
  ::market_trader::ActiveInstrumentReq* _msg = _internal_mutable_active_instrument_req();
  // @@protoc_insertion_point(field_mutable:market_trader.message.active_instrument_req)
  return _msg;
}

// .market_trader.ActiveInstrumentRsp active_instrument_rsp = 2;
inline bool message::_internal_has_active_instrument_rsp() const {
  return MessageType_case() == kActiveInstrumentRsp;
}
inline bool message::has_active_instrument_rsp() const {
  return _internal_has_active_instrument_rsp();
}
inline void message::set_has_active_instrument_rsp() {
  _impl_._oneof_case_[0] = kActiveInstrumentRsp;
}
inline void message::clear_active_instrument_rsp() {
  if (_internal_has_active_instrument_rsp()) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.MessageType_.active_instrument_rsp_;
    }
    clear_has_MessageType();
  }
}
inline ::market_trader::ActiveInstrumentRsp* message::release_active_instrument_rsp() {
  // @@protoc_insertion_point(field_release:market_trader.message.active_instrument_rsp)
  if (_internal_has_active_instrument_rsp()) {
    clear_has_MessageType();
    ::market_trader::ActiveInstrumentRsp* temp = _impl_.MessageType_.active_instrument_rsp_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.MessageType_.active_instrument_rsp_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::market_trader::ActiveInstrumentRsp& message::_internal_active_instrument_rsp() const {
  return _internal_has_active_instrument_rsp()
      ? *_impl_.MessageType_.active_instrument_rsp_
      : reinterpret_cast< ::market_trader::ActiveInstrumentRsp&>(::market_trader::_ActiveInstrumentRsp_default_instance_);
}
inline const ::market_trader::ActiveInstrumentRsp& message::active_instrument_rsp() const {
  // @@protoc_insertion_point(field_get:market_trader.message.active_instrument_rsp)
  return _internal_active_instrument_rsp();
}
inline ::market_trader::ActiveInstrumentRsp* message::unsafe_arena_release_active_instrument_rsp() {
  // @@protoc_insertion_point(field_unsafe_arena_release:market_trader.message.active_instrument_rsp)
  if (_internal_has_active_instrument_rsp()) {
    clear_has_MessageType();
    ::market_trader::ActiveInstrumentRsp* temp = _impl_.MessageType_.active_instrument_rsp_;
    _impl_.MessageType_.active_instrument_rsp_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void message::unsafe_arena_set_allocated_active_instrument_rsp(::market_trader::ActiveInstrumentRsp* active_instrument_rsp) {
  clear_MessageType();
  if (active_instrument_rsp) {
    set_has_active_instrument_rsp();
    _impl_.MessageType_.active_instrument_rsp_ = active_instrument_rsp;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:market_trader.message.active_instrument_rsp)
}
inline ::market_trader::ActiveInstrumentRsp* message::_internal_mutable_active_instrument_rsp() {
  if (!_internal_has_active_instrument_rsp()) {
    clear_MessageType();
    set_has_active_instrument_rsp();
    _impl_.MessageType_.active_instrument_rsp_ = CreateMaybeMessage< ::market_trader::ActiveInstrumentRsp >(GetArenaForAllocation());
  }
  return _impl_.MessageType_.active_instrument_rsp_;
}
inline ::market_trader::ActiveInstrumentRsp* message::mutable_active_instrument_rsp() {
  ::market_trader::ActiveInstrumentRsp* _msg = _internal_mutable_active_instrument_rsp();
  // @@protoc_insertion_point(field_mutable:market_trader.message.active_instrument_rsp)
  return _msg;
}

// .market_trader.QryInstrumentReq qry_instrument_req = 3;
inline bool message::_internal_has_qry_instrument_req() const {
  return MessageType_case() == kQryInstrumentReq;
}
inline bool message::has_qry_instrument_req() const {
  return _internal_has_qry_instrument_req();
}
inline void message::set_has_qry_instrument_req() {
  _impl_._oneof_case_[0] = kQryInstrumentReq;
}
inline void message::clear_qry_instrument_req() {
  if (_internal_has_qry_instrument_req()) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.MessageType_.qry_instrument_req_;
    }
    clear_has_MessageType();
  }
}
inline ::market_trader::QryInstrumentReq* message::release_qry_instrument_req() {
  // @@protoc_insertion_point(field_release:market_trader.message.qry_instrument_req)
  if (_internal_has_qry_instrument_req()) {
    clear_has_MessageType();
    ::market_trader::QryInstrumentReq* temp = _impl_.MessageType_.qry_instrument_req_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.MessageType_.qry_instrument_req_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::market_trader::QryInstrumentReq& message::_internal_qry_instrument_req() const {
  return _internal_has_qry_instrument_req()
      ? *_impl_.MessageType_.qry_instrument_req_
      : reinterpret_cast< ::market_trader::QryInstrumentReq&>(::market_trader::_QryInstrumentReq_default_instance_);
}
inline const ::market_trader::QryInstrumentReq& message::qry_instrument_req() const {
  // @@protoc_insertion_point(field_get:market_trader.message.qry_instrument_req)
  return _internal_qry_instrument_req();
}
inline ::market_trader::QryInstrumentReq* message::unsafe_arena_release_qry_instrument_req() {
  // @@protoc_insertion_point(field_unsafe_arena_release:market_trader.message.qry_instrument_req)
  if (_internal_has_qry_instrument_req()) {
    clear_has_MessageType();
    ::market_trader::QryInstrumentReq* temp = _impl_.MessageType_.qry_instrument_req_;
    _impl_.MessageType_.qry_instrument_req_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void message::unsafe_arena_set_allocated_qry_instrument_req(::market_trader::QryInstrumentReq* qry_instrument_req) {
  clear_MessageType();
  if (qry_instrument_req) {
    set_has_qry_instrument_req();
    _impl_.MessageType_.qry_instrument_req_ = qry_instrument_req;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:market_trader.message.qry_instrument_req)
}
inline ::market_trader::QryInstrumentReq* message::_internal_mutable_qry_instrument_req() {
  if (!_internal_has_qry_instrument_req()) {
    clear_MessageType();
    set_has_qry_instrument_req();
    _impl_.MessageType_.qry_instrument_req_ = CreateMaybeMessage< ::market_trader::QryInstrumentReq >(GetArenaForAllocation());
  }
  return _impl_.MessageType_.qry_instrument_req_;
}
inline ::market_trader::QryInstrumentReq* message::mutable_qry_instrument_req() {
  ::market_trader::QryInstrumentReq* _msg = _internal_mutable_qry_instrument_req();
  // @@protoc_insertion_point(field_mutable:market_trader.message.qry_instrument_req)
  return _msg;
}

// .market_trader.QryInstrumentRsp qry_instrument_rsp = 4;
inline bool message::_internal_has_qry_instrument_rsp() const {
  return MessageType_case() == kQryInstrumentRsp;
}
inline bool message::has_qry_instrument_rsp() const {
  return _internal_has_qry_instrument_rsp();
}
inline void message::set_has_qry_instrument_rsp() {
  _impl_._oneof_case_[0] = kQryInstrumentRsp;
}
inline void message::clear_qry_instrument_rsp() {
  if (_internal_has_qry_instrument_rsp()) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.MessageType_.qry_instrument_rsp_;
    }
    clear_has_MessageType();
  }
}
inline ::market_trader::QryInstrumentRsp* message::release_qry_instrument_rsp() {
  // @@protoc_insertion_point(field_release:market_trader.message.qry_instrument_rsp)
  if (_internal_has_qry_instrument_rsp()) {
    clear_has_MessageType();
    ::market_trader::QryInstrumentRsp* temp = _impl_.MessageType_.qry_instrument_rsp_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.MessageType_.qry_instrument_rsp_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::market_trader::QryInstrumentRsp& message::_internal_qry_instrument_rsp() const {
  return _internal_has_qry_instrument_rsp()
      ? *_impl_.MessageType_.qry_instrument_rsp_
      : reinterpret_cast< ::market_trader::QryInstrumentRsp&>(::market_trader::_QryInstrumentRsp_default_instance_);
}
inline const ::market_trader::QryInstrumentRsp& message::qry_instrument_rsp() const {
  // @@protoc_insertion_point(field_get:market_trader.message.qry_instrument_rsp)
  return _internal_qry_instrument_rsp();
}
inline ::market_trader::QryInstrumentRsp* message::unsafe_arena_release_qry_instrument_rsp() {
  // @@protoc_insertion_point(field_unsafe_arena_release:market_trader.message.qry_instrument_rsp)
  if (_internal_has_qry_instrument_rsp()) {
    clear_has_MessageType();
    ::market_trader::QryInstrumentRsp* temp = _impl_.MessageType_.qry_instrument_rsp_;
    _impl_.MessageType_.qry_instrument_rsp_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void message::unsafe_arena_set_allocated_qry_instrument_rsp(::market_trader::QryInstrumentRsp* qry_instrument_rsp) {
  clear_MessageType();
  if (qry_instrument_rsp) {
    set_has_qry_instrument_rsp();
    _impl_.MessageType_.qry_instrument_rsp_ = qry_instrument_rsp;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:market_trader.message.qry_instrument_rsp)
}
inline ::market_trader::QryInstrumentRsp* message::_internal_mutable_qry_instrument_rsp() {
  if (!_internal_has_qry_instrument_rsp()) {
    clear_MessageType();
    set_has_qry_instrument_rsp();
    _impl_.MessageType_.qry_instrument_rsp_ = CreateMaybeMessage< ::market_trader::QryInstrumentRsp >(GetArenaForAllocation());
  }
  return _impl_.MessageType_.qry_instrument_rsp_;
}
inline ::market_trader::QryInstrumentRsp* message::mutable_qry_instrument_rsp() {
  ::market_trader::QryInstrumentRsp* _msg = _internal_mutable_qry_instrument_rsp();
  // @@protoc_insertion_point(field_mutable:market_trader.message.qry_instrument_rsp)
  return _msg;
}

// .market_trader.MarketStateReq market_state_req = 5;
inline bool message::_internal_has_market_state_req() const {
  return MessageType_case() == kMarketStateReq;
}
inline bool message::has_market_state_req() const {
  return _internal_has_market_state_req();
}
inline void message::set_has_market_state_req() {
  _impl_._oneof_case_[0] = kMarketStateReq;
}
inline void message::clear_market_state_req() {
  if (_internal_has_market_state_req()) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.MessageType_.market_state_req_;
    }
    clear_has_MessageType();
  }
}
inline ::market_trader::MarketStateReq* message::release_market_state_req() {
  // @@protoc_insertion_point(field_release:market_trader.message.market_state_req)
  if (_internal_has_market_state_req()) {
    clear_has_MessageType();
    ::market_trader::MarketStateReq* temp = _impl_.MessageType_.market_state_req_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.MessageType_.market_state_req_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::market_trader::MarketStateReq& message::_internal_market_state_req() const {
  return _internal_has_market_state_req()
      ? *_impl_.MessageType_.market_state_req_
      : reinterpret_cast< ::market_trader::MarketStateReq&>(::market_trader::_MarketStateReq_default_instance_);
}
inline const ::market_trader::MarketStateReq& message::market_state_req() const {
  // @@protoc_insertion_point(field_get:market_trader.message.market_state_req)
  return _internal_market_state_req();
}
inline ::market_trader::MarketStateReq* message::unsafe_arena_release_market_state_req() {
  // @@protoc_insertion_point(field_unsafe_arena_release:market_trader.message.market_state_req)
  if (_internal_has_market_state_req()) {
    clear_has_MessageType();
    ::market_trader::MarketStateReq* temp = _impl_.MessageType_.market_state_req_;
    _impl_.MessageType_.market_state_req_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void message::unsafe_arena_set_allocated_market_state_req(::market_trader::MarketStateReq* market_state_req) {
  clear_MessageType();
  if (market_state_req) {
    set_has_market_state_req();
    _impl_.MessageType_.market_state_req_ = market_state_req;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:market_trader.message.market_state_req)
}
inline ::market_trader::MarketStateReq* message::_internal_mutable_market_state_req() {
  if (!_internal_has_market_state_req()) {
    clear_MessageType();
    set_has_market_state_req();
    _impl_.MessageType_.market_state_req_ = CreateMaybeMessage< ::market_trader::MarketStateReq >(GetArenaForAllocation());
  }
  return _impl_.MessageType_.market_state_req_;
}
inline ::market_trader::MarketStateReq* message::mutable_market_state_req() {
  ::market_trader::MarketStateReq* _msg = _internal_mutable_market_state_req();
  // @@protoc_insertion_point(field_mutable:market_trader.message.market_state_req)
  return _msg;
}

// .market_trader.MarketStateRsp market_state_rsp = 6;
inline bool message::_internal_has_market_state_rsp() const {
  return MessageType_case() == kMarketStateRsp;
}
inline bool message::has_market_state_rsp() const {
  return _internal_has_market_state_rsp();
}
inline void message::set_has_market_state_rsp() {
  _impl_._oneof_case_[0] = kMarketStateRsp;
}
inline void message::clear_market_state_rsp() {
  if (_internal_has_market_state_rsp()) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.MessageType_.market_state_rsp_;
    }
    clear_has_MessageType();
  }
}
inline ::market_trader::MarketStateRsp* message::release_market_state_rsp() {
  // @@protoc_insertion_point(field_release:market_trader.message.market_state_rsp)
  if (_internal_has_market_state_rsp()) {
    clear_has_MessageType();
    ::market_trader::MarketStateRsp* temp = _impl_.MessageType_.market_state_rsp_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.MessageType_.market_state_rsp_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::market_trader::MarketStateRsp& message::_internal_market_state_rsp() const {
  return _internal_has_market_state_rsp()
      ? *_impl_.MessageType_.market_state_rsp_
      : reinterpret_cast< ::market_trader::MarketStateRsp&>(::market_trader::_MarketStateRsp_default_instance_);
}
inline const ::market_trader::MarketStateRsp& message::market_state_rsp() const {
  // @@protoc_insertion_point(field_get:market_trader.message.market_state_rsp)
  return _internal_market_state_rsp();
}
inline ::market_trader::MarketStateRsp* message::unsafe_arena_release_market_state_rsp() {
  // @@protoc_insertion_point(field_unsafe_arena_release:market_trader.message.market_state_rsp)
  if (_internal_has_market_state_rsp()) {
    clear_has_MessageType();
    ::market_trader::MarketStateRsp* temp = _impl_.MessageType_.market_state_rsp_;
    _impl_.MessageType_.market_state_rsp_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void message::unsafe_arena_set_allocated_market_state_rsp(::market_trader::MarketStateRsp* market_state_rsp) {
  clear_MessageType();
  if (market_state_rsp) {
    set_has_market_state_rsp();
    _impl_.MessageType_.market_state_rsp_ = market_state_rsp;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:market_trader.message.market_state_rsp)
}
inline ::market_trader::MarketStateRsp* message::_internal_mutable_market_state_rsp() {
  if (!_internal_has_market_state_rsp()) {
    clear_MessageType();
    set_has_market_state_rsp();
    _impl_.MessageType_.market_state_rsp_ = CreateMaybeMessage< ::market_trader::MarketStateRsp >(GetArenaForAllocation());
  }
  return _impl_.MessageType_.market_state_rsp_;
}
inline ::market_trader::MarketStateRsp* message::mutable_market_state_rsp() {
  ::market_trader::MarketStateRsp* _msg = _internal_mutable_market_state_rsp();
  // @@protoc_insertion_point(field_mutable:market_trader.message.market_state_rsp)
  return _msg;
}

inline bool message::has_MessageType() const {
  return MessageType_case() != MESSAGETYPE_NOT_SET;
}
inline void message::clear_has_MessageType() {
  _impl_._oneof_case_[0] = MESSAGETYPE_NOT_SET;
}
inline message::MessageTypeCase message::MessageType_case() const {
  return message::MessageTypeCase(_impl_._oneof_case_[0]);
}
// -------------------------------------------------------------------

// QryInstrumentRsp

// .market_trader.Result result = 1;
inline void QryInstrumentRsp::clear_result() {
  _impl_.result_ = 0;
}
inline ::market_trader::Result QryInstrumentRsp::_internal_result() const {
  return static_cast< ::market_trader::Result >(_impl_.result_);
}
inline ::market_trader::Result QryInstrumentRsp::result() const {
  // @@protoc_insertion_point(field_get:market_trader.QryInstrumentRsp.result)
  return _internal_result();
}
inline void QryInstrumentRsp::_internal_set_result(::market_trader::Result value) {
  
  _impl_.result_ = value;
}
inline void QryInstrumentRsp::set_result(::market_trader::Result value) {
  _internal_set_result(value);
  // @@protoc_insertion_point(field_set:market_trader.QryInstrumentRsp.result)
}

// bool finish_flag = 2;
inline void QryInstrumentRsp::clear_finish_flag() {
  _impl_.finish_flag_ = false;
}
inline bool QryInstrumentRsp::_internal_finish_flag() const {
  return _impl_.finish_flag_;
}
inline bool QryInstrumentRsp::finish_flag() const {
  // @@protoc_insertion_point(field_get:market_trader.QryInstrumentRsp.finish_flag)
  return _internal_finish_flag();
}
inline void QryInstrumentRsp::_internal_set_finish_flag(bool value) {
  
  _impl_.finish_flag_ = value;
}
inline void QryInstrumentRsp::set_finish_flag(bool value) {
  _internal_set_finish_flag(value);
  // @@protoc_insertion_point(field_set:market_trader.QryInstrumentRsp.finish_flag)
}

// string instrument_id = 3;
inline void QryInstrumentRsp::clear_instrument_id() {
  _impl_.instrument_id_.ClearToEmpty();
}
inline const std::string& QryInstrumentRsp::instrument_id() const {
  // @@protoc_insertion_point(field_get:market_trader.QryInstrumentRsp.instrument_id)
  return _internal_instrument_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void QryInstrumentRsp::set_instrument_id(ArgT0&& arg0, ArgT... args) {
 
 _impl_.instrument_id_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:market_trader.QryInstrumentRsp.instrument_id)
}
inline std::string* QryInstrumentRsp::mutable_instrument_id() {
  std::string* _s = _internal_mutable_instrument_id();
  // @@protoc_insertion_point(field_mutable:market_trader.QryInstrumentRsp.instrument_id)
  return _s;
}
inline const std::string& QryInstrumentRsp::_internal_instrument_id() const {
  return _impl_.instrument_id_.Get();
}
inline void QryInstrumentRsp::_internal_set_instrument_id(const std::string& value) {
  
  _impl_.instrument_id_.Set(value, GetArenaForAllocation());
}
inline std::string* QryInstrumentRsp::_internal_mutable_instrument_id() {
  
  return _impl_.instrument_id_.Mutable(GetArenaForAllocation());
}
inline std::string* QryInstrumentRsp::release_instrument_id() {
  // @@protoc_insertion_point(field_release:market_trader.QryInstrumentRsp.instrument_id)
  return _impl_.instrument_id_.Release();
}
inline void QryInstrumentRsp::set_allocated_instrument_id(std::string* instrument_id) {
  if (instrument_id != nullptr) {
    
  } else {
    
  }
  _impl_.instrument_id_.SetAllocated(instrument_id, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.instrument_id_.IsDefault()) {
    _impl_.instrument_id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:market_trader.QryInstrumentRsp.instrument_id)
}

// string exchange_id = 4;
inline void QryInstrumentRsp::clear_exchange_id() {
  _impl_.exchange_id_.ClearToEmpty();
}
inline const std::string& QryInstrumentRsp::exchange_id() const {
  // @@protoc_insertion_point(field_get:market_trader.QryInstrumentRsp.exchange_id)
  return _internal_exchange_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void QryInstrumentRsp::set_exchange_id(ArgT0&& arg0, ArgT... args) {
 
 _impl_.exchange_id_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:market_trader.QryInstrumentRsp.exchange_id)
}
inline std::string* QryInstrumentRsp::mutable_exchange_id() {
  std::string* _s = _internal_mutable_exchange_id();
  // @@protoc_insertion_point(field_mutable:market_trader.QryInstrumentRsp.exchange_id)
  return _s;
}
inline const std::string& QryInstrumentRsp::_internal_exchange_id() const {
  return _impl_.exchange_id_.Get();
}
inline void QryInstrumentRsp::_internal_set_exchange_id(const std::string& value) {
  
  _impl_.exchange_id_.Set(value, GetArenaForAllocation());
}
inline std::string* QryInstrumentRsp::_internal_mutable_exchange_id() {
  
  return _impl_.exchange_id_.Mutable(GetArenaForAllocation());
}
inline std::string* QryInstrumentRsp::release_exchange_id() {
  // @@protoc_insertion_point(field_release:market_trader.QryInstrumentRsp.exchange_id)
  return _impl_.exchange_id_.Release();
}
inline void QryInstrumentRsp::set_allocated_exchange_id(std::string* exchange_id) {
  if (exchange_id != nullptr) {
    
  } else {
    
  }
  _impl_.exchange_id_.SetAllocated(exchange_id, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.exchange_id_.IsDefault()) {
    _impl_.exchange_id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:market_trader.QryInstrumentRsp.exchange_id)
}

// double ticksize = 5;
inline void QryInstrumentRsp::clear_ticksize() {
  _impl_.ticksize_ = 0;
}
inline double QryInstrumentRsp::_internal_ticksize() const {
  return _impl_.ticksize_;
}
inline double QryInstrumentRsp::ticksize() const {
  // @@protoc_insertion_point(field_get:market_trader.QryInstrumentRsp.ticksize)
  return _internal_ticksize();
}
inline void QryInstrumentRsp::_internal_set_ticksize(double value) {
  
  _impl_.ticksize_ = value;
}
inline void QryInstrumentRsp::set_ticksize(double value) {
  _internal_set_ticksize(value);
  // @@protoc_insertion_point(field_set:market_trader.QryInstrumentRsp.ticksize)
}

// double tradeuint = 6;
inline void QryInstrumentRsp::clear_tradeuint() {
  _impl_.tradeuint_ = 0;
}
inline double QryInstrumentRsp::_internal_tradeuint() const {
  return _impl_.tradeuint_;
}
inline double QryInstrumentRsp::tradeuint() const {
  // @@protoc_insertion_point(field_get:market_trader.QryInstrumentRsp.tradeuint)
  return _internal_tradeuint();
}
inline void QryInstrumentRsp::_internal_set_tradeuint(double value) {
  
  _impl_.tradeuint_ = value;
}
inline void QryInstrumentRsp::set_tradeuint(double value) {
  _internal_set_tradeuint(value);
  // @@protoc_insertion_point(field_set:market_trader.QryInstrumentRsp.tradeuint)
}

// uint32 min_limit_volume = 7;
inline void QryInstrumentRsp::clear_min_limit_volume() {
  _impl_.min_limit_volume_ = 0u;
}
inline uint32_t QryInstrumentRsp::_internal_min_limit_volume() const {
  return _impl_.min_limit_volume_;
}
inline uint32_t QryInstrumentRsp::min_limit_volume() const {
  // @@protoc_insertion_point(field_get:market_trader.QryInstrumentRsp.min_limit_volume)
  return _internal_min_limit_volume();
}
inline void QryInstrumentRsp::_internal_set_min_limit_volume(uint32_t value) {
  
  _impl_.min_limit_volume_ = value;
}
inline void QryInstrumentRsp::set_min_limit_volume(uint32_t value) {
  _internal_set_min_limit_volume(value);
  // @@protoc_insertion_point(field_set:market_trader.QryInstrumentRsp.min_limit_volume)
}

// uint32 max_limit_volume = 8;
inline void QryInstrumentRsp::clear_max_limit_volume() {
  _impl_.max_limit_volume_ = 0u;
}
inline uint32_t QryInstrumentRsp::_internal_max_limit_volume() const {
  return _impl_.max_limit_volume_;
}
inline uint32_t QryInstrumentRsp::max_limit_volume() const {
  // @@protoc_insertion_point(field_get:market_trader.QryInstrumentRsp.max_limit_volume)
  return _internal_max_limit_volume();
}
inline void QryInstrumentRsp::_internal_set_max_limit_volume(uint32_t value) {
  
  _impl_.max_limit_volume_ = value;
}
inline void QryInstrumentRsp::set_max_limit_volume(uint32_t value) {
  _internal_set_max_limit_volume(value);
  // @@protoc_insertion_point(field_set:market_trader.QryInstrumentRsp.max_limit_volume)
}

// uint32 min_market_volume = 9;
inline void QryInstrumentRsp::clear_min_market_volume() {
  _impl_.min_market_volume_ = 0u;
}
inline uint32_t QryInstrumentRsp::_internal_min_market_volume() const {
  return _impl_.min_market_volume_;
}
inline uint32_t QryInstrumentRsp::min_market_volume() const {
  // @@protoc_insertion_point(field_get:market_trader.QryInstrumentRsp.min_market_volume)
  return _internal_min_market_volume();
}
inline void QryInstrumentRsp::_internal_set_min_market_volume(uint32_t value) {
  
  _impl_.min_market_volume_ = value;
}
inline void QryInstrumentRsp::set_min_market_volume(uint32_t value) {
  _internal_set_min_market_volume(value);
  // @@protoc_insertion_point(field_set:market_trader.QryInstrumentRsp.min_market_volume)
}

// uint32 max_market_volume = 10;
inline void QryInstrumentRsp::clear_max_market_volume() {
  _impl_.max_market_volume_ = 0u;
}
inline uint32_t QryInstrumentRsp::_internal_max_market_volume() const {
  return _impl_.max_market_volume_;
}
inline uint32_t QryInstrumentRsp::max_market_volume() const {
  // @@protoc_insertion_point(field_get:market_trader.QryInstrumentRsp.max_market_volume)
  return _internal_max_market_volume();
}
inline void QryInstrumentRsp::_internal_set_max_market_volume(uint32_t value) {
  
  _impl_.max_market_volume_ = value;
}
inline void QryInstrumentRsp::set_max_market_volume(uint32_t value) {
  _internal_set_max_market_volume(value);
  // @@protoc_insertion_point(field_set:market_trader.QryInstrumentRsp.max_market_volume)
}

// bool is_trade = 11;
inline void QryInstrumentRsp::clear_is_trade() {
  _impl_.is_trade_ = false;
}
inline bool QryInstrumentRsp::_internal_is_trade() const {
  return _impl_.is_trade_;
}
inline bool QryInstrumentRsp::is_trade() const {
  // @@protoc_insertion_point(field_get:market_trader.QryInstrumentRsp.is_trade)
  return _internal_is_trade();
}
inline void QryInstrumentRsp::_internal_set_is_trade(bool value) {
  
  _impl_.is_trade_ = value;
}
inline void QryInstrumentRsp::set_is_trade(bool value) {
  _internal_set_is_trade(value);
  // @@protoc_insertion_point(field_set:market_trader.QryInstrumentRsp.is_trade)
}

// -------------------------------------------------------------------

// QryInstrumentReq

// string identity = 1;
inline void QryInstrumentReq::clear_identity() {
  _impl_.identity_.ClearToEmpty();
}
inline const std::string& QryInstrumentReq::identity() const {
  // @@protoc_insertion_point(field_get:market_trader.QryInstrumentReq.identity)
  return _internal_identity();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void QryInstrumentReq::set_identity(ArgT0&& arg0, ArgT... args) {
 
 _impl_.identity_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:market_trader.QryInstrumentReq.identity)
}
inline std::string* QryInstrumentReq::mutable_identity() {
  std::string* _s = _internal_mutable_identity();
  // @@protoc_insertion_point(field_mutable:market_trader.QryInstrumentReq.identity)
  return _s;
}
inline const std::string& QryInstrumentReq::_internal_identity() const {
  return _impl_.identity_.Get();
}
inline void QryInstrumentReq::_internal_set_identity(const std::string& value) {
  
  _impl_.identity_.Set(value, GetArenaForAllocation());
}
inline std::string* QryInstrumentReq::_internal_mutable_identity() {
  
  return _impl_.identity_.Mutable(GetArenaForAllocation());
}
inline std::string* QryInstrumentReq::release_identity() {
  // @@protoc_insertion_point(field_release:market_trader.QryInstrumentReq.identity)
  return _impl_.identity_.Release();
}
inline void QryInstrumentReq::set_allocated_identity(std::string* identity) {
  if (identity != nullptr) {
    
  } else {
    
  }
  _impl_.identity_.SetAllocated(identity, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.identity_.IsDefault()) {
    _impl_.identity_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:market_trader.QryInstrumentReq.identity)
}

// -------------------------------------------------------------------

// ActiveInstrumentRsp

// string instrumens = 1;
inline void ActiveInstrumentRsp::clear_instrumens() {
  _impl_.instrumens_.ClearToEmpty();
}
inline const std::string& ActiveInstrumentRsp::instrumens() const {
  // @@protoc_insertion_point(field_get:market_trader.ActiveInstrumentRsp.instrumens)
  return _internal_instrumens();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ActiveInstrumentRsp::set_instrumens(ArgT0&& arg0, ArgT... args) {
 
 _impl_.instrumens_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:market_trader.ActiveInstrumentRsp.instrumens)
}
inline std::string* ActiveInstrumentRsp::mutable_instrumens() {
  std::string* _s = _internal_mutable_instrumens();
  // @@protoc_insertion_point(field_mutable:market_trader.ActiveInstrumentRsp.instrumens)
  return _s;
}
inline const std::string& ActiveInstrumentRsp::_internal_instrumens() const {
  return _impl_.instrumens_.Get();
}
inline void ActiveInstrumentRsp::_internal_set_instrumens(const std::string& value) {
  
  _impl_.instrumens_.Set(value, GetArenaForAllocation());
}
inline std::string* ActiveInstrumentRsp::_internal_mutable_instrumens() {
  
  return _impl_.instrumens_.Mutable(GetArenaForAllocation());
}
inline std::string* ActiveInstrumentRsp::release_instrumens() {
  // @@protoc_insertion_point(field_release:market_trader.ActiveInstrumentRsp.instrumens)
  return _impl_.instrumens_.Release();
}
inline void ActiveInstrumentRsp::set_allocated_instrumens(std::string* instrumens) {
  if (instrumens != nullptr) {
    
  } else {
    
  }
  _impl_.instrumens_.SetAllocated(instrumens, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.instrumens_.IsDefault()) {
    _impl_.instrumens_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:market_trader.ActiveInstrumentRsp.instrumens)
}

// string ExchangeID = 2;
inline void ActiveInstrumentRsp::clear_exchangeid() {
  _impl_.exchangeid_.ClearToEmpty();
}
inline const std::string& ActiveInstrumentRsp::exchangeid() const {
  // @@protoc_insertion_point(field_get:market_trader.ActiveInstrumentRsp.ExchangeID)
  return _internal_exchangeid();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ActiveInstrumentRsp::set_exchangeid(ArgT0&& arg0, ArgT... args) {
 
 _impl_.exchangeid_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:market_trader.ActiveInstrumentRsp.ExchangeID)
}
inline std::string* ActiveInstrumentRsp::mutable_exchangeid() {
  std::string* _s = _internal_mutable_exchangeid();
  // @@protoc_insertion_point(field_mutable:market_trader.ActiveInstrumentRsp.ExchangeID)
  return _s;
}
inline const std::string& ActiveInstrumentRsp::_internal_exchangeid() const {
  return _impl_.exchangeid_.Get();
}
inline void ActiveInstrumentRsp::_internal_set_exchangeid(const std::string& value) {
  
  _impl_.exchangeid_.Set(value, GetArenaForAllocation());
}
inline std::string* ActiveInstrumentRsp::_internal_mutable_exchangeid() {
  
  return _impl_.exchangeid_.Mutable(GetArenaForAllocation());
}
inline std::string* ActiveInstrumentRsp::release_exchangeid() {
  // @@protoc_insertion_point(field_release:market_trader.ActiveInstrumentRsp.ExchangeID)
  return _impl_.exchangeid_.Release();
}
inline void ActiveInstrumentRsp::set_allocated_exchangeid(std::string* exchangeid) {
  if (exchangeid != nullptr) {
    
  } else {
    
  }
  _impl_.exchangeid_.SetAllocated(exchangeid, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.exchangeid_.IsDefault()) {
    _impl_.exchangeid_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:market_trader.ActiveInstrumentRsp.ExchangeID)
}

// uint32 bIsLast = 3;
inline void ActiveInstrumentRsp::clear_bislast() {
  _impl_.bislast_ = 0u;
}
inline uint32_t ActiveInstrumentRsp::_internal_bislast() const {
  return _impl_.bislast_;
}
inline uint32_t ActiveInstrumentRsp::bislast() const {
  // @@protoc_insertion_point(field_get:market_trader.ActiveInstrumentRsp.bIsLast)
  return _internal_bislast();
}
inline void ActiveInstrumentRsp::_internal_set_bislast(uint32_t value) {
  
  _impl_.bislast_ = value;
}
inline void ActiveInstrumentRsp::set_bislast(uint32_t value) {
  _internal_set_bislast(value);
  // @@protoc_insertion_point(field_set:market_trader.ActiveInstrumentRsp.bIsLast)
}

// -------------------------------------------------------------------

// ActiveInstrumentReq

// .market_trader.ActiveInstrumentReq.InstrumentType instrument_type = 1;
inline void ActiveInstrumentReq::clear_instrument_type() {
  _impl_.instrument_type_ = 0;
}
inline ::market_trader::ActiveInstrumentReq_InstrumentType ActiveInstrumentReq::_internal_instrument_type() const {
  return static_cast< ::market_trader::ActiveInstrumentReq_InstrumentType >(_impl_.instrument_type_);
}
inline ::market_trader::ActiveInstrumentReq_InstrumentType ActiveInstrumentReq::instrument_type() const {
  // @@protoc_insertion_point(field_get:market_trader.ActiveInstrumentReq.instrument_type)
  return _internal_instrument_type();
}
inline void ActiveInstrumentReq::_internal_set_instrument_type(::market_trader::ActiveInstrumentReq_InstrumentType value) {
  
  _impl_.instrument_type_ = value;
}
inline void ActiveInstrumentReq::set_instrument_type(::market_trader::ActiveInstrumentReq_InstrumentType value) {
  _internal_set_instrument_type(value);
  // @@protoc_insertion_point(field_set:market_trader.ActiveInstrumentReq.instrument_type)
}

// -------------------------------------------------------------------

// MarketStateReq

// .market_trader.MarketStateReq.MarketState market_state = 1;
inline void MarketStateReq::clear_market_state() {
  _impl_.market_state_ = 0;
}
inline ::market_trader::MarketStateReq_MarketState MarketStateReq::_internal_market_state() const {
  return static_cast< ::market_trader::MarketStateReq_MarketState >(_impl_.market_state_);
}
inline ::market_trader::MarketStateReq_MarketState MarketStateReq::market_state() const {
  // @@protoc_insertion_point(field_get:market_trader.MarketStateReq.market_state)
  return _internal_market_state();
}
inline void MarketStateReq::_internal_set_market_state(::market_trader::MarketStateReq_MarketState value) {
  
  _impl_.market_state_ = value;
}
inline void MarketStateReq::set_market_state(::market_trader::MarketStateReq_MarketState value) {
  _internal_set_market_state(value);
  // @@protoc_insertion_point(field_set:market_trader.MarketStateReq.market_state)
}

// string date = 2;
inline void MarketStateReq::clear_date() {
  _impl_.date_.ClearToEmpty();
}
inline const std::string& MarketStateReq::date() const {
  // @@protoc_insertion_point(field_get:market_trader.MarketStateReq.date)
  return _internal_date();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void MarketStateReq::set_date(ArgT0&& arg0, ArgT... args) {
 
 _impl_.date_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:market_trader.MarketStateReq.date)
}
inline std::string* MarketStateReq::mutable_date() {
  std::string* _s = _internal_mutable_date();
  // @@protoc_insertion_point(field_mutable:market_trader.MarketStateReq.date)
  return _s;
}
inline const std::string& MarketStateReq::_internal_date() const {
  return _impl_.date_.Get();
}
inline void MarketStateReq::_internal_set_date(const std::string& value) {
  
  _impl_.date_.Set(value, GetArenaForAllocation());
}
inline std::string* MarketStateReq::_internal_mutable_date() {
  
  return _impl_.date_.Mutable(GetArenaForAllocation());
}
inline std::string* MarketStateReq::release_date() {
  // @@protoc_insertion_point(field_release:market_trader.MarketStateReq.date)
  return _impl_.date_.Release();
}
inline void MarketStateReq::set_allocated_date(std::string* date) {
  if (date != nullptr) {
    
  } else {
    
  }
  _impl_.date_.SetAllocated(date, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.date_.IsDefault()) {
    _impl_.date_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:market_trader.MarketStateReq.date)
}

// bool is_last = 3;
inline void MarketStateReq::clear_is_last() {
  _impl_.is_last_ = false;
}
inline bool MarketStateReq::_internal_is_last() const {
  return _impl_.is_last_;
}
inline bool MarketStateReq::is_last() const {
  // @@protoc_insertion_point(field_get:market_trader.MarketStateReq.is_last)
  return _internal_is_last();
}
inline void MarketStateReq::_internal_set_is_last(bool value) {
  
  _impl_.is_last_ = value;
}
inline void MarketStateReq::set_is_last(bool value) {
  _internal_set_is_last(value);
  // @@protoc_insertion_point(field_set:market_trader.MarketStateReq.is_last)
}

// -------------------------------------------------------------------

// MarketStateRsp

// uint32 result = 1;
inline void MarketStateRsp::clear_result() {
  _impl_.result_ = 0u;
}
inline uint32_t MarketStateRsp::_internal_result() const {
  return _impl_.result_;
}
inline uint32_t MarketStateRsp::result() const {
  // @@protoc_insertion_point(field_get:market_trader.MarketStateRsp.result)
  return _internal_result();
}
inline void MarketStateRsp::_internal_set_result(uint32_t value) {
  
  _impl_.result_ = value;
}
inline void MarketStateRsp::set_result(uint32_t value) {
  _internal_set_result(value);
  // @@protoc_insertion_point(field_set:market_trader.MarketStateRsp.result)
}

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace market_trader

PROTOBUF_NAMESPACE_OPEN

template <> struct is_proto_enum< ::market_trader::ActiveInstrumentReq_InstrumentType> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::market_trader::ActiveInstrumentReq_InstrumentType>() {
  return ::market_trader::ActiveInstrumentReq_InstrumentType_descriptor();
}
template <> struct is_proto_enum< ::market_trader::MarketStateReq_MarketState> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::market_trader::MarketStateReq_MarketState>() {
  return ::market_trader::MarketStateReq_MarketState_descriptor();
}
template <> struct is_proto_enum< ::market_trader::Result> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::market_trader::Result>() {
  return ::market_trader::Result_descriptor();
}

PROTOBUF_NAMESPACE_CLOSE

// @@protoc_insertion_point(global_scope)

#include <google/protobuf/port_undef.inc>
#endif  // GOOGLE_PROTOBUF_INCLUDED_GOOGLE_PROTOBUF_INCLUDED_market_2dtrader_2eproto
